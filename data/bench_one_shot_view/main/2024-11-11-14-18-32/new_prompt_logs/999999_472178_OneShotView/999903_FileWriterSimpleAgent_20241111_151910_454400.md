Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me analyze the issue and propose a solution.

DIAGNOSIS:
Looking at the image and comparing it to the error message, there are several issues:

1. The main error is a timeout after 120s, suggesting the UI simulator couldn't complete its intended interactions
2. The skills buttons section appears to be empty or not properly rendering in the bottom portion of the screen
3. The map function for skills buttons has a logical error in its implementation that could prevent buttons from appearing

The key problems in the code are:

1. The skills mapping function is using an inline conditional that doesn't properly return elements
2. There's no fallback UI state when no skills are available
3. The height constraints might be causing layout issues

PROPOSED SOLUTION:

1. Fix the skills mapping logic to properly filter and render buttons
2. Add a fallback state when no skills are available
3. Adjust the height calculations to ensure proper rendering
4. Ensure the button click events are properly emitted

Here's the corrected code:

# Excerpt ID: b5c6c2f0-f180-43be-98de-df6ea5c499ee
```jsx main_game/templates/MainGameScene.tsx
import { useCurrentButtons } from "@/lib/useChoices.ts";
import { Sword, Shield, Zap, Heart } from 'lucide-react';
import { Card, CardHeader, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";

interface Skill {
  uid: string;
  display_name: string;
  description: string;
  stats: {
    base_damage: number;
  };
}

interface Creature {
  uid: string;
  display_name: string;
  description: string;
  stats: {
    hp: number;
    max_hp: number;
    attack: number;
    defense: number;
    speed: number;
  };
  collections: {
    skills: Skill[];
  };
}

interface GameUIData {
  entities: {
    player_creature: Creature;
    opponent_creature: Creature;
  };
}

function CreatureCard({ creature, isPlayer }: { creature: Creature; isPlayer: boolean }) {
  return (
    <Card className="w-1/3" key={creature.uid}>
      <CardHeader>
        <h3 className="text-lg font-bold">{creature.display_name}</h3>
      </CardHeader>
      <CardContent>
        <div className="mb-2 bg-gray-200 rounded-full">
          <div 
            className={`${isPlayer ? 'bg-green-500' : 'bg-red-500'} rounded-full h-2`}
            style={{
              width: `${(creature.stats.hp / creature.stats.max_hp) * 100}%`
            }}
          />
        </div>
        <div className="flex gap-2 text-sm">
          <div className="flex items-center">
            <Heart className="w-4 h-4 mr-1" />
            {creature.stats.hp}/{creature.stats.max_hp}
          </div>
          <div className="flex items-center">
            <Sword className="w-4 h-4 mr-1" />
            {creature.stats.attack}
          </div>
          <div className="flex items-center">
            <Shield className="w-4 h-4 mr-1" />
            {creature.stats.defense}
          </div>
          <div className="flex items-center">
            <Zap className="w-4 h-4 mr-1" />
            {creature.stats.speed}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

function SkillButton({ skill, onClick }: { skill: Skill; onClick: () => void }) {
  return (
    <Button 
      key={skill.uid}
      onClick={onClick}
      className="w-full h-full flex flex-col items-start p-4"
      variant="secondary"
    >
      <span className="font-bold">{skill.display_name}</span>
      <span className="text-sm">{skill.description}</span>
      <span className="text-sm mt-1">Damage: {skill.stats.base_damage}</span>
    </Button>
  );
}

export function MainGameSceneView(props: { data: GameUIData }) {
  const {
    availableButtonSlugs,
    emitButtonClick
  } = useCurrentButtons();

  const playerCreature = props.data?.entities?.player_creature;
  const opponentCreature = props.data?.entities?.opponent_creature;

  if (!playerCreature || !opponentCreature) {
    return <div className="w-full h-screen flex items-center justify-center">
      Loading battle...
    </div>;
  }

  const availableSkills = playerCreature.collections.skills.filter(skill => 
    availableButtonSlugs.includes(skill.uid)
  );

  return (
    <div className="w-full h-screen flex flex-col bg-slate-100">
      <Card className="w-full h-[10%] bg-slate-800 text-white rounded-none">
        <CardContent className="flex items-center justify-between p-4">
          <span className="font-bold">{playerCreature.display_name}</span>
          <span className="font-bold">{opponentCreature.display_name}</span>
        </CardContent>
      </Card>

      <div className="w-full h-[50%] flex items-center justify-between px-8 bg-gradient-to-b from-slate-200 to-slate-300">
        <CreatureCard creature={playerCreature} isPlayer={true} />
        <CreatureCard creature={opponentCreature} isPlayer={false} />
      </div>

      <Card className="w-full h-[40%] shadow-inner rounded-none">
        <CardContent className="p-4">
          {availableSkills.length > 0 ? (
            <div className="grid grid-cols-2 gap-4 h-full">
              {availableSkills.map((skill) => (
                <SkillButton 
                  key={skill.uid}
                  skill={skill}
                  onClick={() => emitButtonClick(skill.uid)}
                />
              ))}
            </div>
          ) : (
            <div className="flex items-center justify-center h-full">
              <p className="text-gray-500">No actions available</p>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```

The main changes made are:

1. Fixed the skills filtering logic by moving it outside the render and using a proper filter
2. Added a fallback UI state when no skills are available
3. Simplified the button rendering logic
4. Maintained all existing interfaces and prop structures
5. Ensured proper event emission with skill UIDs

These changes should resolve the timeout issue by ensuring the UI is always in a valid state for interaction.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
