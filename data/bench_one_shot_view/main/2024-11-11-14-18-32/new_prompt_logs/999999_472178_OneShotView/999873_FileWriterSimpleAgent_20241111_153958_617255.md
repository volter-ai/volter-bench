Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me analyze the issue and propose a solution.

DIAGNOSIS:
Looking at the image and comparing it with the error message, there are several issues:

1. The timeout error suggests that the UI simulator couldn't complete its intended interactions within 120 seconds, likely because it couldn't find or interact with the skill buttons.

2. In the image, I can see the creature stats cards for both Bubwool and Scizard, but there's no visible skill buttons in the lower UI area, despite the code showing we should have a grid of skill buttons.

3. The error "ECONNREFUSED" suggests there might be connectivity issues, but this is likely a secondary effect of the UI not rendering properly.

PROPOSED SOLUTION:
The main issues appear to be:

1. The skills UI section might be hidden or not properly rendered because the condition `isAvailable && (...)` in the skill button mapping could be causing buttons to not render if `availableButtonSlugs` is empty.

2. We should ensure the skills are always visible but disabled if not available, rather than completely hidden.

3. We should add proper error handling for when button slugs aren't available.

Here's the implementation:

# Excerpt ID: 71d65aeb-3f3b-40b5-860d-d983596d023b
```jsx main_game/templates/MainGameScene.tsx
import { useCurrentButtons } from "@/lib/useChoices.ts";
import { Sword, Shield, Zap, Heart } from 'lucide-react';
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";

interface Creature {
  uid: string;
  display_name: string;
  description: string;
  stats: {
    hp: number;
    max_hp: number;
    attack: number;
    defense: number;
    speed: number;
  };
  collections: {
    skills: Skill[];
  };
}

interface Skill {
  uid: string;
  display_name: string;
  description: string;
  stats: {
    base_damage: number;
  };
  meta: {
    prototype_id: string;
  };
}

interface GameUIData {
  entities: {
    player: {
      uid: string;
      stats: Record<string, number>;
    };
    opponent: {
      uid: string;
      stats: Record<string, number>;
    };
    player_creature: Creature;
    opponent_creature: Creature;
  };
}

export function MainGameSceneView(props: { data: GameUIData }) {
  const {
    availableButtonSlugs,
    emitButtonClick
  } = useCurrentButtons();

  const playerCreature = props.data?.entities?.player_creature;
  const opponentCreature = props.data?.entities?.opponent_creature;

  if (!playerCreature || !opponentCreature) {
    return <div className="w-full h-screen flex items-center justify-center">
      Loading battle...
    </div>;
  }

  const renderCreatureStats = (creature: Creature, isPlayer: boolean) => (
    <Card className={`p-4 ${isPlayer ? 'ml-auto mr-8' : 'ml-8 mr-auto'} w-64`}>
      <div className="flex flex-col gap-2">
        <h2 className="text-xl font-bold">{creature.display_name}</h2>
        <div className="w-full">
          <Progress 
            value={(creature.stats.hp / creature.stats.max_hp) * 100}
            className="h-2"
          />
          <span className="text-sm">
            {creature.stats.hp}/{creature.stats.max_hp} HP
          </span>
        </div>
        <div className="flex gap-4 mt-2">
          <div className="flex items-center">
            <Sword className="w-4 h-4 mr-1" />
            {creature.stats.attack}
          </div>
          <div className="flex items-center">
            <Shield className="w-4 h-4 mr-1" />
            {creature.stats.defense}
          </div>
          <div className="flex items-center">
            <Zap className="w-4 h-4 mr-1" />
            {creature.stats.speed}
          </div>
        </div>
      </div>
    </Card>
  );

  return (
    <div className="w-full h-screen flex flex-col bg-gradient-to-b from-blue-900 to-blue-800">
      {/* HUD */}
      <Card className="w-full p-4 rounded-none bg-black/30">
        <div className="flex justify-between items-center">
          <span className="text-white">Battle Scene</span>
          <Heart className="text-red-500" />
        </div>
      </Card>

      {/* Battlefield */}
      <div className="flex-1 flex items-center px-4">
        <div className="w-1/2 flex justify-end">
          {renderCreatureStats(playerCreature, true)}
        </div>
        <div className="w-1/2 flex justify-start">
          {renderCreatureStats(opponentCreature, false)}
        </div>
      </div>

      {/* Skills UI */}
      <Card className="min-h-[240px] bg-black/40 p-4 rounded-t-xl rounded-b-none">
        <div className="grid grid-cols-2 gap-4">
          {playerCreature.collections.skills.map((skill) => {
            const buttonId = `skill-${skill.meta.prototype_id}`;
            const isAvailable = availableButtonSlugs.includes(buttonId);
            
            return (
              <Button
                key={skill.uid}
                onClick={() => isAvailable && emitButtonClick(buttonId)}
                variant="secondary"
                className="h-auto flex flex-col items-start p-4"
                disabled={!isAvailable}
              >
                <h3 className="font-bold">{skill.display_name}</h3>
                <p className="text-sm opacity-80">{skill.description}</p>
                <span className="text-xs">Damage: {skill.stats.base_damage}</span>
              </Button>
            );
          })}
        </div>
      </Card>
    </div>
  );
}
```

Key changes made:
1. Removed the conditional rendering with `isAvailable &&` and replaced it with always rendering the button but using the `disabled` prop
2. Moved the `isAvailable` check into the onClick handler
3. Added proper button state handling through the disabled prop

These changes ensure that:
- The UI simulator can always find the buttons
- Buttons are visible but properly disabled when not available
- The interaction flow remains correct while being more reliable for testing

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
