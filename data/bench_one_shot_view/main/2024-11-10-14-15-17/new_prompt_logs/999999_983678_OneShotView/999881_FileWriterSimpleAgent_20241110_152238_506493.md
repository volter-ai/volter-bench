Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me analyze the issue and propose a solution.

DIAGNOSIS:
Looking at the image and comparing it with the error message, there are several issues:

1. The UI simulator is timing out after 120s, suggesting it's unable to interact with the buttons properly
2. The skill buttons section appears to be empty or not rendering correctly in the bottom portion
3. The map function for skills might not be handling the filtering of available buttons correctly

The main issue seems to be in the skills rendering logic where the combination of .map() and conditional rendering using && might be causing buttons to not render at all when they should be available.

PROPOSED SOLUTION:
1. Modify the skills rendering logic to properly filter and map available skills
2. Add proper key handling for the mapped elements
3. Ensure the button grid maintains proper layout even with filtered items

The changes needed:
1. Replace the current skills mapping logic with a filter().map() chain
2. Ensure proper null checking for skills array
3. Add proper defensive coding for availableButtonSlugs check

Here's the complete implementation:

# Excerpt ID: 4c44d892-8b1b-40d6-9923-8b1ab873b754
```jsx main_game/templates/MainGameScene.tsx
import { useCurrentButtons } from "@/lib/useChoices.ts";
import { Sword, Shield, Zap, Heart } from 'lucide-react';
import { Card, CardHeader, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";

interface Skill {
  uid: string;
  display_name: string;
  description: string;
  stats: {
    base_damage: number;
  };
}

interface Creature {
  uid: string;
  display_name: string;
  description: string;
  stats: {
    hp: number;
    max_hp: number;
    attack: number;
    defense: number;
    speed: number;
  };
  collections: {
    skills: Skill[];
  };
}

interface GameUIData {
  entities: {
    player_creature: Creature;
    opponent_creature: Creature;
  };
}

function CreatureCard({ creature, isPlayer }: { creature: Creature; isPlayer: boolean }) {
  return (
    <Card className="w-1/3" key={creature.uid}>
      <CardHeader>
        <h3 className="text-lg font-bold">{creature.display_name}</h3>
      </CardHeader>
      <CardContent>
        <div className="mb-2 bg-gray-200 rounded-full">
          <div 
            className={`${isPlayer ? 'bg-green-500' : 'bg-red-500'} rounded-full h-2`}
            style={{
              width: `${(creature.stats.hp / creature.stats.max_hp) * 100}%`
            }}
          />
        </div>
        <div className="flex gap-2 text-sm">
          <div className="flex items-center">
            <Heart className="w-4 h-4 mr-1" />
            {creature.stats.hp}/{creature.stats.max_hp}
          </div>
          <div className="flex items-center">
            <Sword className="w-4 h-4 mr-1" />
            {creature.stats.attack}
          </div>
          <div className="flex items-center">
            <Shield className="w-4 h-4 mr-1" />
            {creature.stats.defense}
          </div>
          <div className="flex items-center">
            <Zap className="w-4 h-4 mr-1" />
            {creature.stats.speed}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

function SkillButton({ skill, onClick }: { skill: Skill; onClick: () => void }) {
  return (
    <Button 
      key={skill.uid}
      onClick={onClick}
      className="w-full h-full flex flex-col items-start p-4"
      variant="default"
    >
      <span className="font-bold">{skill.display_name}</span>
      <span className="text-sm">{skill.description}</span>
      <span className="text-sm mt-1">Damage: {skill.stats.base_damage}</span>
    </Button>
  );
}

export function MainGameSceneView(props: { data: GameUIData }) {
  const {
    availableButtonSlugs,
    emitButtonClick
  } = useCurrentButtons();

  const playerCreature = props.data?.entities?.player_creature;
  const opponentCreature = props.data?.entities?.opponent_creature;

  if (!playerCreature || !opponentCreature) {
    return <div className="w-full h-screen flex items-center justify-center">
      Loading battle...
    </div>;
  }

  const availableSkills = playerCreature.collections.skills
    .filter(skill => availableButtonSlugs.includes(skill.uid));

  return (
    <div className="w-full h-screen flex flex-col bg-slate-100">
      {/* HUD */}
      <Card className="w-full h-[10%] bg-slate-800 text-white rounded-none">
        <CardContent className="flex items-center justify-between p-4">
          <span className="font-bold">{playerCreature.display_name}</span>
          <span className="font-bold">{opponentCreature.display_name}</span>
        </CardContent>
      </Card>

      {/* Battlefield */}
      <div className="w-full h-[50%] flex items-center justify-between px-8 bg-gradient-to-b from-slate-200 to-slate-300">
        <CreatureCard creature={playerCreature} isPlayer={true} />
        <CreatureCard creature={opponentCreature} isPlayer={false} />
      </div>

      {/* Action UI */}
      <Card className="w-full h-[40%] shadow-inner">
        <CardContent className="p-4">
          <div className="grid grid-cols-2 gap-4">
            {availableSkills.map((skill) => (
              <SkillButton 
                key={skill.uid}
                skill={skill}
                onClick={() => emitButtonClick(skill.uid)}
              />
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

The main changes are:
1. Created a filtered `availableSkills` array before rendering
2. Simplified the mapping logic by removing the inline conditional
3. Ensured proper key usage on mapped elements
4. Maintained the grid layout for consistent button placement

These changes should resolve the timeout issue by ensuring the buttons are properly rendered and interactive.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
