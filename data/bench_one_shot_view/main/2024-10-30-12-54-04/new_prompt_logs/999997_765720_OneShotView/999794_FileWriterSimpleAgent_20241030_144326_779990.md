Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for providing the detailed information and requirements. I'll explain the architecture and implementation approach, and then provide the updated code for the MainGameSceneView component.

Architecture and Implementation Approach:

1. Component Structure:
   We'll create a main container div that takes up the entire 16:9 game container. Inside this, we'll have two main sections:
   - Battlefield Display (upper 2/3)
   - User Interface (lower 1/3)

2. Battlefield Display:
   We'll use a grid layout to divide the battlefield into four quadrants:
   - Bottom-left: Player's creature (CreatureCard component)
   - Bottom-right: Player's creature status
   - Top-right: Opponent's creature (CreatureCard component)
   - Top-left: Opponent's creature status

3. User Interface:
   We'll create a flex container for the buttons and choices. We'll use the SkillButton component for skills and regular buttons for other actions.

4. Tailwind Styles:
   We'll use Tailwind classes for layout, sizing, and positioning. For example:
   - `h-screen w-screen` for full-screen container
   - `grid grid-cols-2 grid-rows-2` for the battlefield layout
   - `flex flex-col` for the user interface

5. Data Handling:
   We'll create interfaces for the main data structures (Player, Creature, Skill) to ensure type safety. We'll use optional chaining and nullish coalescing to handle potential missing data.

6. Button Handling:
   We'll use the `availableButtonSlugs` and `emitButtonClick` from `useCurrentButtons` to manage button availability and clicks.

Now, let's implement the MainGameSceneView component:

# Excerpt ID: b7ae63fc-1664-4fee-b604-f2fd1e6f71dc
```tsx main_game/templates/MainGameScene.tsx
import { useCurrentButtons } from "@/lib/useChoices.ts";
import { Sword, ArrowLeft, Repeat } from 'lucide-react';
import { CreatureCard } from "@/components/ui/custom/creature/creature_card";
import { SkillButton } from "@/components/ui/custom/skill/skill_button";
import { Button } from "@/components/ui/button";

interface Skill {
  __type: "Skill";
  uid: string;
  display_name: string;
  description: string;
  stats: {
    base_damage: number;
  };
}

interface Creature {
  __type: "Creature";
  uid: string;
  display_name: string;
  description: string;
  stats: {
    hp: number;
    max_hp: number;
  };
  collections: {
    skills: Skill[];
  };
}

interface Player {
  __type: "Player";
  uid: string;
  display_name: string;
  entities: {
    active_creature: Creature;
  };
}

interface GameUIData {
  entities: {
    player: Player;
    opponent: Player;
  };
}

export function MainGameSceneView(props: { data: GameUIData }) {
  const { availableButtonSlugs, emitButtonClick } = useCurrentButtons();

  const playerCreature = props.data.entities.player?.entities.active_creature;
  const opponentCreature = props.data.entities.opponent?.entities.active_creature;

  return (
    <div className="h-screen w-screen flex flex-col">
      {/* Battlefield Display */}
      <div className="h-2/3 grid grid-cols-2 grid-rows-2 gap-4 p-4">
        {/* Top-left: Opponent Status */}
        <div className="flex flex-col items-end">
          <h3 className="text-xl font-bold">{opponentCreature?.display_name}</h3>
          <div className="w-full bg-gray-200 rounded-full h-2.5 mt-2">
            <div
              className="bg-red-600 h-2.5 rounded-full"
              style={{ width: `${(opponentCreature?.stats.hp / opponentCreature?.stats.max_hp) * 100 || 0}%` }}
            ></div>
          </div>
          <span>{opponentCreature?.stats.hp}/{opponentCreature?.stats.max_hp} HP</span>
        </div>

        {/* Top-right: Opponent Creature */}
        <div className="flex justify-end items-start">
          {opponentCreature && (
            <CreatureCard
              uid={opponentCreature.uid}
              name={opponentCreature.display_name}
              imageUrl="/placeholder-creature-front.png"
              hp={opponentCreature.stats.hp}
              maxHp={opponentCreature.stats.max_hp}
            />
          )}
        </div>

        {/* Bottom-left: Player Creature */}
        <div className="flex items-end">
          {playerCreature && (
            <CreatureCard
              uid={playerCreature.uid}
              name={playerCreature.display_name}
              imageUrl="/placeholder-creature-back.png"
              hp={playerCreature.stats.hp}
              maxHp={playerCreature.stats.max_hp}
            />
          )}
        </div>

        {/* Bottom-right: Player Status */}
        <div className="flex flex-col items-start justify-end">
          <h3 className="text-xl font-bold">{playerCreature?.display_name}</h3>
          <div className="w-full bg-gray-200 rounded-full h-2.5 mt-2">
            <div
              className="bg-green-600 h-2.5 rounded-full"
              style={{ width: `${(playerCreature?.stats.hp / playerCreature?.stats.max_hp) * 100 || 0}%` }}
            ></div>
          </div>
          <span>{playerCreature?.stats.hp}/{playerCreature?.stats.max_hp} HP</span>
        </div>
      </div>

      {/* User Interface */}
      <div className="h-1/3 bg-gray-100 p-4 flex flex-col">
        <div className="flex space-x-4 mb-4">
          {availableButtonSlugs.includes('attack') && (
            <Button onClick={() => emitButtonClick('attack')}>
              <Sword className="mr-2 h-4 w-4" /> Attack
            </Button>
          )}
          {availableButtonSlugs.includes('swap') && (
            <Button onClick={() => emitButtonClick('swap')}>
              <Repeat className="mr-2 h-4 w-4" /> Swap
            </Button>
          )}
          {availableButtonSlugs.includes('back') && (
            <Button onClick={() => emitButtonClick('back')}>
              <ArrowLeft className="mr-2 h-4 w-4" /> Back
            </Button>
          )}
        </div>
        <div className="grid grid-cols-2 gap-4">
          {playerCreature?.collections.skills.map((skill) => (
            <SkillButton
              key={skill.uid}
              uid={skill.uid}
              skillName={skill.display_name}
              description={skill.description}
              stats={`Base Damage: ${skill.stats.base_damage}`}
            />
          ))}
        </div>
      </div>
    </div>
  );
}
```

This implementation follows the requirements and uses the custom components as specified. It creates a full-screen layout with the battlefield display in the upper 2/3 and the user interface in the lower 1/3. The component handles potential missing data with optional chaining and provides a fallback for the HP bar width calculation.

The battlefield display is divided into four quadrants using a grid layout, showing the player's and opponent's creatures and their statuses. The user interface section contains the main action buttons and skill buttons, which are conditionally rendered based on the `availableButtonSlugs`.

Tailwind classes are used for styling and layout, creating a responsive design that should fit well within the 16:9 game container. The component uses the custom `CreatureCard` and `SkillButton` components as required, passing the necessary props including the `uid`.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "b7ae63fc-1664-4fee-b604-f2fd1e6f71dc", "file_path": "main_game/templates/MainGameScene.tsx"}]
```
__________________
