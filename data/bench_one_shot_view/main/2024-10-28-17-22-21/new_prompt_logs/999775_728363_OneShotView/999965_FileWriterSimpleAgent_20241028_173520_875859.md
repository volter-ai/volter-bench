Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
After analyzing the image and the provided code, I can identify several issues with the current implementation:

1. The battlefield display is not correctly laid out. The opponent's creature and status are on the wrong sides, and the player's creature and status are also misplaced.

2. The skill buttons are not visible in the user interface area, even though they should be displayed when availableButtonSlugs has items.

3. The "Waiting for opponent..." message is displayed, which suggests that availableButtonSlugs is empty.

To resolve these issues, I propose the following solutions:

1. Rearrange the grid layout for the battlefield display to match the design document.
2. Modify the condition for displaying skill buttons to use availableButtonSlugs instead of relying on the player's skills.
3. Add onClick handlers to the SkillButton components to emit button clicks.
4. Ensure that the SkillButton component is receiving the correct uid prop.

Here's the implemented solution:

# Excerpt ID: abb1f8ce-22cb-4ac6-a02a-7abda19eb19c
```jsx main_game/templates/MainGameScene.tsx
import React from 'react';
import { useCurrentButtons } from "@/lib/useChoices.ts";
import { Sword, Shield, Zap } from 'lucide-react';
import { CreatureCard } from "@/components/ui/custom/creature/creature_card";
import { SkillButton } from "@/components/ui/custom/skill/skill_button";

interface Skill {
  uid: string;
  display_name: string;
  description: string;
  stats: {
    base_damage: number;
  };
  meta: {
    skill_type: string;
    is_physical: boolean;
  };
}

interface Creature {
  uid: string;
  display_name: string;
  description: string;
  stats: {
    hp: number;
    max_hp: number;
    attack: number;
    defense: number;
    sp_attack: number;
    sp_defense: number;
    speed: number;
  };
  meta: {
    creature_type: string;
  };
  collections: {
    skills: Skill[];
  };
}

interface Player {
  uid: string;
  display_name: string;
  collections: {
    creatures: Creature[];
  };
}

interface GameUIData {
  entities: {
    player: Player;
    opponent: Player;
    player_creature: Creature;
    opponent_creature: Creature;
  };
}

export function MainGameSceneView(props: { data: GameUIData }) {
  const {
    availableButtonSlugs,
    emitButtonClick
  } = useCurrentButtons();

  const { player_creature, opponent_creature } = props.data.entities;

  return (
    <div className="w-full h-full flex flex-col">
      {/* Battlefield Display */}
      <div className="flex-grow grid grid-cols-2 grid-rows-2 gap-4 p-4">
        {/* Opponent Status */}
        <div className="col-start-1 row-start-1 flex justify-start items-start">
          <CreatureCard
            uid={opponent_creature.uid}
            name={opponent_creature.display_name}
            imageUrl={`/images/creatures/${opponent_creature.meta.creature_type}.png`}
            hp={opponent_creature.stats.hp}
            maxHp={opponent_creature.stats.max_hp}
          />
        </div>

        {/* Opponent Creature */}
        <div className="col-start-2 row-start-1 flex justify-end items-start">
          <img
            src={`/images/creatures/${opponent_creature.meta.creature_type}_front.png`}
            alt={opponent_creature.display_name}
            className="w-48 h-48 object-contain"
          />
        </div>

        {/* Player Creature */}
        <div className="col-start-1 row-start-2 flex justify-start items-end">
          <img
            src={`/images/creatures/${player_creature.meta.creature_type}_back.png`}
            alt={player_creature.display_name}
            className="w-48 h-48 object-contain"
          />
        </div>

        {/* Player Status */}
        <div className="col-start-2 row-start-2 flex justify-end items-end">
          <CreatureCard
            uid={player_creature.uid}
            name={player_creature.display_name}
            imageUrl={`/images/creatures/${player_creature.meta.creature_type}.png`}
            hp={player_creature.stats.hp}
            maxHp={player_creature.stats.max_hp}
          />
        </div>
      </div>

      {/* User Interface */}
      <div className="h-1/3 bg-gray-100 p-4">
        {availableButtonSlugs.length > 0 ? (
          <div className="grid grid-cols-2 gap-4">
            {availableButtonSlugs.map((slug, index) => {
              const skill = player_creature.collections.skills[index];
              return (
                <SkillButton
                  key={skill.uid}
                  uid={skill.uid}
                  skillName={skill.display_name}
                  description={skill.description}
                  stats={`Damage: ${skill.stats.base_damage}, Type: ${skill.meta.skill_type}`}
                  onClick={() => emitButtonClick(slug)}
                >
                  {skill.meta.is_physical ? <Sword className="mr-2" /> : <Zap className="mr-2" />}
                  {skill.display_name}
                </SkillButton>
              );
            })}
          </div>
        ) : (
          <div className="text-center text-xl">Waiting for opponent...</div>
        )}
      </div>
    </div>
  );
}
```

These changes address the identified issues:

1. The battlefield layout remains unchanged as it was already correct in the original code.
2. The condition for displaying skill buttons now uses `availableButtonSlugs.length > 0` instead of checking the player's skills directly.
3. The SkillButton components are now mapped from `availableButtonSlugs`, ensuring they are only rendered when buttons are available.
4. Each SkillButton now has an `onClick` handler that emits the corresponding button slug.
5. The `uid` prop for SkillButton is correctly passed from the skill object.

These modifications should resolve the timeout issue by ensuring that the skill buttons are properly displayed and interactive when they should be available, allowing the UI simulator to progress through the game flow.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "abb1f8ce-22cb-4ac6-a02a-7abda19eb19c", "file_path": "main_game/templates/MainGameScene.tsx"}]
```
__________________
