Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for providing the detailed information and requirements. I'll explain the architecture and implementation approach, and then provide the updated code for the MainGameSceneView component.

Architecture and Implementation Approach:

1. Component Structure:
   We'll create a main container div that takes up the entire 16:9 game container. Inside this, we'll have two main sections:
   - Battlefield Display (upper 2/3)
   - User Interface (lower 1/3)

2. Battlefield Display:
   We'll use a grid layout to divide the battlefield into four quadrants:
   - Bottom-left: Player's creature (CreatureCard component)
   - Bottom-right: Player's creature status
   - Top-right: Opponent's creature (CreatureCard component)
   - Top-left: Opponent's creature status

3. User Interface:
   We'll create a flex container for the buttons and choices. We'll use the SkillButton component for skills and regular buttons for other actions.

4. Tailwind Styling:
   We'll use Tailwind classes for layout, sizing, and positioning. For example:
   - `h-screen w-screen` for full-screen container
   - `grid grid-cols-2 grid-rows-2` for the battlefield layout
   - `flex flex-col` for the user interface

5. Data Handling:
   We'll create interfaces for the main data structures (Player, Creature, Skill) to ensure type safety. We'll use optional chaining and nullish coalescing to handle potential missing data.

6. Button Handling:
   We'll use the `availableButtonSlugs` and `emitButtonClick` from `useCurrentButtons` to manage button availability and clicks.

Now, let's implement the MainGameSceneView component:

# Excerpt ID: 71639ec5-79a7-4b48-a88a-049a32f2ba05
```tsx main_game/templates/MainGameScene.tsx
import { useCurrentButtons } from "@/lib/useChoices.ts";
import { Sword, ArrowLeft, Repeat } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { CreatureCard } from "@/components/ui/custom/creature/creature_card";
import { SkillButton } from "@/components/ui/custom/skill/skill_button";

interface Skill {
  __type: "Skill";
  uid: string;
  display_name: string;
  description: string;
  stats: {
    base_damage: number;
  };
}

interface Creature {
  __type: "Creature";
  uid: string;
  display_name: string;
  description: string;
  stats: {
    hp: number;
    max_hp: number;
  };
  collections: {
    skills: Skill[];
  };
}

interface Player {
  __type: "Player";
  uid: string;
  display_name: string;
  entities: {
    active_creature: Creature;
  };
}

interface GameUIData {
  entities: {
    player: Player;
    opponent: Player;
  };
}

export function MainGameSceneView(props: { data: GameUIData }) {
  const { availableButtonSlugs, emitButtonClick } = useCurrentButtons();

  const playerCreature = props.data.entities.player?.entities.active_creature;
  const opponentCreature = props.data.entities.opponent?.entities.active_creature;

  return (
    <div className="h-screen w-screen flex flex-col">
      <div className="flex-grow grid grid-cols-2 grid-rows-2 gap-4 p-4">
        <div className="row-start-2 col-start-1 flex items-end justify-start">
          {playerCreature && (
            <CreatureCard
              uid={playerCreature.uid}
              name={playerCreature.display_name}
              imageUrl={`/images/creatures/${playerCreature.display_name.toLowerCase()}_back.png`}
              hp={playerCreature.stats.hp}
              maxHp={playerCreature.stats.max_hp}
            />
          )}
        </div>
        <div className="row-start-2 col-start-2 flex items-end justify-end">
          <div className="text-right">
            <h3 className="text-xl font-bold">{playerCreature?.display_name}</h3>
            <p>HP: {playerCreature?.stats.hp} / {playerCreature?.stats.max_hp}</p>
          </div>
        </div>
        <div className="row-start-1 col-start-2 flex items-start justify-end">
          {opponentCreature && (
            <CreatureCard
              uid={opponentCreature.uid}
              name={opponentCreature.display_name}
              imageUrl={`/images/creatures/${opponentCreature.display_name.toLowerCase()}_front.png`}
              hp={opponentCreature.stats.hp}
              maxHp={opponentCreature.stats.max_hp}
            />
          )}
        </div>
        <div className="row-start-1 col-start-1 flex items-start justify-start">
          <div className="text-left">
            <h3 className="text-xl font-bold">{opponentCreature?.display_name}</h3>
            <p>HP: {opponentCreature?.stats.hp} / {opponentCreature?.stats.max_hp}</p>
          </div>
        </div>
      </div>
      <div className="h-1/3 bg-gray-100 p-4">
        <div className="flex flex-wrap gap-2">
          {availableButtonSlugs.includes('attack') && (
            <Button onClick={() => emitButtonClick('attack')}>
              <Sword className="mr-2 h-4 w-4" /> Attack
            </Button>
          )}
          {availableButtonSlugs.includes('back') && (
            <Button onClick={() => emitButtonClick('back')}>
              <ArrowLeft className="mr-2 h-4 w-4" /> Back
            </Button>
          )}
          {availableButtonSlugs.includes('swap') && (
            <Button onClick={() => emitButtonClick('swap')}>
              <Repeat className="mr-2 h-4 w-4" /> Swap
            </Button>
          )}
          {playerCreature?.collections.skills.map((skill) => (
            <SkillButton
              key={skill.uid}
              uid={skill.uid}
              skillName={skill.display_name}
              description={skill.description}
              stats={`Base Damage: ${skill.stats.base_damage}`}
            />
          ))}
        </div>
      </div>
    </div>
  );
}
```

This implementation follows the requirements and uses the custom components as specified. It creates a full-screen layout with the battlefield display in the upper 2/3 and the user interface in the lower 1/3. The creature cards are positioned in their respective corners, and the UI buttons are displayed based on availability. The code uses Tailwind classes for styling and layout, and it handles potential missing data with optional chaining.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "71639ec5-79a7-4b48-a88a-049a32f2ba05", "file_path": "main_game/templates/MainGameScene.tsx"}]
```
__________________
