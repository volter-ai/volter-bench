Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issue, we need to modify the `MainGameScene` class in the `main_game_scene.py` file. The problem is that the scene is terminating without calling `_quit_whole_game` or `_transition_to_scene`, which is causing the test to fail. We'll update the `run` method to properly handle the end of the battle and transition back to the main menu or quit the game.

Here's how we'll fix it:

1. After the battle ends (when `_check_battle_end` returns True), we'll add a choice for the player to either return to the main menu or quit the game.
2. Based on the player's choice, we'll either transition to the main menu scene or quit the whole game.
3. We'll also add a small delay using `time.sleep()` to allow the player to read the battle result before making their choice.

Now, let's rewrite the `main_game_scene.py` file with the proposed solution:

# Excerpt ID: d4d14cfe-5934-4e7b-b5a8-5b5c5b4c3efc
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button
from main_game.models import Player, Creature, Skill
import random
import time

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Your skills:
{self._format_skills(self.player_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name}" for skill in skills])

    def run(self):
        self._show_text(self.player, "Battle start!")
        while True:
            player_skill = self._player_choice_phase()
            opponent_skill = self._opponent_choice_phase()
            self._resolution_phase(player_skill, opponent_skill)
            
            if self._check_battle_end():
                time.sleep(2)  # Give the player time to read the battle result
                self._end_battle_choice()
                break

    def _player_choice_phase(self):
        choices = [Button(skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return next(skill for skill in self.player_creature.skills if skill.display_name == choice.display_name)

    def _opponent_choice_phase(self):
        choices = [Button(skill.display_name) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return next(skill for skill in self.opponent_creature.skills if skill.display_name == choice.display_name)

    def _resolution_phase(self, player_skill, opponent_skill):
        first, second = self._determine_order()
        self._execute_skill(first, second, player_skill if first == self.player else opponent_skill)
        if not self._check_battle_end():
            self._execute_skill(second, first, opponent_skill if first == self.player else player_skill)

    def _determine_order(self):
        if self.player_creature.speed > self.opponent_creature.speed:
            return self.player, self.opponent
        elif self.player_creature.speed < self.opponent_creature.speed:
            return self.opponent, self.player
        else:
            return random.sample([self.player, self.opponent], 2)

    def _execute_skill(self, attacker, defender, skill):
        attacker_creature = attacker.creatures[0]
        defender_creature = defender.creatures[0]
        damage = max(0, attacker_creature.attack + skill.base_damage - defender_creature.defense)
        defender_creature.hp = max(0, defender_creature.hp - damage)
        self._show_text(self.player, f"{attacker.display_name}'s {attacker_creature.display_name} uses {skill.display_name}!")
        self._show_text(self.player, f"{defender.display_name}'s {defender_creature.display_name} takes {damage} damage!")

    def _check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name} lost the battle!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name} won the battle!")
            return True
        return False

    def _end_battle_choice(self):
        main_menu_button = Button("Return to Main Menu")
        quit_button = Button("Quit Game")
        choices = [main_menu_button, quit_button]
        choice = self._wait_for_choice(self.player, choices)

        if choice == main_menu_button:
            self._transition_to_scene("MainMenuScene")
        elif choice == quit_button:
            self._quit_whole_game()
```

This updated version of the `MainGameScene` class addresses the issue by ensuring that the scene always ends with either a transition to another scene or by quitting the whole game. The `_end_battle_choice` method is called after the battle ends, giving the player the option to return to the main menu or quit the game. This should resolve the test failures and make the game flow more smoothly.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "d4d14cfe-5934-4e7b-b5a8-5b5c5b4c3efc", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
