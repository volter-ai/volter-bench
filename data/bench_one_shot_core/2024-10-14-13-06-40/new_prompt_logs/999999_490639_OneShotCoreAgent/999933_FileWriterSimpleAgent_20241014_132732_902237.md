Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issues raised during QA/testing, we need to address two main problems:

1. The MainGameScene is not exiting properly, either by transitioning to another scene or quitting the game.
2. The scene is terminating without calling `quit_whole_game` or `transition_to_scene`.

To resolve these issues, we'll modify the MainGameScene to properly exit the game loop and transition to an appropriate scene or quit the game when the battle ends. Here's how we'll fix it:

1. We'll add a new method `end_battle` to handle the end of the battle.
2. In the `end_battle` method, we'll show the result message and then transition back to the MainMenuScene.
3. We'll modify the `check_battle_end` method to call `end_battle` when the battle is over.
4. We'll ensure that the main game loop continues until the battle ends.

Here's the rewritten MainGameScene with these changes:

# Excerpt ID: b8998840-bcaf-4c67-a079-24ac83b77bb1
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Your turn! Choose a skill:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        while True:
            player_skill = self.player_choice_phase()
            opponent_skill = self.foe_choice_phase()
            self.resolution_phase(player_skill, opponent_skill)
            
            if self.check_battle_end():
                break

    def player_choice_phase(self):
        choices = [Button(skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return next(skill for skill in self.player_creature.skills if skill.display_name == choice.display_name)

    def foe_choice_phase(self):
        choices = [Button(skill.display_name) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return next(skill for skill in self.opponent_creature.skills if skill.display_name == choice.display_name)

    def resolution_phase(self, player_skill, opponent_skill):
        first, second = self.determine_order(self.player_creature, self.opponent_creature)
        first_skill = player_skill if first == self.player_creature else opponent_skill
        second_skill = opponent_skill if first == self.player_creature else player_skill

        self.execute_skill(first, second, first_skill)
        if not self.check_battle_end():
            self.execute_skill(second, first, second_skill)

    def determine_order(self, creature1, creature2):
        if creature1.speed > creature2.speed:
            return creature1, creature2
        elif creature2.speed > creature1.speed:
            return creature2, creature1
        else:
            return random.sample([creature1, creature2], 2)

    def execute_skill(self, attacker, defender, skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        weakness_factor = self.calculate_weakness_factor(skill.skill_type, defender.creature_type)
        final_damage = int(weakness_factor * raw_damage)
        defender.hp = max(0, defender.hp - final_damage)

        self._show_text(self.player, f"{attacker.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender.display_name} took {final_damage} damage!")

    def calculate_weakness_factor(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def check_battle_end(self):
        if self.player_creature.hp == 0 or self.opponent_creature.hp == 0:
            self.end_battle()
            return True
        return False

    def end_battle(self):
        if self.player_creature.hp == 0:
            result_message = f"{self.player.display_name}, you have lost the battle!"
        else:
            result_message = f"Congratulations {self.player.display_name}, you have won the battle!"
        
        self._show_text(self.player, result_message)
        self._show_text(self.opponent, result_message)
        
        # Add a small delay to allow the player to read the result
        self._show_text(self.player, "Returning to main menu...")
        self._show_text(self.opponent, "Returning to main menu...")
        
        # Transition back to the MainMenuScene
        self._transition_to_scene("MainMenuScene")
```

These changes ensure that the MainGameScene properly exits by transitioning back to the MainMenuScene when the battle ends. This should resolve both issues:

1. The scene now exits properly by calling `_transition_to_scene`.
2. The scene no longer terminates without calling `quit_whole_game` or `transition_to_scene`.

The main game loop continues until `check_battle_end` returns True, at which point it calls `end_battle`. The `end_battle` method shows the result message and then transitions back to the MainMenuScene.

This solution maintains the existing architecture and stays within the capabilities of the engine. It doesn't modify any models, keeping them as pure data schemas, and it uses the engine's built-in methods for scene transitions and showing text to the player.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "b8998840-bcaf-4c67-a079-24ac83b77bb1", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
