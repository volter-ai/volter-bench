Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for bringing these issues to my attention. I'll address each of the problems and propose a solution that aligns with the architecture and stays within the engine's capabilities.

1. To fix the resolution phase not randomly deciding execution order when speeds are equal, we'll add a random tie-breaker.
2. To implement the 'Leaf' type, we'll add it to the type effectiveness calculations.
3. To handle the 'Normal' type effectiveness as described, we'll ensure it's neither effective nor ineffective against any other types.

These changes will primarily affect the MainGameScene, so we'll rewrite that file. Here's the proposed solution:

# Excerpt ID: b9dce5da-a83f-4b37-8d3d-99d4c81f27b4
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Your skills:
{self._format_skills(self.player_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name}" for skill in skills])

    def run(self):
        while True:
            # Player Choice Phase
            player_skill = self._player_choice_phase(self.player, self.player_creature)
            
            # Foe Choice Phase
            foe_skill = self._player_choice_phase(self.opponent, self.opponent_creature)
            
            # Resolution Phase
            self._resolution_phase(player_skill, foe_skill)
            
            # Check for battle end
            if self._check_battle_end():
                self._end_battle()
                break

    def _player_choice_phase(self, current_player, current_creature):
        choices = [Button(skill.display_name) for skill in current_creature.skills]
        choice = self._wait_for_choice(current_player, choices)
        return next(skill for skill in current_creature.skills if skill.display_name == choice.display_name)

    def _resolution_phase(self, player_skill, foe_skill):
        if self.player_creature.speed > self.opponent_creature.speed:
            first, second = self.player, self.opponent
            first_skill, second_skill = player_skill, foe_skill
        elif self.player_creature.speed < self.opponent_creature.speed:
            first, second = self.opponent, self.player
            first_skill, second_skill = foe_skill, player_skill
        else:
            # Random tie-breaker when speeds are equal
            if random.choice([True, False]):
                first, second = self.player, self.opponent
                first_skill, second_skill = player_skill, foe_skill
            else:
                first, second = self.opponent, self.player
                first_skill, second_skill = foe_skill, player_skill

        self._execute_skill(first, first.creatures[0], first_skill, second.creatures[0])
        if second.creatures[0].hp > 0:
            self._execute_skill(second, second.creatures[0], second_skill, first.creatures[0])

    def _execute_skill(self, attacker, attacker_creature, skill, defender_creature):
        raw_damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        weakness_factor = self._get_weakness_factor(skill.skill_type, defender_creature.creature_type)
        final_damage = int(weakness_factor * raw_damage)
        defender_creature.hp = max(0, defender_creature.hp - final_damage)
        
        self._show_text(self.player, f"{attacker.display_name}'s {attacker_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender_creature.display_name} took {final_damage} damage!")

    def _get_weakness_factor(self, skill_type, defender_type):
        if skill_type == "normal":
            return 1  # Normal is neither effective nor ineffective against any type
        elif skill_type == defender_type:
            return 1
        elif (skill_type == "fire" and defender_type == "leaf") or \
             (skill_type == "water" and defender_type == "fire") or \
             (skill_type == "leaf" and defender_type == "water"):
            return 2
        elif (skill_type == "fire" and defender_type == "water") or \
             (skill_type == "water" and defender_type == "leaf") or \
             (skill_type == "leaf" and defender_type == "fire"):
            return 0.5
        else:
            return 1

    def _check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name}, you have lost the battle!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"Congratulations {self.player.display_name}, you have won the battle!")
            return True
        return False

    def _end_battle(self):
        play_again_button = Button("Play Again")
        quit_button = Button("Quit")
        choices = [play_again_button, quit_button]
        choice = self._wait_for_choice(self.player, choices)

        if choice == play_again_button:
            self._transition_to_scene("MainGameScene")
        else:
            self._transition_to_scene("MainMenuScene")
```

These changes address the issues by:

1. Adding a random tie-breaker in the `_resolution_phase` method when creature speeds are equal.
2. Including 'leaf' type in the type effectiveness calculations in the `_get_weakness_factor` method.
3. Handling the 'normal' type effectiveness separately in the `_get_weakness_factor` method, ensuring it's neither effective nor ineffective against any other types.

These modifications should resolve the issues raised during QA/testing while maintaining alignment with the described architecture and staying within the capabilities of the engine.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "b9dce5da-a83f-4b37-8d3d-99d4c81f27b4", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
