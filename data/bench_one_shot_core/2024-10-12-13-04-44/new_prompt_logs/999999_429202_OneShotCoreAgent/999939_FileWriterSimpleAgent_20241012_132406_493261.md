Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
I understand the issue now. The Resolution Phase in the MainGameScene doesn't handle the case where creatures have the same speed, which should result in a random decision to determine which goes first. I'll fix this issue by modifying the MainGameScene class. Here's how I'll address it:

1. I'll add a method called `determine_turn_order` that will return the order of creatures to act based on their speed, with a random decision in case of a tie.
2. I'll modify the `resolve_turn` method to use this new `determine_turn_order` method.
3. I'll ensure that the logic aligns with the architecture document and stays within the capabilities of the engine.

Here's the rewritten MainGameScene with the proposed solution:

# Excerpt ID: 889b1ed4-6d29-472d-8fc9-472a0d36bc73
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Choose a skill:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent.display_name} appeared!")
        while True:
            # Player Choice Phase
            player_skill = self.player_turn()
            
            # Foe Choice Phase
            opponent_skill = self.opponent_turn()
            
            # Resolution Phase
            self.resolve_turn(player_skill, opponent_skill)
            
            if self.check_battle_end():
                break

    def player_turn(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def opponent_turn(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def determine_turn_order(self):
        if self.player_creature.speed > self.opponent_creature.speed:
            return [self.player, self.opponent]
        elif self.player_creature.speed < self.opponent_creature.speed:
            return [self.opponent, self.player]
        else:
            # If speeds are equal, randomly decide who goes first
            return random.sample([self.player, self.opponent], 2)

    def resolve_turn(self, player_skill, opponent_skill):
        turn_order = self.determine_turn_order()
        for attacker in turn_order:
            if attacker == self.player:
                self.execute_skill(self.player, self.player_creature, player_skill, self.opponent_creature)
            else:
                self.execute_skill(self.opponent, self.opponent_creature, opponent_skill, self.player_creature)
            
            if self.check_battle_end():
                break

    def execute_skill(self, attacker, attacker_creature, skill, defender_creature):
        raw_damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        weakness_factor = self.calculate_weakness_factor(skill.skill_type, defender_creature.creature_type)
        final_damage = int(weakness_factor * raw_damage)
        defender_creature.hp = max(0, defender_creature.hp - final_damage)
        
        effectiveness = "It's super effective!" if weakness_factor > 1 else "It's not very effective..." if weakness_factor < 1 else ""
        self._show_text(attacker, f"{attacker_creature.display_name} used {skill.display_name}! {effectiveness}")
        self._show_text(attacker, f"{defender_creature.display_name} took {final_damage} damage!")

    def calculate_weakness_factor(self, skill_type, defender_type):
        effectiveness = {
            "fire": {"leaf": 2, "water": 0.5},
            "water": {"fire": 2, "leaf": 0.5},
            "leaf": {"water": 2, "fire": 0.5}
        }
        return effectiveness.get(skill_type, {}).get(defender_type, 1)

    def check_battle_end(self):
        if self.player_creature.hp <= 0:
            self.end_battle(f"{self.player.display_name}'s {self.player_creature.display_name} fainted! You lose!")
            return True
        elif self.opponent_creature.hp <= 0:
            self.end_battle(f"{self.opponent.display_name}'s {self.opponent_creature.display_name} fainted! You win!")
            return True
        return False

    def end_battle(self, message):
        self._show_text(self.player, message)
        self._transition_to_scene("MainMenuScene")
```

This solution addresses the issue by introducing the `determine_turn_order` method, which handles the case of equal speeds by randomly deciding the order. The `resolve_turn` method now uses this new method to determine the order of actions, ensuring that the game logic aligns with the architecture document.

The changes are confined to the MainGameScene class and do not affect the models or other parts of the game. This solution stays within the capabilities of the engine and maintains the separation of concerns between models and game logic.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "889b1ed4-6d29-472d-8fc9-472a0d36bc73", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
