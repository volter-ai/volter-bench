Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To address the issues raised in the QA pass, I'll describe how to fix them and then provide the updated `main_game_scene.py` file. The changes will be implemented within the capabilities of the engine and without modifying the models.

1. Fixing the issues:

a) Add 'Back' option in the player choice phase:
   - Implement a 'Back' button in the attack and swap choice menus.
   - Allow players to return to the main action selection when 'Back' is chosen.

b) Implement speed-based execution of actions:
   - Compare the speed of both active creatures before executing actions.
   - Execute the action of the faster creature first.

c) Random turn order for creatures with the same speed:
   - When speeds are equal, use random.choice to determine which creature goes first.

d) Forced swapping when a creature's hp reaches zero:
   - After each action, check if the defending creature's HP is zero.
   - If so, force the owner to swap to another creature with non-zero HP.
   - End the battle if no creatures with non-zero HP are available.

e) Reset the state of creatures when leaving the scene:
   - Implement a method to reset all creatures' HP to their max_hp before transitioning to the main menu.

Now, I'll rewrite the `main_game_scene.py` file with these changes:

# Excerpt ID: f10db64e-4a5c-4c8e-ad81-acc1020c571b
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}: {self.player.active_creature.display_name} (HP: {self.player.active_creature.hp}/{self.player.active_creature.max_hp})
{self.opponent.display_name}: {self.opponent.active_creature.display_name} (HP: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp})

> Attack
> Swap
"""

    def run(self):
        while True:
            player_action = self.get_player_action(self.player)
            opponent_action = self.get_player_action(self.opponent)
            
            if self.player.active_creature.speed > self.opponent.active_creature.speed:
                self.execute_action(self.player, self.opponent, player_action)
                if not self.check_battle_end() and self.opponent.active_creature.hp > 0:
                    self.execute_action(self.opponent, self.player, opponent_action)
            elif self.player.active_creature.speed < self.opponent.active_creature.speed:
                self.execute_action(self.opponent, self.player, opponent_action)
                if not self.check_battle_end() and self.player.active_creature.hp > 0:
                    self.execute_action(self.player, self.opponent, player_action)
            else:
                first, second = random.choice([(self.player, self.opponent), (self.opponent, self.player)])
                first_action = player_action if first == self.player else opponent_action
                second_action = opponent_action if first == self.player else player_action
                
                self.execute_action(first, second, first_action)
                if not self.check_battle_end() and second.active_creature.hp > 0:
                    self.execute_action(second, first, second_action)
            
            if self.check_battle_end():
                break

    def get_player_action(self, acting_player):
        while True:
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choices = [attack_button, swap_button]
            choice = self._wait_for_choice(acting_player, choices)

            if attack_button == choice:
                action = self.get_attack_action(acting_player)
                if action:
                    return action
            elif swap_button == choice:
                action = self.get_swap_action(acting_player)
                if action:
                    return action

    def get_attack_action(self, acting_player):
        back_button = Button("Back")
        skill_choices = [SelectThing(skill, label=skill.display_name) for skill in acting_player.active_creature.skills]
        choices = skill_choices + [back_button]
        choice = self._wait_for_choice(acting_player, choices)
        
        if choice == back_button:
            return None
        return choice

    def get_swap_action(self, acting_player):
        back_button = Button("Back")
        available_creatures = [c for c in acting_player.creatures if c != acting_player.active_creature and c.hp > 0]
        if not available_creatures:
            self._show_text(acting_player, "No creatures available to swap.")
            return None
        creature_choices = [SelectThing(creature, label=creature.display_name) for creature in available_creatures]
        choices = creature_choices + [back_button]
        choice = self._wait_for_choice(acting_player, choices)
        
        if choice == back_button:
            return None
        return choice

    def execute_action(self, acting_player, defending_player, action):
        if isinstance(action.thing, Skill):
            self.execute_attack(acting_player, defending_player, action.thing)
        elif isinstance(action.thing, Creature):
            self.execute_swap(acting_player, action.thing)
        
        self.check_and_force_swap(defending_player)

    def execute_attack(self, attacker, defender, skill):
        damage = self.calculate_damage(attacker.active_creature, defender.active_creature, skill)
        defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
        self._show_text(self.player, f"{attacker.active_creature.display_name} used {skill.display_name} and dealt {damage} damage to {defender.active_creature.display_name}!")

    def execute_swap(self, player, new_creature):
        player.active_creature = new_creature
        self._show_text(self.player, f"{player.display_name} swapped to {new_creature.display_name}!")

    def calculate_damage(self, attacker, defender, skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_effectiveness)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def get_type_effectiveness(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def check_and_force_swap(self, player):
        if player.active_creature.hp == 0:
            available_creatures = [c for c in player.creatures if c.hp > 0]
            if not available_creatures:
                return  # Battle will end in the next check_battle_end call
            
            self._show_text(self.player, f"{player.display_name}'s {player.active_creature.display_name} fainted!")
            swap_choices = [SelectThing(creature, label=creature.display_name) for creature in available_creatures]
            choice = self._wait_for_choice(player, swap_choices)
            self.execute_swap(player, choice.thing)

    def check_battle_end(self):
        if all(creature.hp == 0 for creature in self.player.creatures):
            self._show_text(self.player, f"{self.opponent.display_name} wins!")
            self.reset_creatures()
            self._transition_to_scene("MainMenuScene")
            return True
        elif all(creature.hp == 0 for creature in self.opponent.creatures):
            self._show_text(self.player, f"{self.player.display_name} wins!")
            self.reset_creatures()
            self._transition_to_scene("MainMenuScene")
            return True
        return False

    def reset_creatures(self):
        for player in [self.player, self.opponent]:
            for creature in player.creatures:
                creature.hp = creature.max_hp
```

These changes address all the issues raised in the QA pass while staying within the capabilities of the engine and without modifying the models. The updated `MainGameScene` now includes:

1. A 'Back' option in the player choice phase for both attack and swap actions.
2. Speed-based execution of actions, with random turn order for creatures with the same speed.
3. Forced swapping when a creature's HP reaches zero.
4. Resetting the state of creatures when leaving the scene (transitioning to the main menu).

The implementation maintains the pure data schema nature of the models and uses the existing engine capabilities to handle game logic and flow.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "f10db64e-4a5c-4c8e-ad81-acc1020c571b", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
