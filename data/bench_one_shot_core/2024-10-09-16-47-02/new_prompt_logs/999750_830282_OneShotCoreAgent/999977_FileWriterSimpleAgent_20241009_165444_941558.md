Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issues raised during QA/testing, we need to address two main problems:

1. The `MainGameScene` is not properly exiting, either by transitioning to another scene or quitting the game.
2. The random test runs are not completing as expected.

Here's how we'll fix these issues:

1. We'll modify the `MainGameScene` to properly end the battle and transition back to the `MainMenuScene` when the battle is over.
2. We'll add a check for when all creatures of a player are knocked out, ending the battle.
3. We'll ensure that the `_check_battle_end` method is called after each turn and handles the scene transition.

Let's rewrite the `main_game_scene.py` file with these fixes:

# Excerpt ID: 5fcb12d4-a39a-4f8c-a299-846de7026d18
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        self.turn_order = [self.player, self.bot]
        random.shuffle(self.turn_order)

    def __str__(self):
        player_creature = self.player.active_creature
        bot_creature = self.bot.active_creature
        return f"""===Battle===
{self.player.display_name}'s {player_creature.display_name}: HP {player_creature.hp}/{player_creature.max_hp}
{self.bot.display_name}'s {bot_creature.display_name}: HP {bot_creature.hp}/{bot_creature.max_hp}

> Attack
> Swap
"""

    def run(self):
        self._initialize_battle()
        while True:
            for current_player in self.turn_order:
                action = self._player_turn(current_player)
                if action == "end_battle":
                    return

            self._resolve_turn()
            if self._check_battle_end():
                return

    def _initialize_battle(self):
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]
        self._show_text(self.player, f"{self.player.display_name} sends out {self.player.active_creature.display_name}!")
        self._show_text(self.bot, f"{self.bot.display_name} sends out {self.bot.active_creature.display_name}!")

    def _player_turn(self, player: Player):
        while True:
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choices = [attack_button, swap_button]
            choice = self._wait_for_choice(player, choices)

            if choice == attack_button:
                skill = self._choose_skill(player)
                if skill:
                    player.queued_action = ("attack", skill)
                    return
            elif choice == swap_button:
                new_creature = self._choose_swap_creature(player)
                if new_creature:
                    player.queued_action = ("swap", new_creature)
                    return

    def _choose_skill(self, player: Player):
        skills = player.active_creature.skills
        skill_choices = [SelectThing(skill) for skill in skills]
        back_button = Button("Back")
        choices = skill_choices + [back_button]
        choice = self._wait_for_choice(player, choices)

        if choice == back_button:
            return None
        return choice.thing

    def _choose_swap_creature(self, player: Player):
        available_creatures = [c for c in player.creatures if c != player.active_creature and c.hp > 0]
        creature_choices = [SelectThing(creature) for creature in available_creatures]
        back_button = Button("Back")
        choices = creature_choices + [back_button]
        choice = self._wait_for_choice(player, choices)

        if choice == back_button:
            return None
        return choice.thing

    def _resolve_turn(self):
        for player in self.turn_order:
            action, target = player.queued_action
            if action == "swap":
                self._perform_swap(player, target)
            elif action == "attack":
                self._perform_attack(player, target)

    def _perform_swap(self, player: Player, new_creature: Creature):
        player.active_creature = new_creature
        self._show_text(player, f"{player.display_name} swapped to {new_creature.display_name}!")

    def _perform_attack(self, attacker: Player, skill: Skill):
        defender = self.player if attacker == self.bot else self.bot
        damage = self._calculate_damage(attacker.active_creature, defender.active_creature, skill)
        defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
        self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name} and dealt {damage} damage!")

        if defender.active_creature.hp == 0:
            self._show_text(defender, f"{defender.active_creature.display_name} fainted!")
            if not self._force_swap(defender):
                return "end_battle"

    def _calculate_damage(self, attacker: Creature, defender: Creature, skill: Skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_factor = self._get_type_factor(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_factor)
        return max(1, final_damage)

    def _get_type_factor(self, skill_type: str, defender_type: str):
        effectiveness = {
            "fire": {"leaf": 2, "water": 0.5},
            "water": {"fire": 2, "leaf": 0.5},
            "leaf": {"water": 2, "fire": 0.5}
        }
        return effectiveness.get(skill_type, {}).get(defender_type, 1)

    def _force_swap(self, player: Player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if not available_creatures:
            return False
        new_creature = available_creatures[0]
        player.active_creature = new_creature
        self._show_text(player, f"{player.display_name} sends out {new_creature.display_name}!")
        return True

    def _check_battle_end(self):
        for player in [self.player, self.bot]:
            if all(creature.hp == 0 for creature in player.creatures):
                winner = self.bot if player == self.player else self.player
                self._show_text(self.player, f"{winner.display_name} wins the battle!")
                self._transition_to_scene("MainMenuScene")
                return True
        return False
```

These changes address the issues by:

1. Ensuring that the battle ends properly when all creatures of a player are knocked out.
2. Adding a `_force_swap` method to handle creature swapping when one faints.
3. Calling `_check_battle_end` after each turn to check if the battle should end.
4. Using `_transition_to_scene` to return to the `MainMenuScene` when the battle ends.

These modifications should resolve the test failures and ensure that the `MainGameScene` exits properly, either by transitioning to another scene or ending the game. The changes adhere to the existing architecture and capabilities of the engine, and do not modify the models, keeping them as pure data schemas.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "5fcb12d4-a39a-4f8c-a299-846de7026d18", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
