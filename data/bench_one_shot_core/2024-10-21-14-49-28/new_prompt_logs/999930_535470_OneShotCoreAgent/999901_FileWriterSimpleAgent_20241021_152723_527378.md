Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issues raised during QA/testing, we need to address two main problems:

1. The MainGameScene is not exiting properly, either by transitioning to another scene or quitting the game.
2. The scene is terminating without calling `quit_whole_game` or `transition_to_scene`.

Here's how we'll fix these issues:

1. We'll modify the `MainGameScene` to transition back to the `MainMenuScene` after the battle ends.
2. We'll ensure that the game loop continues until a transition or quit action is called.
3. We'll add a "Return to Main Menu" option after the battle ends.

Let's rewrite the `main_game_scene.py` file with these changes:

# Excerpt ID: 064d926f-b172-4e6f-aa26-9d0cac1a99fe
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.battle_ended = False

    def __str__(self):
        if self.battle_ended:
            return """===Battle Ended===
> Return to Main Menu
"""
        return f"""===Battle===
{self.player.display_name}: {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
{self.opponent.display_name}: {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Player's turn:
> {self.player_creature.skills[0].display_name}
> {self.player_creature.skills[1].display_name}
"""

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appeared!")
        
        while True:
            if self.battle_ended:
                self.handle_post_battle()
            else:
                self.handle_battle_turn()
            
            if self.check_battle_end():
                self.battle_ended = True

    def handle_battle_turn(self):
        # Player turn
        player_skill = self.player_turn()
        
        # Opponent turn
        opponent_skill = self.opponent_turn()
        
        # Resolve turn
        self.resolve_turn(self.player_creature, player_skill, self.opponent_creature, opponent_skill)

    def handle_post_battle(self):
        choices = [Button("Return to Main Menu")]
        choice = self._wait_for_choice(self.player, choices)
        if choice.display_name == "Return to Main Menu":
            self.reset_creatures()
            self._transition_to_scene("MainMenuScene")

    def player_turn(self):
        choices = [SelectThing(skill) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def opponent_turn(self):
        choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def resolve_turn(self, player_creature, player_skill, opponent_creature, opponent_skill):
        first, second = self.determine_turn_order(player_creature, player_skill, opponent_creature, opponent_skill)
        self.execute_skill(*first)
        if not self.check_battle_end():
            self.execute_skill(*second)

    def determine_turn_order(self, player_creature, player_skill, opponent_creature, opponent_skill):
        if player_creature.speed > opponent_creature.speed:
            return (player_creature, player_skill, opponent_creature), (opponent_creature, opponent_skill, player_creature)
        elif player_creature.speed < opponent_creature.speed:
            return (opponent_creature, opponent_skill, player_creature), (player_creature, player_skill, opponent_creature)
        else:
            if random.random() < 0.5:
                return (player_creature, player_skill, opponent_creature), (opponent_creature, opponent_skill, player_creature)
            else:
                return (opponent_creature, opponent_skill, player_creature), (player_creature, player_skill, opponent_creature)

    def execute_skill(self, attacker: Creature, skill: Skill, defender: Creature):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        weakness_factor = self.calculate_weakness_factor(skill.skill_type, defender.creature_type)
        final_damage = int(weakness_factor * raw_damage)
        
        defender.hp = max(0, defender.hp - final_damage)
        
        self._show_text(self.player, f"{attacker.display_name}'s {skill.display_name} dealt {final_damage} damage to {defender.display_name}!")

    def calculate_weakness_factor(self, skill_type, defender_type):
        effectiveness = {
            "fire": {"leaf": 2, "water": 0.5},
            "water": {"fire": 2, "leaf": 0.5},
            "leaf": {"water": 2, "fire": 0.5}
        }
        return effectiveness.get(skill_type, {}).get(defender_type, 1)

    def check_battle_end(self):
        if self.player_creature.hp == 0:
            self._show_text(self.player, f"{self.player.display_name} lost the battle!")
            return True
        elif self.opponent_creature.hp == 0:
            self._show_text(self.player, f"{self.player.display_name} won the battle!")
            return True
        return False

    def reset_creatures(self):
        for creature in self.player.creatures + self.opponent.creatures:
            creature.hp = creature.max_hp
```

These changes address the issues by:

1. Adding a `battle_ended` flag to track when the battle is over.
2. Modifying the `run` method to continue looping until a transition or quit action is called.
3. Adding a `handle_post_battle` method to display the "Return to Main Menu" option after the battle ends.
4. Ensuring that the scene transitions back to the `MainMenuScene` when the player chooses to return to the main menu.

These modifications should resolve the test failures by properly exiting the scene and transitioning back to the main menu. The scene will no longer terminate without calling `quit_whole_game` or `transition_to_scene`, addressing the FixableException raised in the test.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "064d926f-b172-4e6f-aa26-9d0cac1a99fe", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
