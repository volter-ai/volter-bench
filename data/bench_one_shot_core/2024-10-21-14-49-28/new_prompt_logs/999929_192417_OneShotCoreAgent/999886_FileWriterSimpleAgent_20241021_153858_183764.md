Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issues raised during QA/testing, we need to address two main problems:

1. The `MainGameScene` is not exiting properly, either by transitioning to another scene or quitting the whole game.
2. The scene is not handling the end of the battle correctly.

Here's how we'll fix these issues:

1. We'll modify the `run` method in `MainGameScene` to handle the end of the battle by transitioning back to the `MainMenuScene`.
2. We'll update the `check_battle_end` method to return a boolean indicating whether the battle has ended, and who the winner is.
3. We'll add a method to reset the creatures' HP at the end of the battle.

These changes will ensure that the scene exits properly and follows the engine's requirements.

Let's rewrite the `main_game_scene.py` file with these changes:

# Excerpt ID: 0b1c0e02-ab19-4215-8b06-555b73edfcda
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}: {self.player.active_creature.display_name} (HP: {self.player.active_creature.hp}/{self.player.active_creature.max_hp})
{self.opponent.display_name}: {self.opponent.active_creature.display_name} (HP: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp})

> Attack
> Swap
"""

    def run(self):
        while True:
            self.player_turn()
            battle_end, player_won = self.check_battle_end()
            if battle_end:
                self.end_battle(player_won)
                break
            self.opponent_turn()
            battle_end, player_won = self.check_battle_end()
            if battle_end:
                self.end_battle(player_won)
                break
        self.reset_creatures()
        self._transition_to_scene("MainMenuScene")

    def player_turn(self):
        action = self.get_player_action(self.player)
        self.execute_action(self.player, self.opponent, action)

    def opponent_turn(self):
        action = self.get_player_action(self.opponent)
        self.execute_action(self.opponent, self.player, action)

    def get_player_action(self, current_player):
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        choices = [attack_button, swap_button]
        choice = self._wait_for_choice(current_player, choices)

        if choice == attack_button:
            return self.choose_attack(current_player)
        elif choice == swap_button:
            swap_action = self.choose_swap(current_player)
            if swap_action is None:
                self._show_text(current_player, "No creatures available to swap. You must attack.")
                return self.choose_attack(current_player)
            return swap_action

    def choose_attack(self, current_player):
        choices = [SelectThing(skill) for skill in current_player.active_creature.skills]
        return self._wait_for_choice(current_player, choices)

    def choose_swap(self, current_player):
        choices = [SelectThing(creature) for creature in current_player.creatures 
                   if creature != current_player.active_creature and creature.hp > 0]
        if not choices:
            return None
        return self._wait_for_choice(current_player, choices)

    def execute_action(self, attacker, defender, action):
        if isinstance(action.thing, Skill):
            self.execute_attack(attacker, defender, action.thing)
        elif isinstance(action.thing, Creature):
            self.execute_swap(attacker, action.thing)

    def execute_attack(self, attacker, defender, skill):
        damage = self.calculate_damage(attacker.active_creature, defender.active_creature, skill)
        defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
        self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(defender, f"{defender.active_creature.display_name} took {damage} damage!")

    def execute_swap(self, player, new_creature):
        player.active_creature = new_creature
        self._show_text(player, f"{player.display_name} swapped to {new_creature.display_name}!")

    def calculate_damage(self, attacker, defender, skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_factor = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(type_factor * raw_damage)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def get_type_effectiveness(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def check_battle_end(self):
        if all(creature.hp == 0 for creature in self.player.creatures):
            return True, False  # Battle ended, player lost
        elif all(creature.hp == 0 for creature in self.opponent.creatures):
            return True, True  # Battle ended, player won
        return False, False  # Battle not ended

    def end_battle(self, player_won):
        if player_won:
            self._show_text(self.player, "You won the battle!")
        else:
            self._show_text(self.player, "You lost the battle!")

    def reset_creatures(self):
        for creature in self.player.creatures + self.opponent.creatures:
            creature.hp = creature.max_hp

    def force_swap(self, current_player):
        available_creatures = [creature for creature in current_player.creatures if creature.hp > 0]
        if not available_creatures:
            return False
        choices = [SelectThing(creature) for creature in available_creatures]
        new_creature = self._wait_for_choice(current_player, choices).thing
        self.execute_swap(current_player, new_creature)
        return True
```

These changes address the issues by:

1. Properly handling the end of the battle in the `run` method.
2. Adding an `end_battle` method to display the battle result.
3. Adding a `reset_creatures` method to restore creatures' HP at the end of the battle.
4. Transitioning back to the `MainMenuScene` after the battle ends.

These modifications ensure that the scene exits properly by transitioning to another scene, following the engine's requirements. The battle loop now checks for the end condition after each turn and handles it appropriately. The creatures' HP is reset at the end of the battle, preparing for potential future battles.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "0b1c0e02-ab19-4215-8b06-555b73edfcda", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
