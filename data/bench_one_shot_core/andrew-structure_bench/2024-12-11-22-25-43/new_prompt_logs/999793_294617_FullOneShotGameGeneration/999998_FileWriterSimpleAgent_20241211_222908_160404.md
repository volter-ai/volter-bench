Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Implementation Plan:
- The game is a coffee shop management game where we need to automate upgrades
- There are 5 types of upgrades available:
  * Hire Barista (increases worker count)
  * Upgrade Speed (makes baristas move faster)
  * Upgrade Coffee Machine (reduces coffee making time)
  * Increase Capacity (allows more customers in queue)
  * Increase Coffee Price (increases revenue per coffee)

- For the GameAI implementation:
  1. Define UPGRADES array with all upgrade types
  2. Implement getMainCurrency() to return game.money
  3. For experimental mode:
     - Set infinite money
     - Randomly apply 0-10 upgrades of each type
  4. For updateGameStats():
     - Show money, barista count, coffee price, customer capacity
     - Show upgrade levels for each upgrade type
  5. For checkCheapestUpgrade():
     - Check all upgrade costs
     - Buy the cheapest one if we have enough money
  6. For performUpgrade():
     - Handle each upgrade type by calling corresponding game method
     - Track upgrade levels
     - Log upgrade info

Here's the implementation:

# Excerpt ID: 7703e3fa-7114-49fd-ab35-771a01c9305f
```javascript src/GameAI.js
import { AIUtils } from './AIUtils';
import { INITIAL_VALUES, UPGRADE_COSTS } from './game/gameData';

const UPGRADES = [
  'barista',
  'speed',
  'efficiency',
  'capacity', 
  'price'
];

export class GameAI {
  constructor() {
    this.ai = new AIUtils();
    this.game = null;
    this.initialized = false;
    // Initialize upgrade levels for all upgrade types
    this.upgradeLevels = UPGRADES.reduce((acc, upgrade) => {
      acc[upgrade] = 0;
      return acc;
    }, {});
  }

  init() {
    if (!window.game || !window.game.ready) {
      setTimeout(() => this.init(), 100);
      return;
    }
    this.game = window.game;

    if (this.initialized) return;
    this.initialized = true;

    window.game.app.ticker.speed = this.ai.defaultGameSpeed;
    this.ai.updateDebugOverlay('Game speed set to ' + this.ai.defaultGameSpeed + 'x');

    if (this.ai.enabled) {
      this.ai.gameStartTime = Date.now();

      if (this.ai.mode === 'experimental') {
        this.setupExperimentalMode();
      }

      this.ai.startLoggingLoop(this.getMainCurrency.bind(this));
      this.startUpgradeLoop();
      this.updateGameStats();

      setTimeout(() => {
        this.ai.stopAI();
        this.ai.exportLogs();
        this.ai.updateDebugOverlay('Session ended - logs exported');
      }, this.ai.duration);
    }
  }

  getMainCurrency() {
    return this.game.money;
  }

  setupExperimentalMode() {
    // Give infinite money for experimental mode
    this.game.money = Number.MAX_SAFE_INTEGER;

    // Randomly upgrade each stat between 0-10 times
    UPGRADES.forEach(upgrade => {
      const times = Math.floor(Math.random() * 11); // 0 to 10
      for (let i = 0; i < times; i++) {
        this.performUpgrade(upgrade, 0, true);
      }
    });

    this.ai.updateDebugOverlay('Experimental mode initialized with random upgrades');
  }

  updateGameStats() {
    const stats = {
      Money: this.game.money,
      'Barista Count': this.game.baristaCount,
      'Coffee Price': this.game.coffeePrice,
      'Customer Capacity': this.game.customerCapacity,
      'Barista Speed': Math.round(this.game.baristaSpeed),
      'Coffee Make Time': this.game.coffeeMakeTime.toFixed(1) + 's',
      'Barista Level': this.upgradeLevels.barista,
      'Speed Level': this.upgradeLevels.speed,
      'Efficiency Level': this.upgradeLevels.efficiency,
      'Capacity Level': this.upgradeLevels.capacity,
      'Price Level': this.upgradeLevels.price
    };

    this.ai.updateDebugOverlay('Game stats updated', stats);
  }

  startUpgradeLoop() {
    if (!this.ai.enabled || this.ai.mode === 'experimental') return;

    this.upgradeInterval = setInterval(() => {
      this.checkCheapestUpgrade();
      this.updateGameStats();
    }, 100);
  }

  checkCheapestUpgrade() {
    let cheapestUpgrade = null;
    let lowestCost = Infinity;

    for (const upgrade of UPGRADES) {
      const cost = this.game.upgradeCosts[upgrade];
      if (cost <= this.game.money && cost < lowestCost) {
        cheapestUpgrade = upgrade;
        lowestCost = cost;
      }
    }

    if (cheapestUpgrade) {
      this.performUpgrade(cheapestUpgrade, lowestCost);
    }
  }

  performUpgrade(upgradeName, cost, skipLogging = false) {
    // Increment the upgrade level before performing the upgrade
    this.upgradeLevels[upgradeName]++;
    const currentLevel = this.upgradeLevels[upgradeName];

    switch (upgradeName) {
      case 'barista':
        this.game.upgradeBarista();
        break;
      case 'speed':
        this.game.upgradeSpeed();
        break;
      case 'efficiency':
        this.game.upgradeEfficiency();
        break;
      case 'capacity':
        this.game.upgradeCapacity();
        break;
      case 'price':
        this.game.upgradePrice();
        break;
      default:
        console.error(`${upgradeName} is not a valid upgrade`);
    }

    if (!skipLogging) {
      const upgradeInfo = {
        timestamp: Date.now(),
        upgrade: upgradeName,
        cost: cost,
        level: currentLevel
      };

      this.ai.logUpgrade(upgradeInfo);
      this.ai.updateDebugOverlay(`Purchased ${upgradeName} upgrade for ${cost} (Level ${currentLevel})`);
    }
  }
}

const gameAI = new GameAI();
gameAI.init();

if (window.game) {
  window.game.exportAILogs = () => gameAI.ai.exportLogs();
  window.game.clearAILogs = () => gameAI.ai.clearLogs();
}

export default gameAI;
```

This implementation:
1. Defines all 5 upgrade types in UPGRADES array
2. Tracks upgrade levels for each type
3. In experimental mode, gives infinite money and randomly applies upgrades
4. Shows comprehensive stats including all game values and upgrade levels
5. Automatically buys the cheapest available upgrade in normal mode
6. Properly logs all upgrades and updates the debug overlay
7. Maintains compatibility with the existing game logic
8. Uses the AIUtils for all logging and UI functionality

The AI will continuously buy the cheapest available upgrade while tracking and logging everything. In experimental mode, it will randomly set upgrade levels to observe their effects.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
