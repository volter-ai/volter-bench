Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me trace the error:

The error occurs in utils.js when trying to access resources.default.texture and ASSET_MANIFEST[key].path. This suggests:

1. The utils.js file is missing from our implementation
2. The loadAssets function is trying to use an ASSET_MANIFEST variable but we're passing SPRITES

We need to:
1. Create utils.js with proper asset loading
2. Update gameLogic.js to properly handle asset loading

Here are the fixed files:

# Excerpt ID: 4c37bf89-84d3-4823-8061-b9fd7184bfa8
```javascript src/game/utils.js
import * as PIXI from 'pixi.js';

export function loadAssets(sprites, onComplete) {
  const loader = PIXI.Loader.shared;
  
  // Add all sprites to loader
  Object.entries(sprites).forEach(([key, sprite]) => {
    loader.add(key, sprite.path);
  });

  // Start loading
  loader.load((loader, resources) => {
    Object.keys(sprites).forEach(key => {
      if (resources[key]) {
        PIXI.Texture.from(resources[key].texture);
      }
    });
    onComplete();
  });
}
```

# Excerpt ID: 2a5cabd2-e504-4f33-8cfc-3f1df2c18d1f
```javascript src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, POSITIONS, MOVEMENT_POINTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.money = 0;
    this.baristaSpeed = INITIAL_VALUES.BARISTA_SPEED;
    this.coffeeMakeTime = INITIAL_VALUES.COFFEE_MAKE_TIME;
    this.coffeePrice = INITIAL_VALUES.COFFEE_PRICE;
    this.customerCapacity = INITIAL_VALUES.CUSTOMER_CAPACITY;
    this.baristaCount = INITIAL_VALUES.BARISTA_COUNT;

    this.upgradeCosts = {
      barista: UPGRADE_COSTS.BARISTA,
      speed: UPGRADE_COSTS.SPEED,
      efficiency: UPGRADE_COSTS.COFFEE_EFFICIENCY,
      capacity: UPGRADE_COSTS.CAPACITY,
      price: UPGRADE_COSTS.PRICE
    };

    // Pre-load textures
    Object.entries(SPRITES).forEach(([key, sprite]) => {
      PIXI.Texture.from(sprite.path);
    });

    this.createGameObjects();
    this.app.ticker.add(this.gameLoop.bind(this));
    this.ready = true;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.coffeeMachine = this.getSprite(SPRITES.coffee_machine);
    this.coffeeMachine.position.set(POSITIONS.COFFEE_MACHINE.x, POSITIONS.COFFEE_MACHINE.y);

    this.baristas = new PIXI.Container();
    this.customers = new PIXI.Container();
    this.customerQueue = [];

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.coffeeMachine);
    this.app.stage.addChild(this.baristas);
    this.app.stage.addChild(this.customers);

    // Create initial barista
    this.createBarista();
    this.spawnCustomer();
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  // ... rest of the GameLogic class implementation remains exactly the same ...
  createBarista() {
    const barista = this.getSprite(SPRITES.barista);
    barista.anchor.set(0.5);
    barista.position.set(MOVEMENT_POINTS.START.x, MOVEMENT_POINTS.START.y);
    barista.state = 'idle';
    barista.targetCustomer = null;
    barista.coffeeTimer = 0;
    this.baristas.addChild(barista);
  }

  spawnCustomer() {
    if (this.customerQueue.length >= this.customerCapacity) return;

    const customer = this.getSprite(SPRITES.customer);
    customer.anchor.set(0.5);
    customer.position.set(
      POSITIONS.CUSTOMER_COUNTER.x,
      POSITIONS.CUSTOMER_COUNTER.y + this.customerQueue.length * POSITIONS.CUSTOMER_SPACING
    );
    customer.state = 'waiting';
    this.customers.addChild(customer);
    this.customerQueue.push(customer);
  }

  moveTowards(object, target, speed, delta) {
    const dx = target.x - object.x;
    const dy = target.y - object.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < 1) return true;

    const movement = speed * delta;
    object.x += (dx / distance) * movement;
    object.y += (dy / distance) * movement;
    return false;
  }

  gameLoop(delta) {
    const elapsedSecs = delta / 60;

    this.baristas.children.forEach(barista => {
      switch(barista.state) {
        case 'idle':
          if (this.customerQueue.length > 0) {
            barista.targetCustomer = this.customerQueue[0];
            barista.state = 'moving_to_machine';
          }
          break;

        case 'moving_to_machine':
          if (this.moveTowards(barista, MOVEMENT_POINTS.COFFEE_MACHINE, this.baristaSpeed, elapsedSecs)) {
            barista.state = 'making_coffee';
            barista.coffeeTimer = 0;
          }
          break;

        case 'making_coffee':
          barista.coffeeTimer += elapsedSecs;
          if (barista.coffeeTimer >= this.coffeeMakeTime) {
            barista.state = 'serving';
          }
          break;

        case 'serving':
          if (this.moveTowards(barista, MOVEMENT_POINTS.SERVING, this.baristaSpeed, elapsedSecs)) {
            this.money += this.coffeePrice;
            const servedCustomer = this.customerQueue.shift();
            this.customers.removeChild(servedCustomer);
            this.customerQueue.forEach((customer, index) => {
              customer.y = POSITIONS.CUSTOMER_COUNTER.y + index * POSITIONS.CUSTOMER_SPACING;
            });
            barista.state = 'returning';
            this.spawnCustomer();
          }
          break;

        case 'returning':
          if (this.moveTowards(barista, MOVEMENT_POINTS.START, this.baristaSpeed, elapsedSecs)) {
            barista.state = 'idle';
            barista.targetCustomer = null;
          }
          break;
      }
    });
  }

  upgradeBarista() {
    if (this.money >= this.upgradeCosts.barista) {
      this.money -= this.upgradeCosts.barista;
      this.createBarista();
      this.upgradeCosts.barista *= 2;
      this.baristaCount++;
    }
  }

  upgradeSpeed() {
    if (this.money >= this.upgradeCosts.speed) {
      this.money -= this.upgradeCosts.speed;
      this.baristaSpeed *= 1.2;
      this.upgradeCosts.speed *= 2;
    }
  }

  upgradeEfficiency() {
    if (this.money >= this.upgradeCosts.efficiency) {
      this.money -= this.upgradeCosts.efficiency;
      this.coffeeMakeTime *= 0.8;
      this.upgradeCosts.efficiency *= 2;
    }
  }

  upgradeCapacity() {
    if (this.money >= this.upgradeCosts.capacity) {
      this.money -= this.upgradeCosts.capacity;
      this.customerCapacity++;
      this.upgradeCosts.capacity *= 2;
      this.spawnCustomer();
    }
  }

  upgradePrice() {
    if (this.money >= this.upgradeCosts.price) {
      this.money -= this.upgradeCosts.price;
      this.coffeePrice = Math.floor(this.coffeePrice * 1.2);
      this.upgradeCosts.price *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

The key changes are:
1. Added utils.js with proper PIXI loader implementation
2. Simplified asset loading in GameLogic by directly creating textures
3. Removed the loadAssets callback pattern since we're loading assets synchronously now

This should resolve the texture loading errors while maintaining all the game functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
