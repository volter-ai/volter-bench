Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data Structure (gameData.js):
- Initial values for barista speed, coffee machine speed, prices, etc
- Upgrade costs and multipliers
- Screen positions for coffee machine, counters

2. Asset Requirements (assetManifest.js):
- Background with counter/coffee shop scene
- Barista sprite
- Customer sprite
- Coffee machine sprite
- Coffee cup sprite

3. Core Game Logic (gameLogic.js):
- Track game state: money, baristas, customers
- Customer management:
  - Queue system for customers
  - Customer spawning based on capacity
  - Customer states (waiting, being served, leaving)
- Barista management:
  - Movement between points
  - State machine (idle, making coffee, serving)
  - Coffee preparation timer
- Collision detection for serving
- Upgrade implementations

4. UI Elements (GameUI.js):
- Display current money
- Show upgrade buttons with costs
- Display stats (baristas, speed, etc)

Now, I'll implement each file:

# Excerpt ID: 8ff9e77c-a439-4e7f-9038-a2dbdc5ccd75
```javascript src/game/gameData.js
export const INITIAL_VALUES = {
  BARISTA_SPEED: 100, // pixels per second
  COFFEE_MAKE_TIME: 3, // seconds to make coffee
  COFFEE_PRICE: 5,
  CUSTOMER_CAPACITY: 3,
  BARISTA_COUNT: 1,
};

export const UPGRADE_COSTS = {
  BARISTA: 50,
  SPEED: 30,
  COFFEE_EFFICIENCY: 40,
  CAPACITY: 25,
  PRICE: 35,
};

export const POSITIONS = {
  COFFEE_MACHINE: { x: 400, y: 300 },
  CUSTOMER_COUNTER: { x: 100, y: 300 },
  SERVING_COUNTER: { x: 700, y: 300 },
  CUSTOMER_SPACING: 80,
};

export const MOVEMENT_POINTS = {
  START: { x: 300, y: 300 },
  COFFEE_MACHINE: { x: 400, y: 300 },
  SERVING: { x: 700, y: 300 },
};
```

# Excerpt ID: 607d8f19-be98-4173-af97-245eaea11238
```javascript src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/coffee_shop.png',
    width: 800,
    height: 600
  },
  barista: {
    path: 'assets/barista.png',
    width: 64,
    height: 64
  },
  customer: {
    path: 'assets/customer.png',
    width: 64,
    height: 64
  },
  coffee_machine: {
    path: 'assets/coffee_machine.png',
    width: 128,
    height: 128
  },
  coffee_cup: {
    path: 'assets/coffee_cup.png',
    width: 32,
    height: 32
  }
};
```

# Excerpt ID: 617f13ac-7396-4a5b-8f88-e36867a47528
```javascript src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, POSITIONS, MOVEMENT_POINTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.money = 0;
    this.baristaSpeed = INITIAL_VALUES.BARISTA_SPEED;
    this.coffeeMakeTime = INITIAL_VALUES.COFFEE_MAKE_TIME;
    this.coffeePrice = INITIAL_VALUES.COFFEE_PRICE;
    this.customerCapacity = INITIAL_VALUES.CUSTOMER_CAPACITY;
    this.baristaCount = INITIAL_VALUES.BARISTA_COUNT;

    this.upgradeCosts = {
      barista: UPGRADE_COSTS.BARISTA,
      speed: UPGRADE_COSTS.SPEED,
      efficiency: UPGRADE_COSTS.COFFEE_EFFICIENCY,
      capacity: UPGRADE_COSTS.CAPACITY,
      price: UPGRADE_COSTS.PRICE
    };

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.coffeeMachine = this.getSprite(SPRITES.coffee_machine);
    this.coffeeMachine.position.set(POSITIONS.COFFEE_MACHINE.x, POSITIONS.COFFEE_MACHINE.y);

    this.baristas = new PIXI.Container();
    this.customers = new PIXI.Container();
    this.customerQueue = [];

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.coffeeMachine);
    this.app.stage.addChild(this.baristas);
    this.app.stage.addChild(this.customers);

    // Create initial barista
    this.createBarista();
    this.spawnCustomer();
  }

  createBarista() {
    const barista = this.getSprite(SPRITES.barista);
    barista.anchor.set(0.5);
    barista.position.set(MOVEMENT_POINTS.START.x, MOVEMENT_POINTS.START.y);
    barista.state = 'idle';
    barista.targetCustomer = null;
    barista.coffeeTimer = 0;
    this.baristas.addChild(barista);
  }

  spawnCustomer() {
    if (this.customerQueue.length >= this.customerCapacity) return;

    const customer = this.getSprite(SPRITES.customer);
    customer.anchor.set(0.5);
    customer.position.set(
      POSITIONS.CUSTOMER_COUNTER.x,
      POSITIONS.CUSTOMER_COUNTER.y + this.customerQueue.length * POSITIONS.CUSTOMER_SPACING
    );
    customer.state = 'waiting';
    this.customers.addChild(customer);
    this.customerQueue.push(customer);
  }

  moveTowards(object, target, speed, delta) {
    const dx = target.x - object.x;
    const dy = target.y - object.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < 1) return true;

    const movement = speed * delta;
    object.x += (dx / distance) * movement;
    object.y += (dy / distance) * movement;
    return false;
  }

  gameLoop(delta) {
    const elapsedSecs = delta / 60;

    this.baristas.children.forEach(barista => {
      switch(barista.state) {
        case 'idle':
          if (this.customerQueue.length > 0) {
            barista.targetCustomer = this.customerQueue[0];
            barista.state = 'moving_to_machine';
          }
          break;

        case 'moving_to_machine':
          if (this.moveTowards(barista, MOVEMENT_POINTS.COFFEE_MACHINE, this.baristaSpeed, elapsedSecs)) {
            barista.state = 'making_coffee';
            barista.coffeeTimer = 0;
          }
          break;

        case 'making_coffee':
          barista.coffeeTimer += elapsedSecs;
          if (barista.coffeeTimer >= this.coffeeMakeTime) {
            barista.state = 'serving';
          }
          break;

        case 'serving':
          if (this.moveTowards(barista, MOVEMENT_POINTS.SERVING, this.baristaSpeed, elapsedSecs)) {
            this.money += this.coffeePrice;
            const servedCustomer = this.customerQueue.shift();
            this.customers.removeChild(servedCustomer);
            this.customerQueue.forEach((customer, index) => {
              customer.y = POSITIONS.CUSTOMER_COUNTER.y + index * POSITIONS.CUSTOMER_SPACING;
            });
            barista.state = 'returning';
            this.spawnCustomer();
          }
          break;

        case 'returning':
          if (this.moveTowards(barista, MOVEMENT_POINTS.START, this.baristaSpeed, elapsedSecs)) {
            barista.state = 'idle';
            barista.targetCustomer = null;
          }
          break;
      }
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  upgradeBarista() {
    if (this.money >= this.upgradeCosts.barista) {
      this.money -= this.upgradeCosts.barista;
      this.createBarista();
      this.upgradeCosts.barista *= 2;
      this.baristaCount++;
    }
  }

  upgradeSpeed() {
    if (this.money >= this.upgradeCosts.speed) {
      this.money -= this.upgradeCosts.speed;
      this.baristaSpeed *= 1.2;
      this.upgradeCosts.speed *= 2;
    }
  }

  upgradeEfficiency() {
    if (this.money >= this.upgradeCosts.efficiency) {
      this.money -= this.upgradeCosts.efficiency;
      this.coffeeMakeTime *= 0.8;
      this.upgradeCosts.efficiency *= 2;
    }
  }

  upgradeCapacity() {
    if (this.money >= this.upgradeCosts.capacity) {
      this.money -= this.upgradeCosts.capacity;
      this.customerCapacity++;
      this.upgradeCosts.capacity *= 2;
      this.spawnCustomer();
    }
  }

  upgradePrice() {
    if (this.money >= this.upgradeCosts.price) {
      this.money -= this.upgradeCosts.price;
      this.coffeePrice = Math.floor(this.coffeePrice * 1.2);
      this.upgradeCosts.price *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: db34ea70-30ed-440c-9564-fd88b85eadd3
```javascript src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} (${cost})
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Money: ${game.money} | Baristas: {game.baristaCount} | Coffee Price: ${game.coffeePrice} | Customer Capacity: {game.customerCapacity}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeBarista()} cost={game.upgradeCosts.barista}>Hire Barista</Button>
        <Button onClick={() => game.upgradeSpeed()} cost={game.upgradeCosts.speed}>Upgrade Speed</Button>
        <Button onClick={() => game.upgradeEfficiency()} cost={game.upgradeCosts.efficiency}>Upgrade Coffee Machine</Button>
        <Button onClick={() => game.upgradeCapacity()} cost={game.upgradeCosts.capacity}>Increase Capacity</Button>
        <Button onClick={() => game.upgradePrice()} cost={game.upgradeCosts.price}>Increase Coffee Price</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation follows all requirements:
1. Auto-playing with manual upgrades only
2. Proper movement system between three points
3. Customer queueing system
4. All specified upgrades
5. Proper use of elapsed time for movement and timers
6. Appropriate sprite sizes
7. All features implemented in existing files
8. Maintains original code structure

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
