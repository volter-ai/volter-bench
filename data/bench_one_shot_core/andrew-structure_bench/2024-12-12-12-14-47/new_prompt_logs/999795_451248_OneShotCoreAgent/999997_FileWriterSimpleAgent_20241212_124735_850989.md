Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Error Analysis:
The error occurs because we're trying to load assets but don't actually need them for this Pong game. The error trace shows:
# Excerpt ID: ca7f769c-f9c3-4228-96b6-47447317b31e
```js
PIXI.Texture.addToCache(resources.default.texture, ASSET_MANIFEST[key].path);
```
Since we're drawing everything with PIXI.Graphics, we don't need sprite assets. We should:
1. Remove asset loading from gameLogic.js
2. Remove SPRITES from assetManifest.js since we're not using any sprites
3. Remove background sprite creation since we're drawing everything programmatically

Here are the fixed files:

# Excerpt ID: 8c056101-4c9f-4e53-abde-72f1682e416b
```js src/game/assetManifest.js
export const SPRITES = {};
```

# Excerpt ID: 6a4dcb4d-e732-4d3f-bf64-1c6194b5842d
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;
    this.consecutiveHits = 0;
    this.lastTimestamp = performance.now();

    // Game values
    this.paddleHeight = INITIAL_VALUES.PADDLE_HEIGHT;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.currentBallSpeed = INITIAL_VALUES.BALL_SPEED;
    this.pointMultiplier = INITIAL_VALUES.POINT_MULTIPLIER;
    this.paddlePrediction = INITIAL_VALUES.PADDLE_PREDICTION;
    this.comboMultiplier = INITIAL_VALUES.COMBO_MULTIPLIER;

    // Upgrade costs
    this.paddleHeightCost = UPGRADE_COSTS.PADDLE_HEIGHT;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;
    this.pointMultiplierCost = UPGRADE_COSTS.POINT_MULTIPLIER;
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.paddlePredictionCost = UPGRADE_COSTS.PADDLE_PREDICTION;
    this.comboMultiplierCost = UPGRADE_COSTS.COMBO_MULTIPLIER;

    this.createGameObjects();
    this.app.ticker.add(this.gameLoop.bind(this));
    this.ready = true;
  }

  createGameObjects() {
    // Create paddles
    this.leftPaddle = new PIXI.Graphics();
    this.rightPaddle = new PIXI.Graphics();
    this.updatePaddles();

    // Create ball
    this.ball = new PIXI.Graphics();
    this.ball.beginFill(0xFFFFFF);
    this.ball.drawCircle(0, 0, INITIAL_VALUES.BALL_SIZE);
    this.ball.endFill();
    this.resetBall();

    this.app.stage.addChild(this.leftPaddle);
    this.app.stage.addChild(this.rightPaddle);
    this.app.stage.addChild(this.ball);
  }

  updatePaddles() {
    [this.leftPaddle, this.rightPaddle].forEach((paddle, index) => {
      paddle.clear();
      paddle.beginFill(0xFFFFFF);
      paddle.drawRect(0, 0, INITIAL_VALUES.PADDLE_WIDTH, this.paddleHeight);
      paddle.endFill();
      paddle.x = index === 0 ? 50 : SCREEN_SIZE.width - 50 - INITIAL_VALUES.PADDLE_WIDTH;
      paddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;
    });
  }

  resetBall() {
    this.ball.x = SCREEN_SIZE.width / 2;
    this.ball.y = SCREEN_SIZE.height / 2;
    this.currentBallSpeed = this.ballSpeed;
    const angle = (Math.random() * Math.PI / 2) - Math.PI / 4;
    this.ball.vx = Math.cos(angle) * this.currentBallSpeed * (Math.random() < 0.5 ? 1 : -1);
    this.ball.vy = Math.sin(angle) * this.currentBallSpeed;
    this.consecutiveHits = 0;
  }

  gameLoop(delta) {
    const elapsedSecs = delta / 60;

    // Move ball
    this.ball.x += this.ball.vx * elapsedSecs;
    this.ball.y += this.ball.vy * elapsedSecs;

    // Ball collision with top/bottom
    if (this.ball.y < 0 || this.ball.y > SCREEN_SIZE.height) {
      this.ball.vy *= -1;
    }

    // AI paddle movement
    [this.leftPaddle, this.rightPaddle].forEach(paddle => {
      const targetY = this.ball.y - this.paddleHeight / 2 + 
        (Math.random() * 2 - 1) * (1 - this.paddlePrediction) * this.paddleHeight;
      
      const dy = targetY - paddle.y;
      paddle.y += Math.sign(dy) * this.paddleSpeed * elapsedSecs;
      paddle.y = Math.max(0, Math.min(SCREEN_SIZE.height - this.paddleHeight, paddle.y));
    });

    // Paddle collision
    [this.leftPaddle, this.rightPaddle].forEach(paddle => {
      if (this.checkPaddleCollision(paddle)) {
        this.currentBallSpeed *= 1.1;
        this.ball.vx *= -1;
        const angleChange = (Math.random() - 0.5) * Math.PI / 4;
        const speed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
        const angle = Math.atan2(this.ball.vy, this.ball.vx) + angleChange;
        this.ball.vx = Math.cos(angle) * speed;
        this.ball.vy = Math.sin(angle) * speed;
        
        this.consecutiveHits++;
        this.score += this.pointMultiplier * Math.pow(this.comboMultiplier, this.consecutiveHits - 1);
      }
    });

    // Ball out of bounds
    if (this.ball.x < 0 || this.ball.x > SCREEN_SIZE.width) {
      this.resetBall();
    }
  }

  checkPaddleCollision(paddle) {
    return this.ball.x + INITIAL_VALUES.BALL_SIZE > paddle.x &&
           this.ball.x - INITIAL_VALUES.BALL_SIZE < paddle.x + INITIAL_VALUES.PADDLE_WIDTH &&
           this.ball.y + INITIAL_VALUES.BALL_SIZE > paddle.y &&
           this.ball.y - INITIAL_VALUES.BALL_SIZE < paddle.y + this.paddleHeight;
  }

  upgradePaddleHeight() {
    if (this.score >= this.paddleHeightCost) {
      this.score -= this.paddleHeightCost;
      this.paddleHeight += 10;
      this.paddleHeightCost *= 2;
      this.updatePaddles();
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed *= 1.2;
      this.paddleSpeedCost *= 2;
    }
  }

  upgradePointMultiplier() {
    if (this.score >= this.pointMultiplierCost) {
      this.score -= this.pointMultiplierCost;
      this.pointMultiplier *= 1.5;
      this.pointMultiplierCost *= 2;
    }
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed *= 1.2;
      this.ballSpeedCost *= 2;
    }
  }

  upgradePaddlePrediction() {
    if (this.score >= this.paddlePredictionCost) {
      this.score -= this.paddlePredictionCost;
      this.paddlePrediction = Math.min(1, this.paddlePrediction + 0.05);
      this.paddlePredictionCost *= 2;
    }
  }

  upgradeComboMultiplier() {
    if (this.score >= this.comboMultiplierCost) {
      this.score -= this.comboMultiplierCost;
      this.comboMultiplier *= 1.2;
      this.comboMultiplierCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

The main changes were:
1. Removed asset loading and background sprite
2. Removed imports for SPRITES and loadAssets
3. Simplified constructor to create game objects immediately
4. Empty SPRITES object in assetManifest.js

The game should now work without any asset loading errors since we're using pure PIXI.Graphics for all game objects.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
