Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data Structure:
- Add initial values for paddle height, speed, ball speed, point multiplier, etc.
- Add upgrade costs and multipliers
- Track score, combo multiplier, and consecutive hits

2. Game Objects:
- Create paddles as rectangles using PIXI.Graphics
- Create ball as circle using PIXI.Graphics
- Track positions, velocities, and sizes

3. Game Logic:
- Ball movement with speed increases
- Paddle AI movement to track ball
- Collision detection between ball and paddles/walls
- Score tracking and combo system
- Reset mechanics when ball is missed

4. Upgrade System:
- Implement all 6 upgrades affecting relevant variables
- Double costs after each purchase
- Update UI to show costs and current values

Now, let's implement the files:

# Excerpt ID: cdbf4d0b-2d93-4e6b-8813-d9e88fc6121f
```js src/game/gameData.js
export const INITIAL_VALUES = {
  PADDLE_HEIGHT: 100,
  PADDLE_SPEED: 300,
  BALL_SPEED: 200,
  POINT_MULTIPLIER: 1,
  PADDLE_PREDICTION: 0.8,
  COMBO_MULTIPLIER: 1.2,
  PADDLE_WIDTH: 20,
  BALL_SIZE: 10,
};

export const UPGRADE_COSTS = {
  PADDLE_HEIGHT: 10,
  PADDLE_SPEED: 15,
  POINT_MULTIPLIER: 25,
  BALL_SPEED: 20,
  PADDLE_PREDICTION: 30,
  COMBO_MULTIPLIER: 40,
};

```

# Excerpt ID: c6726177-6c49-40bb-88b1-90d46ed5a313
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;
    this.consecutiveHits = 0;
    this.lastTimestamp = performance.now();

    // Game values
    this.paddleHeight = INITIAL_VALUES.PADDLE_HEIGHT;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.currentBallSpeed = INITIAL_VALUES.BALL_SPEED;
    this.pointMultiplier = INITIAL_VALUES.POINT_MULTIPLIER;
    this.paddlePrediction = INITIAL_VALUES.PADDLE_PREDICTION;
    this.comboMultiplier = INITIAL_VALUES.COMBO_MULTIPLIER;

    // Upgrade costs
    this.paddleHeightCost = UPGRADE_COSTS.PADDLE_HEIGHT;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;
    this.pointMultiplierCost = UPGRADE_COSTS.POINT_MULTIPLIER;
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.paddlePredictionCost = UPGRADE_COSTS.PADDLE_PREDICTION;
    this.comboMultiplierCost = UPGRADE_COSTS.COMBO_MULTIPLIER;

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.app.stage.addChild(this.background);

    // Create paddles
    this.leftPaddle = new PIXI.Graphics();
    this.rightPaddle = new PIXI.Graphics();
    this.updatePaddles();

    // Create ball
    this.ball = new PIXI.Graphics();
    this.ball.beginFill(0xFFFFFF);
    this.ball.drawCircle(0, 0, INITIAL_VALUES.BALL_SIZE);
    this.ball.endFill();
    this.resetBall();

    this.app.stage.addChild(this.leftPaddle);
    this.app.stage.addChild(this.rightPaddle);
    this.app.stage.addChild(this.ball);
  }

  updatePaddles() {
    [this.leftPaddle, this.rightPaddle].forEach((paddle, index) => {
      paddle.clear();
      paddle.beginFill(0xFFFFFF);
      paddle.drawRect(0, 0, INITIAL_VALUES.PADDLE_WIDTH, this.paddleHeight);
      paddle.endFill();
      paddle.x = index === 0 ? 50 : SCREEN_SIZE.width - 50 - INITIAL_VALUES.PADDLE_WIDTH;
      paddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;
    });
  }

  resetBall() {
    this.ball.x = SCREEN_SIZE.width / 2;
    this.ball.y = SCREEN_SIZE.height / 2;
    this.currentBallSpeed = this.ballSpeed;
    const angle = (Math.random() * Math.PI / 2) - Math.PI / 4;
    this.ball.vx = Math.cos(angle) * this.currentBallSpeed * (Math.random() < 0.5 ? 1 : -1);
    this.ball.vy = Math.sin(angle) * this.currentBallSpeed;
    this.consecutiveHits = 0;
  }

  gameLoop(delta) {
    const elapsedSecs = delta / 60;

    // Move ball
    this.ball.x += this.ball.vx * elapsedSecs;
    this.ball.y += this.ball.vy * elapsedSecs;

    // Ball collision with top/bottom
    if (this.ball.y < 0 || this.ball.y > SCREEN_SIZE.height) {
      this.ball.vy *= -1;
    }

    // AI paddle movement
    [this.leftPaddle, this.rightPaddle].forEach(paddle => {
      const targetY = this.ball.y - this.paddleHeight / 2 + 
        (Math.random() * 2 - 1) * (1 - this.paddlePrediction) * this.paddleHeight;
      
      const dy = targetY - paddle.y;
      paddle.y += Math.sign(dy) * this.paddleSpeed * elapsedSecs;
      paddle.y = Math.max(0, Math.min(SCREEN_SIZE.height - this.paddleHeight, paddle.y));
    });

    // Paddle collision
    [this.leftPaddle, this.rightPaddle].forEach(paddle => {
      if (this.checkPaddleCollision(paddle)) {
        this.currentBallSpeed *= 1.1;
        this.ball.vx *= -1;
        const angleChange = (Math.random() - 0.5) * Math.PI / 4;
        const speed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
        const angle = Math.atan2(this.ball.vy, this.ball.vx) + angleChange;
        this.ball.vx = Math.cos(angle) * speed;
        this.ball.vy = Math.sin(angle) * speed;
        
        this.consecutiveHits++;
        this.score += this.pointMultiplier * Math.pow(this.comboMultiplier, this.consecutiveHits - 1);
      }
    });

    // Ball out of bounds
    if (this.ball.x < 0 || this.ball.x > SCREEN_SIZE.width) {
      this.resetBall();
    }
  }

  checkPaddleCollision(paddle) {
    return this.ball.x + INITIAL_VALUES.BALL_SIZE > paddle.x &&
           this.ball.x - INITIAL_VALUES.BALL_SIZE < paddle.x + INITIAL_VALUES.PADDLE_WIDTH &&
           this.ball.y + INITIAL_VALUES.BALL_SIZE > paddle.y &&
           this.ball.y - INITIAL_VALUES.BALL_SIZE < paddle.y + this.paddleHeight;
  }

  upgradePaddleHeight() {
    if (this.score >= this.paddleHeightCost) {
      this.score -= this.paddleHeightCost;
      this.paddleHeight += 10;
      this.paddleHeightCost *= 2;
      this.updatePaddles();
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed *= 1.2;
      this.paddleSpeedCost *= 2;
    }
  }

  upgradePointMultiplier() {
    if (this.score >= this.pointMultiplierCost) {
      this.score -= this.pointMultiplierCost;
      this.pointMultiplier *= 1.5;
      this.pointMultiplierCost *= 2;
    }
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed *= 1.2;
      this.ballSpeedCost *= 2;
    }
  }

  upgradePaddlePrediction() {
    if (this.score >= this.paddlePredictionCost) {
      this.score -= this.paddlePredictionCost;
      this.paddlePrediction = Math.min(1, this.paddlePrediction + 0.05);
      this.paddlePredictionCost *= 2;
    }
  }

  upgradeComboMultiplier() {
    if (this.score >= this.comboMultiplierCost) {
      this.score -= this.comboMultiplierCost;
      this.comboMultiplier *= 1.2;
      this.comboMultiplierCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: eb0ad242-96ca-4c38-b576-205868d3ea3e
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} points)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Score: {Math.floor(game.score)} | Combo: x{game.consecutiveHits}</p>
    <p>Current Multiplier: x{(game.pointMultiplier * Math.pow(game.comboMultiplier, game.consecutiveHits - 1)).toFixed(2)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradePaddleHeight()} cost={game.paddleHeightCost}>
          Upgrade Paddle Height
        </Button>
        <Button onClick={() => game.upgradePaddleSpeed()} cost={game.paddleSpeedCost}>
          Upgrade Paddle Speed
        </Button>
        <Button onClick={() => game.upgradePointMultiplier()} cost={game.pointMultiplierCost}>
          Upgrade Point Multiplier
        </Button>
        <Button onClick={() => game.upgradeBallSpeed()} cost={game.ballSpeedCost}>
          Upgrade Ball Speed
        </Button>
        <Button onClick={() => game.upgradePaddlePrediction()} cost={game.paddlePredictionCost}>
          Upgrade Paddle Prediction
        </Button>
        <Button onClick={() => game.upgradeComboMultiplier()} cost={game.comboMultiplierCost}>
          Upgrade Combo Multiplier
        </Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the requested features:
1. Auto-playing pong game with AI paddles
2. Score system with combo multiplier
3. Ball speed increases until miss
4. All 6 upgrades with doubling costs
5. Paddle AI with prediction accuracy
6. Complete UI showing score, combo, and upgrade buttons

The game should run smoothly with proper physics and increasing difficulty as the ball speeds up, while allowing players to strategically purchase upgrades to improve various aspects of the game.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
