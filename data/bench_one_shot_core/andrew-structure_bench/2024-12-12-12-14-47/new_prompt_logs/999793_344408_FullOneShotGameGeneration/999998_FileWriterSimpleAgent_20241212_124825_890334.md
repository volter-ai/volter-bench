Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Implementation Plan:
- The game is a Pong-like game where paddles hit a ball back and forth
- The main currency is "score" which increases when paddles hit the ball
- There are 6 possible upgrades:
  * PADDLE_HEIGHT - Makes paddles taller
  * PADDLE_SPEED - Makes paddles move faster
  * POINT_MULTIPLIER - Increases points gained per hit
  * BALL_SPEED - Makes the ball move faster
  * PADDLE_PREDICTION - Makes AI paddles better at predicting ball position
  * COMBO_MULTIPLIER - Increases bonus points for consecutive hits

Implementation details:
- Import all upgrade names and costs from gameData.js
- getMainCurrency() will return game.score
- In experimental mode, set score to max and randomly apply upgrades
- For standard mode, check all upgrade costs and buy the cheapest one affordable
- Track upgrade levels and costs
- Log all purchases and stats
- Update debug overlay with current game state

Now I'll implement the GameAI.js file:

# Excerpt ID: 3e223193-5ec1-4717-9b7d-5502237f85e1
```javascript src/GameAI.js
import { AIUtils } from './AIUtils';
import { UPGRADE_COSTS } from './game/gameData';

const UPGRADES = [
  'PADDLE_HEIGHT',
  'PADDLE_SPEED', 
  'POINT_MULTIPLIER',
  'BALL_SPEED',
  'PADDLE_PREDICTION',
  'COMBO_MULTIPLIER'
];

export class GameAI {
  constructor() {
    this.ai = new AIUtils();
    this.game = null;
    this.initialized = false;
    // Initialize upgrade levels for all upgrade types
    this.upgradeLevels = UPGRADES.reduce((acc, upgrade) => {
      acc[upgrade] = 0;
      return acc;
    }, {});
  }

  init() {
    if (!window.game || !window.game.ready) {
      setTimeout(() => this.init(), 100);
      return;
    }
    this.game = window.game;

    if (this.initialized) return;
    this.initialized = true;

    window.game.app.ticker.speed = this.ai.defaultGameSpeed;
    this.ai.updateDebugOverlay('Game speed set to ' + this.ai.defaultGameSpeed + 'x');

    if (this.ai.enabled) {
      this.ai.gameStartTime = Date.now();

      if (this.ai.mode === 'experimental') {
        this.setupExperimentalMode();
      }

      this.ai.startLoggingLoop(this.getMainCurrency.bind(this));
      this.startUpgradeLoop();
      this.updateGameStats();

      setTimeout(() => {
        this.ai.stopAI();
        this.ai.exportLogs();
        this.ai.updateDebugOverlay('Session ended - logs exported');
      }, this.ai.duration);
    }
  }

  getMainCurrency() {
    return this.game.score;
  }

  setupExperimentalMode() {
    // Give infinite currency for experimental mode
    this.game.score = Number.MAX_SAFE_INTEGER;

    // Randomly upgrade each stat between 0-10 times
    UPGRADES.forEach(upgrade => {
      const times = Math.floor(Math.random() * 11); // 0 to 10
      for (let i = 0; i < times; i++) {
        this.performUpgrade(upgrade, 0, true);
      }
    });

    this.ai.updateDebugOverlay('Experimental mode initialized with random upgrades');
  }

  updateGameStats() {
    const stats = {
      Score: this.game.score,
      'Consecutive Hits': this.game.consecutiveHits,
      'Point Multiplier': this.game.pointMultiplier,
      'Combo Multiplier': this.game.comboMultiplier,
      'Ball Speed': this.game.ballSpeed,
      'Paddle Height': this.game.paddleHeight,
      'Paddle Speed': this.game.paddleSpeed,
      'Paddle Prediction': this.game.paddlePrediction
    };

    this.ai.updateDebugOverlay('Game stats updated', stats);
  }

  startUpgradeLoop() {
    if (!this.ai.enabled || this.ai.mode === 'experimental') return;

    this.upgradeInterval = setInterval(() => {
      this.checkCheapestUpgrade();
      this.updateGameStats();
    }, 100);
  }

  checkCheapestUpgrade() {
    let cheapestUpgrade = null;
    let lowestCost = Infinity;

    const costs = {
      'PADDLE_HEIGHT': this.game.paddleHeightCost,
      'PADDLE_SPEED': this.game.paddleSpeedCost,
      'POINT_MULTIPLIER': this.game.pointMultiplierCost,
      'BALL_SPEED': this.game.ballSpeedCost,
      'PADDLE_PREDICTION': this.game.paddlePredictionCost,
      'COMBO_MULTIPLIER': this.game.comboMultiplierCost
    };

    for (const upgrade of UPGRADES) {
      const cost = costs[upgrade];
      if (cost <= this.game.score && cost < lowestCost) {
        cheapestUpgrade = upgrade;
        lowestCost = cost;
      }
    }

    if (cheapestUpgrade) {
      this.performUpgrade(cheapestUpgrade, lowestCost);
    }
  }

  performUpgrade(upgradeName, cost, skipLogging = false) {
    // Increment the upgrade level before performing the upgrade
    this.upgradeLevels[upgradeName]++;
    const currentLevel = this.upgradeLevels[upgradeName];

    switch (upgradeName) {
      case 'PADDLE_HEIGHT':
        this.game.upgradePaddleHeight();
        break;
      case 'PADDLE_SPEED':
        this.game.upgradePaddleSpeed();
        break;
      case 'POINT_MULTIPLIER':
        this.game.upgradePointMultiplier();
        break;
      case 'BALL_SPEED':
        this.game.upgradeBallSpeed();
        break;
      case 'PADDLE_PREDICTION':
        this.game.upgradePaddlePrediction();
        break;
      case 'COMBO_MULTIPLIER':
        this.game.upgradeComboMultiplier();
        break;
      default:
        console.error(`${upgradeName} is not a valid upgrade`);
    }

    if (!skipLogging) {
      const upgradeInfo = {
        timestamp: Date.now(),
        upgrade: upgradeName,
        cost: cost,
        level: currentLevel
      };

      this.ai.logUpgrade(upgradeInfo);
      this.ai.updateDebugOverlay(`Purchased ${upgradeName} upgrade for ${cost} (Level ${currentLevel})`);
    }
  }
}

const gameAI = new GameAI();
gameAI.init();

if (window.game) {
  window.game.exportAILogs = () => gameAI.ai.exportLogs();
  window.game.clearAILogs = () => gameAI.ai.clearLogs();
}

export default gameAI;
```

The implementation:
1. Defines all possible upgrades in UPGRADES array
2. Tracks upgrade levels in upgradeLevels object
3. Gets score as main currency
4. In experimental mode:
   - Sets score to max
   - Randomly applies 0-10 upgrades of each type
5. In standard mode:
   - Checks costs of all upgrades
   - Buys cheapest affordable upgrade
6. Logs all stats and upgrades to debug overlay
7. Uses game's upgrade methods to perform upgrades
8. Tracks and displays progress through AIUtils

The implementation follows all the original game logic and just adds AI automation on top.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
