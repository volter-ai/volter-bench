Role: system
Content: You are an expert software developer. Your job is to make an existing simple UI look like the UI from an advanced video game
__________________
Role: user
Content: The existing codebase of the project is as follows:
```js src/Game.js
import React, { useRef, useState, useEffect } from 'react';
import { Settings } from 'lucide-react';
import { GameLogic } from './game/gameLogic';
import GameUI from './ui/GameUI';
import DebugUI from './ui/DebugUI';

const FRAME_RATE = 30;
const FRAME_INTERVAL = 1000 / FRAME_RATE;

const Game = () => {
  const containerRef = useRef(null);
  const gameRef = useRef(null);
  const [showDebugUI, setShowDebugUI] = useState(false);
  const [, setFrame] = useState(0);

  useEffect(() => {
    if (!containerRef.current) return;

    const game = new GameLogic(containerRef.current);
    window.game = game;
    gameRef.current = game;

    let lastTime = Date.now();
    let intervalId;
    const update = (currentTime) => {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // Force a re-render by updating the frame state
      setFrame(prevFrame => prevFrame + 1);
    };

    intervalId = setInterval(() => {
      update(Date.now());
    }, FRAME_INTERVAL);

    return () => {
      clearInterval(intervalId);
      if (gameRef.current) {
        gameRef.current.destroy();
        gameRef.current = null;
      }
      gameRef.current = null;
    };
  }, []);

  return (
    <div style={{
      position: 'relative',
      width: '800px',
      height: '600px',
      overflow: 'hidden'
    }}>
      <div ref={containerRef} style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%'
      }} />
      {gameRef.current && (
        <>
          <GameUI gameRef={gameRef} />
          {showDebugUI && <DebugUI gameRef={gameRef} />}
        </>
      )}
      <Settings
        onClick={() => setShowDebugUI(!showDebugUI)}
        style={{
          position: 'absolute',
          bottom: '10px',
          right: '10px',
          width: '24px',
          height: '24px',
          cursor: 'pointer',
          color: 'white'
        }}
      />
    </div>
  );
};

export default Game;
```
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;
    this.consecutiveHits = 0;
    this.lastTimestamp = performance.now();

    // Game values
    this.paddleHeight = INITIAL_VALUES.PADDLE_HEIGHT;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.currentBallSpeed = INITIAL_VALUES.BALL_SPEED;
    this.pointMultiplier = INITIAL_VALUES.POINT_MULTIPLIER;
    this.paddlePrediction = INITIAL_VALUES.PADDLE_PREDICTION;
    this.comboMultiplier = INITIAL_VALUES.COMBO_MULTIPLIER;

    // Upgrade costs
    this.paddleHeightCost = UPGRADE_COSTS.PADDLE_HEIGHT;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;
    this.pointMultiplierCost = UPGRADE_COSTS.POINT_MULTIPLIER;
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.paddlePredictionCost = UPGRADE_COSTS.PADDLE_PREDICTION;
    this.comboMultiplierCost = UPGRADE_COSTS.COMBO_MULTIPLIER;

    this.createGameObjects();
    this.app.ticker.add(this.gameLoop.bind(this));
    this.ready = true;
  }

  createGameObjects() {
    // Create paddles
    this.leftPaddle = new PIXI.Graphics();
    this.rightPaddle = new PIXI.Graphics();
    this.updatePaddles();

    // Create ball
    this.ball = new PIXI.Graphics();
    this.ball.beginFill(0xFFFFFF);
    this.ball.drawCircle(0, 0, INITIAL_VALUES.BALL_SIZE);
    this.ball.endFill();
    this.resetBall();

    this.app.stage.addChild(this.leftPaddle);
    this.app.stage.addChild(this.rightPaddle);
    this.app.stage.addChild(this.ball);
  }

  updatePaddles() {
    [this.leftPaddle, this.rightPaddle].forEach((paddle, index) => {
      paddle.clear();
      paddle.beginFill(0xFFFFFF);
      paddle.drawRect(0, 0, INITIAL_VALUES.PADDLE_WIDTH, this.paddleHeight);
      paddle.endFill();
      paddle.x = index === 0 ? 50 : SCREEN_SIZE.width - 50 - INITIAL_VALUES.PADDLE_WIDTH;
      paddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;
    });
  }

  resetBall() {
    this.ball.x = SCREEN_SIZE.width / 2;
    this.ball.y = SCREEN_SIZE.height / 2;
    this.currentBallSpeed = this.ballSpeed;
    const angle = (Math.random() * Math.PI / 2) - Math.PI / 4;
    this.ball.vx = Math.cos(angle) * this.currentBallSpeed * (Math.random() < 0.5 ? 1 : -1);
    this.ball.vy = Math.sin(angle) * this.currentBallSpeed;
    this.consecutiveHits = 0;
  }

  gameLoop(delta) {
    const elapsedSecs = delta / 60;

    // Move ball
    this.ball.x += this.ball.vx * elapsedSecs;
    this.ball.y += this.ball.vy * elapsedSecs;

    // Ball collision with top/bottom
    if (this.ball.y < 0 || this.ball.y > SCREEN_SIZE.height) {
      this.ball.vy *= -1;
    }

    // AI paddle movement
    [this.leftPaddle, this.rightPaddle].forEach(paddle => {
      const targetY = this.ball.y - this.paddleHeight / 2 + 
        (Math.random() * 2 - 1) * (1 - this.paddlePrediction) * this.paddleHeight;
      
      const dy = targetY - paddle.y;
      paddle.y += Math.sign(dy) * this.paddleSpeed * elapsedSecs;
      paddle.y = Math.max(0, Math.min(SCREEN_SIZE.height - this.paddleHeight, paddle.y));
    });

    // Paddle collision
    [this.leftPaddle, this.rightPaddle].forEach(paddle => {
      if (this.checkPaddleCollision(paddle)) {
        this.currentBallSpeed *= 1.1;
        this.ball.vx *= -1;
        const angleChange = (Math.random() - 0.5) * Math.PI / 4;
        const speed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
        const angle = Math.atan2(this.ball.vy, this.ball.vx) + angleChange;
        this.ball.vx = Math.cos(angle) * speed;
        this.ball.vy = Math.sin(angle) * speed;
        
        this.consecutiveHits++;
        this.score += this.pointMultiplier * Math.pow(this.comboMultiplier, this.consecutiveHits - 1);
      }
    });

    // Ball out of bounds
    if (this.ball.x < 0 || this.ball.x > SCREEN_SIZE.width) {
      this.resetBall();
    }
  }

  checkPaddleCollision(paddle) {
    return this.ball.x + INITIAL_VALUES.BALL_SIZE > paddle.x &&
           this.ball.x - INITIAL_VALUES.BALL_SIZE < paddle.x + INITIAL_VALUES.PADDLE_WIDTH &&
           this.ball.y + INITIAL_VALUES.BALL_SIZE > paddle.y &&
           this.ball.y - INITIAL_VALUES.BALL_SIZE < paddle.y + this.paddleHeight;
  }

  upgradePaddleHeight() {
    if (this.score >= this.paddleHeightCost) {
      this.score -= this.paddleHeightCost;
      this.paddleHeight += 10;
      this.paddleHeightCost *= 2;
      this.updatePaddles();
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed *= 1.2;
      this.paddleSpeedCost *= 2;
    }
  }

  upgradePointMultiplier() {
    if (this.score >= this.pointMultiplierCost) {
      this.score -= this.pointMultiplierCost;
      this.pointMultiplier *= 1.5;
      this.pointMultiplierCost *= 2;
    }
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed *= 1.2;
      this.ballSpeedCost *= 2;
    }
  }

  upgradePaddlePrediction() {
    if (this.score >= this.paddlePredictionCost) {
      this.score -= this.paddlePredictionCost;
      this.paddlePrediction = Math.min(1, this.paddlePrediction + 0.05);
      this.paddlePredictionCost *= 2;
    }
  }

  upgradeComboMultiplier() {
    if (this.score >= this.comboMultiplierCost) {
      this.score -= this.comboMultiplierCost;
      this.comboMultiplier *= 1.2;
      this.comboMultiplierCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}

```
```js src/game/gameData.js
export const INITIAL_VALUES = {
  PADDLE_HEIGHT: 100,
  PADDLE_SPEED: 300,
  BALL_SPEED: 200,
  POINT_MULTIPLIER: 1,
  PADDLE_PREDICTION: 0.8,
  COMBO_MULTIPLIER: 1.2,
  PADDLE_WIDTH: 20,
  BALL_SIZE: 10,
};

export const UPGRADE_COSTS = {
  PADDLE_HEIGHT: 10,
  PADDLE_SPEED: 15,
  POINT_MULTIPLIER: 25,
  BALL_SPEED: 20,
  PADDLE_PREDICTION: 30,
  COMBO_MULTIPLIER: 40,
};

```
```js src/game/assetManifest.js
export const SPRITES = {};

```
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} points)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Score: {Math.floor(game.score)} | Combo: x{game.consecutiveHits}</p>
    <p>Current Multiplier: x{(game.pointMultiplier * Math.pow(game.comboMultiplier, game.consecutiveHits - 1)).toFixed(2)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradePaddleHeight()} cost={game.paddleHeightCost}>
          Upgrade Paddle Height
        </Button>
        <Button onClick={() => game.upgradePaddleSpeed()} cost={game.paddleSpeedCost}>
          Upgrade Paddle Speed
        </Button>
        <Button onClick={() => game.upgradePointMultiplier()} cost={game.pointMultiplierCost}>
          Upgrade Point Multiplier
        </Button>
        <Button onClick={() => game.upgradeBallSpeed()} cost={game.ballSpeedCost}>
          Upgrade Ball Speed
        </Button>
        <Button onClick={() => game.upgradePaddlePrediction()} cost={game.paddlePredictionCost}>
          Upgrade Paddle Prediction
        </Button>
        <Button onClick={() => game.upgradeComboMultiplier()} cost={game.comboMultiplierCost}>
          Upgrade Combo Multiplier
        </Button>
      </div>
    </div>
  );
};

export default GameUI;

```
```js src/game/fontManifest.js
export const FONTS = [
  'Press Start 2P',
  'Roboto:400,700',
  'Orbitron:400,700',
]
```

Only make changes to the GameUI or fontManifest file. Don't change anything about the logic or functionality but make the UI look much better and make it feel like a very well implemented game. You can add multilayered menu interactions.


Make sure that only the essential data (such as currency) is shown in the hud and the other stats are hidden in a stats modal

Upgrades should be in modals and submenus instead of being directly on the screen


Make sure that the theme of your UI matches with the theme of the game

Make sure all modals can be opened and closed

General Implementation Guidelines:
1. Write out all the code of the files you intend to edit. I will be copy-pasting them
2. Do not create new files, add to the existing files in the appropriate locations
3. Do not do any refactoring outside of what you are requested to do

Directions:
In your response, do both steps, one after the other
1. First think carefully and describe in detail how you will implement the game design. Make sure to follow all the guidelines
2. Then write each file, according to the plan

Write out all the files in the format:
```filetype filepath
content
```

MOST IMPORTANT: Do not write "existing code here" or similar placeholders. If a file has been edited in anyway,
EVERY original unchanged line must be rewritten in your output
__________________
Role: assistant
Content: Let me plan out the UI improvements:

1. Theme Analysis:
- The game appears to be a futuristic/cyber Pong variant
- Using neon colors, dark backgrounds, and sci-fi elements would fit well
- Will use Orbitron font for the futuristic look

2. UI Structure:
- Main HUD: Only show score and current combo multiplier
- Stats Button: Opens modal showing detailed stats
- Upgrades Button: Opens upgrade menu modal
- Settings Button: Already exists, keeps debug functionality

3. Modal System:
- Base Modal Component: Reusable backdrop and container
- Stats Modal: Shows all game statistics
- Upgrades Modal:
  - Categories: Paddle, Ball, Scoring
  - Each category shows relevant upgrades
- Sci-fi styling with glowing borders and hover effects

4. Animations:
- Smooth transitions for modals
- Hover effects on buttons
- Pulse animations for important elements

Now, let's implement the files:

```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';
import { Activity, Award, Box, ChevronRight, X } from 'lucide-react';

const Modal = ({ isOpen, onClose, children, title }) => {
  if (!isOpen) return null;
  return (
    <div className="modal-backdrop" onClick={onClose} style={{
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.8)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 100,
    }}>
      <div className="modal-content" onClick={e => e.stopPropagation()} style={{
        backgroundColor: '#1a1a2e',
        border: '2px solid #7C45CB',
        borderRadius: '10px',
        padding: '20px',
        width: '80%',
        maxWidth: '600px',
        maxHeight: '80%',
        overflow: 'auto',
        boxShadow: '0 0 20px rgba(124, 69, 203, 0.3)',
      }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
          <h2 style={{ margin: 0, fontFamily: 'Orbitron', color: '#7C45CB' }}>{title}</h2>
          <X onClick={onClose} style={{ cursor: 'pointer', color: '#7C45CB' }} />
        </div>
        {children}
      </div>
    </div>
  );
};

const Button = ({ onClick, children, cost, disabled }) => (
  <button 
    onClick={onClick} 
    disabled={disabled}
    style={{
      margin: '5px',
      padding: '10px 15px',
      fontSize: '14px',
      color: disabled ? '#666' : '#fff',
      border: 'none',
      cursor: disabled ? 'not-allowed' : 'pointer',
      backgroundColor: disabled ? '#333' : '#7C45CB',
      borderRadius: '5px',
      fontFamily: 'Orbitron',
      transition: 'all 0.2s',
      opacity: disabled ? 0.5 : 1,
    }}
  >
    {children} {cost && `(${cost} points)`}
  </button>
);

const HUD = ({ game }) => (
  <div style={{ 
    position: 'absolute', 
    top: 0, 
    left: 0, 
    right: 0, 
    padding: '15px', 
    background: 'linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%)',
    color: '#fff',
    fontFamily: 'Orbitron',
  }}>
    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
      <span style={{ fontSize: '24px' }}>Score: {Math.floor(game.score)}</span>
      <span style={{ color: '#7C45CB' }}>Combo: x{game.consecutiveHits}</span>
    </div>
  </div>
);

const UpgradeSection = ({ title, upgrades }) => (
  <div style={{ marginBottom: '20px' }}>
    <h3 style={{ color: '#7C45CB', fontFamily: 'Orbitron', borderBottom: '1px solid #7C45CB' }}>{title}</h3>
    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '10px' }}>
      {upgrades}
    </div>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  const [showStats, setShowStats] = useState(false);
  const [showUpgrades, setShowUpgrades] = useState(false);

  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#fff' }}>
      <HUD game={game} />
      
      <div style={{ position: 'absolute', bottom: '20px', right: '20px', display: 'flex', gap: '10px' }}>
        <Button onClick={() => setShowStats(true)}>
          <Activity size={20} />
        </Button>
        <Button onClick={() => setShowUpgrades(true)}>
          <Award size={20} />
        </Button>
      </div>

      <Modal isOpen={showStats} onClose={() => setShowStats(false)} title="Statistics">
        <div style={{ fontFamily: 'Orbitron' }}>
          <p>Current Multiplier: x{(game.pointMultiplier * Math.pow(game.comboMultiplier, game.consecutiveHits - 1)).toFixed(2)}</p>
          <p>Paddle Height: {game.paddleHeight}</p>
          <p>Paddle Speed: {game.paddleSpeed.toFixed(1)}</p>
          <p>Ball Speed: {game.ballSpeed.toFixed(1)}</p>
          <p>Prediction Accuracy: {(game.paddlePrediction * 100).toFixed(1)}%</p>
        </div>
      </Modal>

      <Modal isOpen={showUpgrades} onClose={() => setShowUpgrades(false)} title="Upgrades">
        <UpgradeSection title="Paddle Upgrades" upgrades={[
          <Button 
            onClick={() => game.upgradePaddleHeight()} 
            cost={game.paddleHeightCost}
            disabled={game.score < game.paddleHeightCost}
          >
            Paddle Height
          </Button>,
          <Button 
            onClick={() => game.upgradePaddleSpeed()} 
            cost={game.paddleSpeedCost}
            disabled={game.score < game.paddleSpeedCost}
          >
            Paddle Speed
          </Button>,
          <Button 
            onClick={() => game.upgradePaddlePrediction()} 
            cost={game.paddlePredictionCost}
            disabled={game.score < game.paddlePredictionCost}
          >
            Prediction
          </Button>
        ]} />

        <UpgradeSection title="Ball Upgrades" upgrades={[
          <Button 
            onClick={() => game.upgradeBallSpeed()} 
            cost={game.ballSpeedCost}
            disabled={game.score < game.ballSpeedCost}
          >
            Ball Speed
          </Button>
        ]} />

        <UpgradeSection title="Scoring Upgrades" upgrades={[
          <Button 
            onClick={() => game.upgradePointMultiplier()} 
            cost={game.pointMultiplierCost}
            disabled={game.score < game.pointMultiplierCost}
          >
            Point Multiplier
          </Button>,
          <Button 
            onClick={() => game.upgradeComboMultiplier()} 
            cost={game.comboMultiplierCost}
            disabled={game.score < game.comboMultiplierCost}
          >
            Combo Multiplier
          </Button>
        ]} />
      </Modal>
    </div>
  );
};

export default GameUI;
```

```js src/game/fontManifest.js
export const FONTS = [
  'Orbitron:400,700',
  'Roboto:400,700',
  'Press Start 2P',
];
```

The UI now has a cohesive cyber/futuristic theme with organized modals and clean information hierarchy. The HUD shows only essential information while detailed stats and upgrades are accessible through dedicated modals.
__________________
