Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me analyze the logs:

1. Currency starts at 0 for first 5 seconds
2. At 6s, currency increases to 10
3. At 8s, currency increases to 20
4. At 13.4s, player purchases DRONE_SPEED upgrade for 25 crystals, reducing currency to 5
5. Currency stays at 5 for the remaining 17 seconds

This indicates issue #1 - Currency never changes after the upgrade. The currency gets stuck at 5 crystals and never increases again.

Looking at the code, I found the likely cause:
In `gameLogic.js`, the `moveTo` function returns true when distance < 5, but doesn't actually complete the movement to the exact target position. This means drones get "stuck" slightly off from their targets, never completing their routes.

The fix:
1. Modify the `moveTo` function to ensure drones reach their exact target positions
2. When distance is very small, snap directly to target position instead of doing partial movement

Here's the implementation:

# Excerpt ID: c849f97b-ed52-4adc-80ba-1de9d58084b6
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
    width: 800,
    height: 600
}

export class GameLogic {
    constructor(container) {
        this.app = new PIXI.Application({
            width: SCREEN_SIZE.width,
            height: SCREEN_SIZE.height,
            backgroundColor: 0x000000,
        });

        container.appendChild(this.app.view);

        this.ready = false;
        this.crystals = 0;
        this.droneCount = INITIAL_VALUES.DRONE_COUNT;
        this.droneSpeed = INITIAL_VALUES.DRONE_SPEED;
        this.droneCapacity = INITIAL_VALUES.DRONE_CAPACITY;
        this.maxAsteroids = INITIAL_VALUES.MAX_ASTEROIDS;
        this.asteroidCapacity = INITIAL_VALUES.ASTEROID_CAPACITY;
        
        this.droneCost = UPGRADE_COSTS.DRONE_COUNT;
        this.speedCost = UPGRADE_COSTS.DRONE_SPEED;
        this.capacityCost = UPGRADE_COSTS.DRONE_CAPACITY;
        this.asteroidCountCost = UPGRADE_COSTS.MAX_ASTEROIDS;
        this.asteroidCapacityCost = UPGRADE_COSTS.ASTEROID_CAPACITY;

        loadAssets(SPRITES, () => {
            if (!this.app.stage) return;
            this.createGameObjects();
            this.app.ticker.add(this.gameLoop.bind(this));
            this.ready = true;
        });
    }

    getSprite(spriteConfig) {
        const texture = PIXI.Texture.from(spriteConfig.path);
        const sprite = new PIXI.Sprite(texture);
        sprite.width = spriteConfig.width;
        sprite.height = spriteConfig.height;
        return sprite;
    }

    createGameObjects() {
        this.background = this.getSprite(SPRITES.background);
        this.app.stage.addChild(this.background);

        // Create station
        this.station = this.getSprite(SPRITES.station);
        this.station.anchor.set(0.5);
        this.station.x = SCREEN_SIZE.width / 2;
        this.station.y = SCREEN_SIZE.height / 2;
        
        // Create containers
        this.drones = new PIXI.Container();
        this.asteroids = new PIXI.Container();

        this.app.stage.addChild(this.station);
        this.app.stage.addChild(this.asteroids);
        this.app.stage.addChild(this.drones);

        // Create initial drones and asteroids
        this.createDrone();
        this.createAsteroid();
    }

    createDrone() {
        const drone = this.getSprite(SPRITES.drone);
        drone.anchor.set(0.5);
        drone.x = this.station.x;
        drone.y = this.station.y;
        drone.cargo = 0;
        drone.state = 'idle';
        drone.target = null;
        drone.miningTimer = 0;
        this.drones.addChild(drone);
    }

    createAsteroid() {
        if (this.asteroids.children.length >= this.maxAsteroids) return;

        const asteroid = this.getSprite(SPRITES.asteroid);
        asteroid.anchor.set(0.5);
        asteroid.x = Math.random() * SCREEN_SIZE.width;
        asteroid.y = Math.random() * SCREEN_SIZE.height;
        asteroid.crystals = this.asteroidCapacity;
        asteroid.claimed = false;
        this.asteroids.addChild(asteroid);
    }

    gameLoop(delta) {
        const elapsedSecs = delta / 60;

        this.drones.children.forEach(drone => {
            switch(drone.state) {
                case 'idle':
                    const freeAsteroid = this.asteroids.children.find(a => !a.claimed && a.crystals > 0);
                    if (freeAsteroid) {
                        drone.target = freeAsteroid;
                        freeAsteroid.claimed = true;
                        drone.state = 'moving_to_asteroid';
                    }
                    break;

                case 'moving_to_asteroid':
                    const toAsteroid = this.moveTo(drone, drone.target.x, drone.target.y, elapsedSecs);
                    if (toAsteroid) {
                        drone.state = 'mining';
                        drone.miningTimer = 0;
                    }
                    break;

                case 'mining':
                    drone.miningTimer += elapsedSecs;
                    if (drone.miningTimer >= INITIAL_VALUES.MINING_TIME) {
                        const mineAmount = Math.min(
                            this.droneCapacity - drone.cargo,
                            drone.target.crystals
                        );
                        drone.cargo += mineAmount;
                        drone.target.crystals -= mineAmount;

                        if (drone.target.crystals <= 0) {
                            this.asteroids.removeChild(drone.target);
                            this.createAsteroid();
                        }
                        drone.state = 'returning';
                    }
                    break;

                case 'returning':
                    const toStation = this.moveTo(drone, this.station.x, this.station.y, elapsedSecs);
                    if (toStation) {
                        this.crystals += drone.cargo;
                        drone.cargo = 0;
                        drone.target = null;
                        drone.state = 'idle';
                    }
                    break;
            }
        });

        if (this.asteroids.children.length < this.maxAsteroids) {
            this.createAsteroid();
        }
    }

    moveTo(drone, targetX, targetY, elapsedSecs) {
        const dx = targetX - drone.x;
        const dy = targetY - drone.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 5) {
            // Snap to exact position when very close
            drone.x = targetX;
            drone.y = targetY;
            return true;
        }

        const moveDistance = this.droneSpeed * elapsedSecs;
        const ratio = moveDistance / distance;
        
        drone.x += dx * ratio;
        drone.y += dy * ratio;
        drone.rotation = Math.atan2(dy, dx);
        
        return false;
    }

    upgradeDroneCount() {
        if (this.crystals >= this.droneCost) {
            this.crystals -= this.droneCost;
            this.droneCount++;
            this.createDrone();
            this.droneCost *= 2;
        }
    }

    upgradeDroneSpeed() {
        if (this.crystals >= this.speedCost) {
            this.crystals -= this.speedCost;
            this.droneSpeed *= 1.2;
            this.speedCost *= 2;
        }
    }

    upgradeDroneCapacity() {
        if (this.crystals >= this.capacityCost) {
            this.crystals -= this.capacityCost;
            this.droneCapacity = Math.floor(this.droneCapacity * 1.5);
            this.capacityCost *= 2;
        }
    }

    upgradeMaxAsteroids() {
        if (this.crystals >= this.asteroidCountCost) {
            this.crystals -= this.asteroidCountCost;
            this.maxAsteroids++;
            this.createAsteroid();
            this.asteroidCountCost *= 2;
        }
    }

    upgradeAsteroidCapacity() {
        if (this.crystals >= this.asteroidCapacityCost) {
            this.crystals -= this.asteroidCapacityCost;
            this.asteroidCapacity = Math.floor(this.asteroidCapacity * 1.5);
            this.asteroidCapacityCost *= 2;
        }
    }

    destroy() {
        this.app.destroy(true);
    }
}
```

The key change is in the `moveTo` function. Instead of just returning true when distance < 5, we now snap the drone to the exact target position. This ensures the drone actually reaches its destination and can properly complete its tasks.

This should fix the issue where currency stops increasing after the upgrade. The drones will now properly complete their routes, deposit crystals at the station, and continue mining operations.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
