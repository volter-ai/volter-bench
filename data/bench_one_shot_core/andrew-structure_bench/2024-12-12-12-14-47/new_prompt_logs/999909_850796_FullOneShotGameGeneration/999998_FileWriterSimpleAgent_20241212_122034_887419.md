Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Implementation Plan:
- The game is a coffee shop management game where we need to optimize various upgrades
- Main currency is money, tracked in `this.game.money`
- Available upgrades from the game code:
  * Hire Barista (adds new barista)
  * Upgrade Barista Speed (increases service speed)
  * Upgrade Brewing Speed (reduces coffee preparation time)
  * Increase Customer Capacity (allows more concurrent customers)
  * Increase Coffee Price (increases revenue per customer)
- For the AI implementation:
  * Track all upgrade types in UPGRADES array
  * Track upgrade levels and costs
  * In experimental mode: randomly apply 0-10 upgrades of each type
  * In standard mode: continuously buy cheapest available upgrade
  * Log all currency changes and upgrades
  * Update stats display with current game state
  * Handle game speed modification

2. Here's the implementation:

# Excerpt ID: b1bab06b-cde5-457a-a23a-1844ad3304c9
```javascript src/GameAI.js
import { AIUtils } from './AIUtils';
import { INITIAL_VALUES, UPGRADE_COSTS, GAME_CONFIG } from './game/gameData';

const UPGRADES = [
  'BARISTA',
  'BARISTA_SPEED',
  'BREW_SPEED',
  'MAX_CUSTOMERS',
  'PRICE_MULTIPLIER'
];

export class GameAI {
  constructor() {
    this.ai = new AIUtils();
    this.game = null;
    this.initialized = false;
    // Initialize upgrade levels for all upgrade types
    this.upgradeLevels = UPGRADES.reduce((acc, upgrade) => {
      acc[upgrade] = 0;
      return acc;
    }, {});
  }

  init() {
    if (!window.game || !window.game.ready) {
      setTimeout(() => this.init(), 100);
      return;
    }
    this.game = window.game;

    if (this.initialized) return;
    this.initialized = true;

    window.game.app.ticker.speed = this.ai.defaultGameSpeed;
    this.ai.updateDebugOverlay('Game speed set to ' + this.ai.defaultGameSpeed + 'x');

    if (this.ai.enabled) {
      this.ai.gameStartTime = Date.now();

      if (this.ai.mode === 'experimental') {
        this.setupExperimentalMode();
      }

      this.ai.startLoggingLoop(this.getMainCurrency.bind(this));
      this.startUpgradeLoop();
      this.updateGameStats();

      setTimeout(() => {
        this.ai.stopAI();
        this.ai.exportLogs();
        this.ai.updateDebugOverlay('Session ended - logs exported');
      }, this.ai.duration);
    }
  }

  getMainCurrency() {
    return this.game.money;
  }

  setupExperimentalMode() {
    // Give infinite money for experimental mode
    this.game.money = Number.MAX_SAFE_INTEGER;

    // Randomly upgrade each stat between 0-10 times
    UPGRADES.forEach(upgrade => {
      const times = Math.floor(Math.random() * 11); // 0 to 10
      for (let i = 0; i < times; i++) {
        this.performUpgrade(upgrade, 0, true);
      }
    });

    this.ai.updateDebugOverlay('Experimental mode initialized with random upgrades');
  }

  updateGameStats() {
    const stats = {
      Money: Math.floor(this.game.money),
      'Barista Count': this.game.baristaCount,
      'Barista Speed': this.game.baristaSpeed.toFixed(2),
      'Brew Time': this.game.brewTime.toFixed(2),
      'Max Customers': this.game.maxCustomers,
      'Coffee Price': this.game.coffeePrice.toFixed(2)
    };

    this.ai.updateDebugOverlay('Game stats updated', stats);
  }

  startUpgradeLoop() {
    if (!this.ai.enabled || this.ai.mode === 'experimental') return;

    this.upgradeInterval = setInterval(() => {
      this.checkCheapestUpgrade();
      this.updateGameStats();
    }, 100);
  }

  checkCheapestUpgrade() {
    let cheapestUpgrade = null;
    let lowestCost = Infinity;

    const costs = {
      BARISTA: this.game.baristaCost,
      BARISTA_SPEED: this.game.baristaSpeedCost,
      BREW_SPEED: this.game.brewSpeedCost,
      MAX_CUSTOMERS: this.game.maxCustomersCost,
      PRICE_MULTIPLIER: this.game.priceCost
    };

    for (const upgrade of UPGRADES) {
      const cost = costs[upgrade];
      if (cost <= this.game.money && cost < lowestCost) {
        cheapestUpgrade = upgrade;
        lowestCost = cost;
      }
    }

    if (cheapestUpgrade) {
      this.performUpgrade(cheapestUpgrade, lowestCost);
    }
  }

  performUpgrade(upgradeName, cost, skipLogging = false) {
    // Increment the upgrade level before performing the upgrade
    this.upgradeLevels[upgradeName]++;
    const currentLevel = this.upgradeLevels[upgradeName];

    switch (upgradeName) {
      case 'BARISTA':
        this.game.upgradeBarista();
        break;
      case 'BARISTA_SPEED':
        this.game.upgradeBaristaSpeed();
        break;
      case 'BREW_SPEED':
        this.game.upgradeBrewSpeed();
        break;
      case 'MAX_CUSTOMERS':
        this.game.upgradeMaxCustomers();
        break;
      case 'PRICE_MULTIPLIER':
        this.game.upgradeCoffeePrice();
        break;
      default:
        console.error(`${upgradeName} is not a valid upgrade`);
    }

    if (!skipLogging) {
      const upgradeInfo = {
        timestamp: Date.now(),
        upgrade: upgradeName,
        cost: cost,
        level: currentLevel
      };

      this.ai.logUpgrade(upgradeInfo);
      this.ai.updateDebugOverlay(`Purchased ${upgradeName} upgrade for ${cost} (Level ${currentLevel})`);
    }
  }
}

const gameAI = new GameAI();
gameAI.init();

if (window.game) {
  window.game.exportAILogs = () => gameAI.ai.exportLogs();
  window.game.clearAILogs = () => gameAI.ai.clearLogs();
}

export default gameAI;
```

This implementation:
1. Defines all available upgrades in the UPGRADES array
2. Tracks upgrade levels for each type
3. Implements experimental mode with random upgrades
4. Implements standard mode that buys cheapest available upgrade
5. Updates and logs game stats regularly
6. Handles all upgrade types through the performUpgrade method
7. Integrates with the AIUtils for logging and UI updates
8. Maintains game speed control
9. Exports logs at the end of the session

The AI will continuously optimize the coffee shop by purchasing the most cost-effective upgrades available, while maintaining detailed logs of all actions and currency changes.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
