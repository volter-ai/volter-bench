Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data Requirements:
- Initial values for tank attributes (speed, health, damage, etc)
- Base upgrade costs
- Enemy tank spawn parameters
- Credit reward values

2. Asset Requirements:
- Tank sprite for friendly units
- Tank sprite for enemy units
- Background image

3. Game Logic Implementation:
- Tank class/structure with properties:
  - Position, velocity
  - Health
  - Target
  - Team (friendly/enemy)
  - Shooting cooldown
- Core systems:
  - Tank movement and targeting
  - Combat (shooting, damage)
  - Enemy spawning
  - Credit accumulation
  - Upgrade system
  - Collision detection

4. UI Requirements:
- Credit counter
- Health bars for tanks
- Upgrade buttons with costs
- Basic stats display

Now, I'll implement each file:

# Excerpt ID: f9bd1303-c176-4c47-9097-e3ab2614a6de
```js src/game/gameData.js
export const INITIAL_VALUES = {
  TANK_SPEED: 100,  // pixels per second
  TANK_HEALTH: 100,
  TANK_DAMAGE: 20,
  FIRE_RATE: 1,     // shots per second
  DETECTION_RANGE: 200,
  TANK_COUNT: 1,
  ENEMY_SPAWN_RATE: 3, // seconds between spawns
  CREDITS_PER_KILL: 10,
  BULLET_SPEED: 300,
};

export const UPGRADE_COSTS = {
  TANK_COUNT: 100,
  TANK_SPEED: 50,
  TANK_DAMAGE: 75,
  TANK_HEALTH: 60,
  FIRE_RATE: 80,
  DETECTION_RANGE: 40,
};

export const ENEMY_CONFIG = {
  HEALTH: 50,
  SPEED: 80,
  DAMAGE: 15,
  FIRE_RATE: 0.8,
};
```

# Excerpt ID: 297f17bb-512d-4de3-9ce0-6babdd6934c1
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  friendlyTank: {
    path: 'assets/friendly_tank.png',
    width: 64,
    height: 64
  },
  enemyTank: {
    path: 'assets/enemy_tank.png',
    width: 64,
    height: 64
  }
};
```

# Excerpt ID: 3c1883c3-d97a-4f72-ad16-6f6023519fb2
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, ENEMY_CONFIG } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils';

const SCREEN_SIZE = {
  width: 800,
  height: 600
};

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.credits = 0;
    this.tankSpeed = INITIAL_VALUES.TANK_SPEED;
    this.tankHealth = INITIAL_VALUES.TANK_HEALTH;
    this.tankDamage = INITIAL_VALUES.TANK_DAMAGE;
    this.fireRate = INITIAL_VALUES.FIRE_RATE;
    this.detectionRange = INITIAL_VALUES.DETECTION_RANGE;
    this.tankCount = INITIAL_VALUES.TANK_COUNT;
    
    this.costs = {...UPGRADE_COSTS};
    this.enemySpawnTimer = 0;
    this.lastTimestamp = performance.now();

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.friendlyTanks = new PIXI.Container();
    this.enemyTanks = new PIXI.Container();
    this.bullets = new PIXI.Container();
    this.healthBars = new PIXI.Container();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.friendlyTanks);
    this.app.stage.addChild(this.enemyTanks);
    this.app.stage.addChild(this.bullets);
    this.app.stage.addChild(this.healthBars);

    for (let i = 0; i < this.tankCount; i++) {
      this.createFriendlyTank();
    }
  }

  createFriendlyTank() {
    const tank = this.getSprite(SPRITES.friendlyTank);
    tank.anchor.set(0.5);
    tank.x = Math.random() * (this.app.screen.width / 2);
    tank.y = Math.random() * this.app.screen.height;
    tank.health = this.tankHealth;
    tank.shootTimer = 0;
    tank.targetX = Math.random() * (this.app.screen.width / 2);
    tank.targetY = Math.random() * this.app.screen.height;
    this.friendlyTanks.addChild(tank);
  }

  createEnemyTank() {
    const tank = this.getSprite(SPRITES.enemyTank);
    tank.anchor.set(0.5);
    tank.x = this.app.screen.width;
    tank.y = Math.random() * this.app.screen.height;
    tank.health = ENEMY_CONFIG.HEALTH;
    tank.shootTimer = 0;
    
    const healthBar = new PIXI.Graphics();
    healthBar.tank = tank;
    this.healthBars.addChild(healthBar);
    tank.healthBar = healthBar;
    
    this.enemyTanks.addChild(tank);
  }

  createBullet(x, y, targetX, targetY, friendly) {
    const bullet = new PIXI.Graphics();
    bullet.beginFill(friendly ? 0x00ff00 : 0xff0000);
    bullet.drawCircle(0, 0, 3);
    bullet.endFill();
    bullet.x = x;
    bullet.y = y;
    
    const angle = Math.atan2(targetY - y, targetX - x);
    bullet.dx = Math.cos(angle) * INITIAL_VALUES.BULLET_SPEED;
    bullet.dy = Math.sin(angle) * INITIAL_VALUES.BULLET_SPEED;
    bullet.friendly = friendly;
    bullet.damage = friendly ? this.tankDamage : ENEMY_CONFIG.DAMAGE;
    
    this.bullets.addChild(bullet);
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    this.updateTanks(elapsedSecs);
    this.updateBullets(elapsedSecs);
    this.updateHealthBars();
    this.spawnEnemies(elapsedSecs);
  }

  updateTanks(elapsedSecs) {
    this.friendlyTanks.children.forEach(tank => {
      tank.shootTimer -= elapsedSecs;
      
      let nearestEnemy = null;
      let minDist = this.detectionRange;
      
      this.enemyTanks.children.forEach(enemy => {
        const dist = Math.hypot(enemy.x - tank.x, enemy.y - tank.y);
        if (dist < minDist) {
          minDist = dist;
          nearestEnemy = enemy;
        }
      });

      if (nearestEnemy) {
        tank.targetX = nearestEnemy.x;
        tank.targetY = nearestEnemy.y;
        
        if (tank.shootTimer <= 0) {
          this.createBullet(tank.x, tank.y, nearestEnemy.x, nearestEnemy.y, true);
          tank.shootTimer = 1 / this.fireRate;
        }
      } else if (Math.hypot(tank.targetX - tank.x, tank.targetY - tank.y) < 10) {
        tank.targetX = Math.random() * (this.app.screen.width / 2);
        tank.targetY = Math.random() * this.app.screen.height;
      }

      const angle = Math.atan2(tank.targetY - tank.y, tank.targetX - tank.x);
      tank.rotation = angle + Math.PI/2;
      
      const speed = nearestEnemy ? this.tankSpeed : this.tankSpeed * 0.5;
      tank.x += Math.cos(angle) * speed * elapsedSecs;
      tank.y += Math.sin(angle) * speed * elapsedSecs;
    });

    this.enemyTanks.children.forEach(tank => {
      tank.shootTimer -= elapsedSecs;
      
      const nearestFriendly = this.friendlyTanks.children[0];
      if (nearestFriendly) {
        const angle = Math.atan2(nearestFriendly.y - tank.y, nearestFriendly.x - tank.x);
        tank.rotation = angle + Math.PI/2;
        
        tank.x += Math.cos(angle) * ENEMY_CONFIG.SPEED * elapsedSecs;
        tank.y += Math.sin(angle) * ENEMY_CONFIG.SPEED * elapsedSecs;
        
        if (tank.shootTimer <= 0) {
          this.createBullet(tank.x, tank.y, nearestFriendly.x, nearestFriendly.y, false);
          tank.shootTimer = 1 / ENEMY_CONFIG.FIRE_RATE;
        }
      }
    });
  }

  updateBullets(elapsedSecs) {
    this.bullets.children.forEach(bullet => {
      bullet.x += bullet.dx * elapsedSecs;
      bullet.y += bullet.dy * elapsedSecs;
      
      if (bullet.x < 0 || bullet.x > this.app.screen.width || 
          bullet.y < 0 || bullet.y > this.app.screen.height) {
        this.bullets.removeChild(bullet);
        return;
      }

      const targets = bullet.friendly ? this.enemyTanks : this.friendlyTanks;
      targets.children.forEach(tank => {
        if (Math.hypot(tank.x - bullet.x, tank.y - bullet.y) < 32) {
          tank.health -= bullet.damage;
          this.bullets.removeChild(bullet);
          
          if (tank.health <= 0) {
            if (!bullet.friendly) {
              tank.health = this.tankHealth;
              tank.x = Math.random() * (this.app.screen.width / 2);
              tank.y = Math.random() * this.app.screen.height;
            } else {
              this.credits += INITIAL_VALUES.CREDITS_PER_KILL;
              this.enemyTanks.removeChild(tank);
              this.healthBars.removeChild(tank.healthBar);
            }
          }
        }
      });
    });
  }

  updateHealthBars() {
    this.healthBars.children.forEach(bar => {
      const tank = bar.tank;
      bar.clear();
      bar.beginFill(0xff0000);
      bar.drawRect(tank.x - 32, tank.y - 40, 64, 5);
      bar.beginFill(0x00ff00);
      bar.drawRect(tank.x - 32, tank.y - 40, 64 * (tank.health / ENEMY_CONFIG.HEALTH), 5);
    });
  }

  spawnEnemies(elapsedSecs) {
    this.enemySpawnTimer -= elapsedSecs;
    if (this.enemySpawnTimer <= 0) {
      this.createEnemyTank();
      this.enemySpawnTimer = INITIAL_VALUES.ENEMY_SPAWN_RATE;
    }
  }

  upgradeTankCount() {
    if (this.credits >= this.costs.TANK_COUNT) {
      this.credits -= this.costs.TANK_COUNT;
      this.tankCount++;
      this.createFriendlyTank();
      this.costs.TANK_COUNT *= 2;
    }
  }

  upgradeTankSpeed() {
    if (this.credits >= this.costs.TANK_SPEED) {
      this.credits -= this.costs.TANK_SPEED;
      this.tankSpeed *= 1.2;
      this.costs.TANK_SPEED *= 2;
    }
  }

  upgradeTankDamage() {
    if (this.credits >= this.costs.TANK_DAMAGE) {
      this.credits -= this.costs.TANK_DAMAGE;
      this.tankDamage *= 1.2;
      this.costs.TANK_DAMAGE *= 2;
    }
  }

  upgradeTankHealth() {
    if (this.credits >= this.costs.TANK_HEALTH) {
      this.credits -= this.costs.TANK_HEALTH;
      this.tankHealth *= 1.2;
      this.friendlyTanks.children.forEach(tank => {
        tank.health = this.tankHealth;
      });
      this.costs.TANK_HEALTH *= 2;
    }
  }

  upgradeFireRate() {
    if (this.credits >= this.costs.FIRE_RATE) {
      this.credits -= this.costs.FIRE_RATE;
      this.fireRate *= 1.2;
      this.costs.FIRE_RATE *= 2;
    }
  }

  upgradeDetectionRange() {
    if (this.credits >= this.costs.DETECTION_RANGE) {
      this.credits -= this.costs.DETECTION_RANGE;
      this.detectionRange *= 1.2;
      this.costs.DETECTION_RANGE *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: 7d6a5d79-9049-46e9-9fe9-105491ecd29c
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
    position: 'relative',
  }}>
    {children} ({cost} credits)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Credits: {game.credits} | Tanks: {game.tankCount} | Damage: {Math.floor(game.tankDamage)} | Health: {Math.floor(game.tankHealth)} | Fire Rate: {game.fireRate.toFixed(1)} | Range: {Math.floor(game.detectionRange)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeTankCount()} cost={game.costs.TANK_COUNT}>Add Tank</Button>
        <Button onClick={() => game.upgradeTankSpeed()} cost={game.costs.TANK_SPEED}>Upgrade Speed</Button>
        <Button onClick={() => game.upgradeTankDamage()} cost={game.costs.TANK_DAMAGE}>Upgrade Damage</Button>
        <Button onClick={() => game.upgradeTankHealth()} cost={game.costs.TANK_HEALTH}>Upgrade Health</Button>
        <Button onClick={() => game.upgradeFireRate()} cost={game.costs.FIRE_RATE}>Upgrade Fire Rate</Button>
        <Button onClick={() => game.upgradeDetectionRange()} cost={game.costs.DETECTION_RANGE}>Upgrade Range</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the requested features:
1. Auto-playing tanks that patrol and engage enemies
2. Enemy tanks that spawn and attack friendly tanks
3. Credit system for destroying enemies
4. All six specified upgrades
5. Health bars for enemy tanks
6. Proper movement and combat systems
7. All timers and movements use elapsed seconds
8. Proper sprite sizes (64x64)
9. Complete UI with credits display and upgrade buttons

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
