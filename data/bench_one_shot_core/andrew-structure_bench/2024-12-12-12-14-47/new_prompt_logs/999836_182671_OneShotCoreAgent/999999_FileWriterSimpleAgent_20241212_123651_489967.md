Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data Requirements:
- Initial values for paddle height, paddle speed, point multiplier, ball speed, speed scaling
- Base costs for upgrades and cost multiplier (doubling)
- Screen dimensions and paddle/ball sizes

2. Game Logic Implementation:
- Create paddles and ball as PIXI sprites
- Track score/points as currency
- Implement linear paddle AI movement to track ball
- Handle ball movement, bouncing, and speed increases
- Reset game when ball is missed
- Calculate points based on ball speed
- Implement all upgrades to affect gameplay values

3. UI Requirements:
- Display current score
- Show current game stats (speeds, multipliers)
- Upgrade buttons with costs
- Simple layout with stats at top, buttons at bottom

Now let's implement the files:

# Excerpt ID: e4ff1638-f090-4195-b832-0e3a93cd9ded
```js src/game/gameData.js
export const INITIAL_VALUES = {
  PADDLE_HEIGHT: 100,
  PADDLE_SPEED: 300,
  POINT_MULTIPLIER: 1,
  BALL_SPEED: 200,
  SPEED_SCALING: 1.1
};

export const UPGRADE_COSTS = {
  PADDLE_HEIGHT: 10,
  PADDLE_SPEED: 15,
  POINT_MULTIPLIER: 25,
  BALL_SPEED: 20,
  SPEED_SCALING: 30
};

export const GAME_CONFIG = {
  PADDLE_WIDTH: 20,
  BALL_SIZE: 16,
  PADDLE_EDGE_MARGIN: 50
};
```

# Excerpt ID: 7e1cd809-ccc4-4760-a173-996a3101f0f2
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  paddle: {
    path: 'assets/paddle.png',
    width: 20,
    height: 100
  },
  ball: {
    path: 'assets/ball.png',
    width: 16,
    height: 16
  }
};
```

# Excerpt ID: 5cc1da3d-86a0-48e5-a73e-7955bc1f162a
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAME_CONFIG } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;
    this.lastTimestamp = performance.now();
    
    // Game values
    this.paddleHeight = INITIAL_VALUES.PADDLE_HEIGHT;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.pointMultiplier = INITIAL_VALUES.POINT_MULTIPLIER;
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.currentBallSpeed = INITIAL_VALUES.BALL_SPEED;
    this.speedScaling = INITIAL_VALUES.SPEED_SCALING;

    // Upgrade costs
    this.paddleHeightCost = UPGRADE_COSTS.PADDLE_HEIGHT;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;
    this.pointMultiplierCost = UPGRADE_COSTS.POINT_MULTIPLIER;
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.speedScalingCost = UPGRADE_COSTS.SPEED_SCALING;

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  createGameObjects() {
    // Create paddles
    this.leftPaddle = new PIXI.Graphics();
    this.leftPaddle.beginFill(0xFFFFFF);
    this.leftPaddle.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
    this.leftPaddle.endFill();
    this.leftPaddle.x = GAME_CONFIG.PADDLE_EDGE_MARGIN;
    this.leftPaddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;

    this.rightPaddle = new PIXI.Graphics();
    this.rightPaddle.beginFill(0xFFFFFF);
    this.rightPaddle.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
    this.rightPaddle.endFill();
    this.rightPaddle.x = SCREEN_SIZE.width - GAME_CONFIG.PADDLE_EDGE_MARGIN - GAME_CONFIG.PADDLE_WIDTH;
    this.rightPaddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;

    // Create ball
    this.ball = new PIXI.Graphics();
    this.ball.beginFill(0xFFFFFF);
    this.ball.drawCircle(0, 0, GAME_CONFIG.BALL_SIZE / 2);
    this.ball.endFill();
    this.resetBall();

    this.app.stage.addChild(this.leftPaddle);
    this.app.stage.addChild(this.rightPaddle);
    this.app.stage.addChild(this.ball);
  }

  resetBall() {
    this.ball.x = SCREEN_SIZE.width / 2;
    this.ball.y = SCREEN_SIZE.height / 2;
    this.currentBallSpeed = this.ballSpeed;
    const angle = (Math.random() - 0.5) * Math.PI / 2;
    this.ball.vx = Math.cos(angle) * this.currentBallSpeed * (Math.random() < 0.5 ? 1 : -1);
    this.ball.vy = Math.sin(angle) * this.currentBallSpeed;
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Move paddles towards ball
    this.movePaddle(this.leftPaddle, elapsedSecs);
    this.movePaddle(this.rightPaddle, elapsedSecs);

    // Move ball
    this.ball.x += this.ball.vx * elapsedSecs;
    this.ball.y += this.ball.vy * elapsedSecs;

    // Ball collision with top/bottom
    if (this.ball.y < 0 || this.ball.y > SCREEN_SIZE.height) {
      this.ball.vy *= -1;
    }

    // Ball collision with paddles
    if (this.checkPaddleCollision(this.leftPaddle) || this.checkPaddleCollision(this.rightPaddle)) {
      this.ball.vx *= -1;
      this.currentBallSpeed *= this.speedScaling;
      const speed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
      this.ball.vx = (this.ball.vx / speed) * this.currentBallSpeed;
      this.ball.vy = (this.ball.vy / speed) * this.currentBallSpeed;
      
      // Add score based on current ball speed
      const points = Math.floor(this.currentBallSpeed / 100) * this.pointMultiplier;
      this.score += points;
    }

    // Reset if ball goes past paddle
    if (this.ball.x < 0 || this.ball.x > SCREEN_SIZE.width) {
      this.resetBall();
    }
  }

  movePaddle(paddle, elapsedSecs) {
    const paddleCenter = paddle.y + this.paddleHeight / 2;
    if (Math.abs(paddleCenter - this.ball.y) > 5) {
      const direction = this.ball.y > paddleCenter ? 1 : -1;
      paddle.y += direction * this.paddleSpeed * elapsedSecs;
    }
    paddle.y = Math.max(0, Math.min(SCREEN_SIZE.height - this.paddleHeight, paddle.y));
  }

  checkPaddleCollision(paddle) {
    return this.ball.x >= paddle.x && 
           this.ball.x <= paddle.x + GAME_CONFIG.PADDLE_WIDTH &&
           this.ball.y >= paddle.y && 
           this.ball.y <= paddle.y + this.paddleHeight;
  }

  upgradePaddleHeight() {
    if (this.score >= this.paddleHeightCost) {
      this.score -= this.paddleHeightCost;
      this.paddleHeight += 10;
      this.paddleHeightCost *= 2;
      this.leftPaddle.height = this.paddleHeight;
      this.rightPaddle.height = this.paddleHeight;
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed += 50;
      this.paddleSpeedCost *= 2;
    }
  }

  upgradePointMultiplier() {
    if (this.score >= this.pointMultiplierCost) {
      this.score -= this.pointMultiplierCost;
      this.pointMultiplier += 1;
      this.pointMultiplierCost *= 2;
    }
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed += 50;
      this.ballSpeedCost *= 2;
    }
  }

  upgradeSpeedScaling() {
    if (this.score >= this.speedScalingCost) {
      this.score -= this.speedScalingCost;
      this.speedScaling += 0.1;
      this.speedScalingCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: cec5faf8-62a2-4cb7-82fb-c807a913a8e2
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} points)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Score: {game.score} | Ball Speed: {Math.floor(game.currentBallSpeed)} | Point Multiplier: {game.pointMultiplier}x</p>
    <p>Paddle Height: {game.paddleHeight} | Paddle Speed: {game.paddleSpeed} | Speed Scaling: {game.speedScaling.toFixed(2)}x</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradePaddleHeight()} cost={game.paddleHeightCost}>Upgrade Paddle Height</Button>
        <Button onClick={() => game.upgradePaddleSpeed()} cost={game.paddleSpeedCost}>Upgrade Paddle Speed</Button>
        <Button onClick={() => game.upgradePointMultiplier()} cost={game.pointMultiplierCost}>Upgrade Point Multiplier</Button>
        <Button onClick={() => game.upgradeBallSpeed()} cost={game.ballSpeedCost}>Upgrade Starting Ball Speed</Button>
        <Button onClick={() => game.upgradeSpeedScaling()} cost={game.speedScalingCost}>Upgrade Speed Scaling</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation follows all requirements from the overview document and includes:
- Automated paddle movement tracking the ball
- Ball physics with speed increases after each hit
- Point accumulation based on ball speed
- All 5 specified upgrades with doubling costs
- Game reset when ball is missed
- Clear UI showing game state and upgrade options

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
