Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Implementation Plan:
- The game is about mining crystals using drones, with various upgrades available
- We need to track upgrades for:
  * DRONE_COUNT
  * DRONE_SPEED
  * CARGO_CAPACITY 
  * MINING_SPEED
  * MAX_ASTEROIDS
  * ASTEROID_CAPACITY

- For the GameAI implementation:
  1. Import all upgrade types and costs from gameData.js
  2. getMainCurrency() will return game.crystals
  3. For experimental mode:
     - Set crystals to max
     - Randomly apply 0-10 upgrades of each type
  4. For updateGameStats:
     - Show crystals, drone count, mining speed, cargo capacity, max asteroids
  5. For checkCheapestUpgrade:
     - Compare costs of all upgrades
     - Buy cheapest one if enough crystals
  6. For performUpgrade:
     - Call appropriate game upgrade method based on type
     - Track upgrade level
     - Log upgrade info

Now let's implement the code:

# Excerpt ID: c863fc8a-5b7d-4a22-806a-168cbc6da1ef
```javascript src/GameAI.js
import { AIUtils } from './AIUtils';
import { UPGRADE_COSTS } from './game/gameData';

const UPGRADES = [
  'DRONE_COUNT',
  'DRONE_SPEED', 
  'CARGO_CAPACITY',
  'MINING_SPEED',
  'MAX_ASTEROIDS',
  'ASTEROID_CAPACITY'
];

export class GameAI {
  constructor() {
    this.ai = new AIUtils();
    this.game = null;
    this.initialized = false;
    // Initialize upgrade levels for all upgrade types
    this.upgradeLevels = UPGRADES.reduce((acc, upgrade) => {
      acc[upgrade] = 0;
      return acc;
    }, {});
  }

  init() {
    if (!window.game || !window.game.ready) {
      setTimeout(() => this.init(), 100);
      return;
    }
    this.game = window.game;

    if (this.initialized) return;
    this.initialized = true;

    window.game.app.ticker.speed = this.ai.defaultGameSpeed;
    this.ai.updateDebugOverlay('Game speed set to ' + this.ai.defaultGameSpeed + 'x');

    if (this.ai.enabled) {
      this.ai.gameStartTime = Date.now();

      if (this.ai.mode === 'experimental') {
        this.setupExperimentalMode();
      }

      this.ai.startLoggingLoop(this.getMainCurrency.bind(this));
      this.startUpgradeLoop();
      this.updateGameStats();

      setTimeout(() => {
        this.ai.stopAI();
        this.ai.exportLogs();
        this.ai.updateDebugOverlay('Session ended - logs exported');
      }, this.ai.duration);
    }
  }

  getMainCurrency() {
    return this.game.crystals;
  }

  setupExperimentalMode() {
    // Give infinite currency for experimental mode
    this.game.crystals = Number.MAX_SAFE_INTEGER;

    // Randomly upgrade each stat between 0-10 times
    UPGRADES.forEach(upgrade => {
      const times = Math.floor(Math.random() * 11); // 0 to 10
      for (let i = 0; i < times; i++) {
        this.performUpgrade(upgrade, 0, true);
      }
    });

    this.ai.updateDebugOverlay('Experimental mode initialized with random upgrades');
  }

  updateGameStats() {
    const stats = {
      Crystals: Math.floor(this.game.crystals),
      'Drone Count': this.game.droneCount,
      'Mining Speed': this.game.miningSpeed.toFixed(1) + 's',
      'Cargo Capacity': this.game.cargoCapacity,
      'Max Asteroids': this.game.maxAsteroids,
      'Asteroid Capacity': this.game.asteroidCapacity,
      'Drone Speed': Math.floor(this.game.droneSpeed)
    };

    this.ai.updateDebugOverlay('Game stats updated', stats);
  }

  startUpgradeLoop() {
    if (!this.ai.enabled || this.ai.mode === 'experimental') return;

    this.upgradeInterval = setInterval(() => {
      this.checkCheapestUpgrade();
      this.updateGameStats();
    }, 100);
  }

  checkCheapestUpgrade() {
    let cheapestUpgrade = null;
    let lowestCost = Infinity;

    for (const upgrade of UPGRADES) {
      const cost = this.game.upgradeCosts[upgrade];
      if (cost <= this.game.crystals && cost < lowestCost) {
        cheapestUpgrade = upgrade;
        lowestCost = cost;
      }
    }

    if (cheapestUpgrade) {
      this.performUpgrade(cheapestUpgrade, lowestCost);
    }
  }

  performUpgrade(upgradeName, cost, skipLogging = false) {
    // Increment the upgrade level before performing the upgrade
    this.upgradeLevels[upgradeName]++;
    const currentLevel = this.upgradeLevels[upgradeName];

    switch (upgradeName) {
      case 'DRONE_COUNT':
        this.game.upgradeDroneCount();
        break;
      case 'DRONE_SPEED':
        this.game.upgradeDroneSpeed();
        break;
      case 'CARGO_CAPACITY':
        this.game.upgradeCargoCapacity();
        break;
      case 'MINING_SPEED':
        this.game.upgradeMiningSpeed();
        break;
      case 'MAX_ASTEROIDS':
        this.game.upgradeMaxAsteroids();
        break;
      case 'ASTEROID_CAPACITY':
        this.game.upgradeAsteroidCapacity();
        break;
      default:
        console.error(`${upgradeName} is not a valid upgrade`);
    }

    if (!skipLogging) {
      const upgradeInfo = {
        timestamp: Date.now(),
        upgrade: upgradeName,
        cost: cost,
        level: currentLevel
      };

      this.ai.logUpgrade(upgradeInfo);
      this.ai.updateDebugOverlay(`Purchased ${upgradeName} upgrade for ${cost} (Level ${currentLevel})`);
    }
  }
}

const gameAI = new GameAI();
gameAI.init();

if (window.game) {
  window.game.exportAILogs = () => gameAI.ai.exportLogs();
  window.game.clearAILogs = () => gameAI.ai.clearLogs();
}

export default gameAI;
```

This implementation:
1. Imports necessary upgrade costs and defines all upgrade types
2. Tracks upgrade levels for each type
3. Implements experimental mode with random upgrades
4. Shows comprehensive game stats in the debug overlay
5. Automatically purchases the cheapest available upgrade in standard mode
6. Properly logs all upgrades and maintains game statistics
7. Handles all upgrade types through the performUpgrade method

The AI will continuously buy the cheapest available upgrade while tracking stats and logging progress. In experimental mode, it will randomly apply upgrades to test different configurations.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
