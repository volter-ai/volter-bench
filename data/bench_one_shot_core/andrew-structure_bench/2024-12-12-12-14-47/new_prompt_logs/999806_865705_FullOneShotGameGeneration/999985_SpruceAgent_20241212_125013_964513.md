Role: system
Content: You are an expert software developer. Your job is to make an existing simple UI look like the UI from an advanced video game
__________________
Role: user
Content: The existing codebase of the project is as follows:
```js src/Game.js
import React, { useRef, useState, useEffect } from 'react';
import { Settings } from 'lucide-react';
import { GameLogic } from './game/gameLogic';
import GameUI from './ui/GameUI';
import DebugUI from './ui/DebugUI';

const FRAME_RATE = 30;
const FRAME_INTERVAL = 1000 / FRAME_RATE;

const Game = () => {
  const containerRef = useRef(null);
  const gameRef = useRef(null);
  const [showDebugUI, setShowDebugUI] = useState(false);
  const [, setFrame] = useState(0);

  useEffect(() => {
    if (!containerRef.current) return;

    const game = new GameLogic(containerRef.current);
    window.game = game;
    gameRef.current = game;

    let lastTime = Date.now();
    let intervalId;
    const update = (currentTime) => {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // Force a re-render by updating the frame state
      setFrame(prevFrame => prevFrame + 1);
    };

    intervalId = setInterval(() => {
      update(Date.now());
    }, FRAME_INTERVAL);

    return () => {
      clearInterval(intervalId);
      if (gameRef.current) {
        gameRef.current.destroy();
        gameRef.current = null;
      }
      gameRef.current = null;
    };
  }, []);

  return (
    <div style={{
      position: 'relative',
      width: '800px',
      height: '600px',
      overflow: 'hidden'
    }}>
      <div ref={containerRef} style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%'
      }} />
      {gameRef.current && (
        <>
          <GameUI gameRef={gameRef} />
          {showDebugUI && <DebugUI gameRef={gameRef} />}
        </>
      )}
      <Settings
        onClick={() => setShowDebugUI(!showDebugUI)}
        style={{
          position: 'absolute',
          bottom: '10px',
          right: '10px',
          width: '24px',
          height: '24px',
          cursor: 'pointer',
          color: 'white'
        }}
      />
    </div>
  );
};

export default Game;
```
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAME_CONFIG } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;
    this.lastTimestamp = performance.now();
    
    // Game attributes
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.paddleSize = INITIAL_VALUES.PADDLE_SIZE;
    this.ballCount = INITIAL_VALUES.BALL_COUNT;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.pointsPerHit = INITIAL_VALUES.POINTS_PER_HIT;

    // Upgrade costs
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.paddleSizeCost = UPGRADE_COSTS.PADDLE_SIZE;
    this.ballCountCost = UPGRADE_COSTS.BALL_COUNT;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;
    this.pointsPerHitCost = UPGRADE_COSTS.POINTS_PER_HIT;

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(name) {
    const sprite = new PIXI.Sprite(PIXI.Loader.shared.resources[name].texture);
    sprite.width = SPRITES[name].width;
    sprite.height = SPRITES[name].height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite('background');
    
    // Create paddles
    this.leftPaddle = this.getSprite('paddle');
    this.rightPaddle = this.getSprite('paddle');
    
    this.leftPaddle.x = GAME_CONFIG.PADDLE_OFFSET;
    this.rightPaddle.x = SCREEN_SIZE.width - GAME_CONFIG.PADDLE_OFFSET;
    
    this.leftPaddle.y = SCREEN_SIZE.height / 2;
    this.rightPaddle.y = SCREEN_SIZE.height / 2;
    
    this.leftPaddle.anchor.set(0.5);
    this.rightPaddle.anchor.set(0.5);

    // Create balls container
    this.balls = new PIXI.Container();
    this.createBall();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.leftPaddle);
    this.app.stage.addChild(this.rightPaddle);
    this.app.stage.addChild(this.balls);
  }

  createBall() {
    const ball = this.getSprite('ball');
    ball.anchor.set(0.5);
    this.resetBall(ball);
    this.balls.addChild(ball);
  }

  resetBall(ball) {
    ball.x = SCREEN_SIZE.width / 2;
    ball.y = SCREEN_SIZE.height / 2;
    const angle = (Math.random() * Math.PI / 2) - Math.PI / 4;
    ball.dx = Math.cos(angle) * this.ballSpeed * (Math.random() < 0.5 ? 1 : -1);
    ball.dy = Math.sin(angle) * this.ballSpeed;
  }

  gameLoop(delta) {
    const currentTimestamp = performance.now();
    const elapsedSecs = (currentTimestamp - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTimestamp;

    // Update paddle sizes
    this.leftPaddle.height = this.paddleSize;
    this.rightPaddle.height = this.paddleSize;

    // AI paddle movement
    this.movePaddles(elapsedSecs);
    this.moveBalls(elapsedSecs);
  }

  movePaddles(elapsedSecs) {
    // Each paddle tracks the closest ball
    [this.leftPaddle, this.rightPaddle].forEach(paddle => {
      let closestBall = null;
      let closestDist = Infinity;
      
      this.balls.children.forEach(ball => {
        const dist = Math.abs(ball.x - paddle.x);
        if (dist < closestDist) {
          closestDist = dist;
          closestBall = ball;
        }
      });

      if (closestBall) {
        const targetY = closestBall.y;
        const dy = targetY - paddle.y;
        const movement = Math.min(Math.abs(dy), this.paddleSpeed * elapsedSecs) * Math.sign(dy);
        paddle.y += movement;
      }

      // Clamp paddle position
      paddle.y = Math.max(paddle.height/2, Math.min(SCREEN_SIZE.height - paddle.height/2, paddle.y));
    });
  }

  moveBalls(elapsedSecs) {
    this.balls.children.forEach(ball => {
      ball.x += ball.dx * elapsedSecs;
      ball.y += ball.dy * elapsedSecs;

      // Bounce off top/bottom
      if (ball.y < 0 || ball.y > SCREEN_SIZE.height) {
        ball.dy *= -1;
      }

      // Check paddle collisions
      [this.leftPaddle, this.rightPaddle].forEach(paddle => {
        if (this.checkPaddleCollision(ball, paddle)) {
          const paddleCenter = paddle.y;
          const relativeIntersectY = paddleCenter - ball.y;
          const normalizedIntersectY = relativeIntersectY / (paddle.height / 2);
          const bounceAngle = normalizedIntersectY * Math.PI / 4;
          
          const direction = paddle === this.leftPaddle ? 1 : -1;
          ball.dx = this.ballSpeed * Math.cos(bounceAngle) * direction;
          ball.dy = -this.ballSpeed * Math.sin(bounceAngle);
          
          this.score += this.pointsPerHit;
        }
      });

      // Reset ball if it goes past paddles
      if (ball.x < 0 || ball.x > SCREEN_SIZE.width) {
        this.resetBall(ball);
      }
    });
  }

  checkPaddleCollision(ball, paddle) {
    return ball.x + ball.width/2 > paddle.x - paddle.width/2 &&
           ball.x - ball.width/2 < paddle.x + paddle.width/2 &&
           ball.y + ball.height/2 > paddle.y - paddle.height/2 &&
           ball.y - ball.height/2 < paddle.y + paddle.height/2;
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed *= 1.1;
      this.ballSpeedCost *= 2;
    }
  }

  upgradePaddleSize() {
    if (this.score >= this.paddleSizeCost) {
      this.score -= this.paddleSizeCost;
      this.paddleSize *= 1.2;
      this.paddleSizeCost *= 2;
    }
  }

  addBall() {
    if (this.score >= this.ballCountCost) {
      this.score -= this.ballCountCost;
      this.ballCount++;
      this.createBall();
      this.ballCountCost *= 2;
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed *= 1.2;
      this.paddleSpeedCost *= 2;
    }
  }

  upgradePointsPerHit() {
    if (this.score >= this.pointsPerHitCost) {
      this.score -= this.pointsPerHitCost;
      this.pointsPerHit++;
      this.pointsPerHitCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}

```
```js src/game/gameData.js
export const INITIAL_VALUES = {
  BALL_SPEED: 200,
  PADDLE_SIZE: 100,
  BALL_COUNT: 1,
  PADDLE_SPEED: 300,
  POINTS_PER_HIT: 2  // Increased from 1 to 2
};

export const UPGRADE_COSTS = {
  BALL_SPEED: 3,     // Reduced from 5
  PADDLE_SIZE: 4,    // Reduced from 8
  BALL_COUNT: 10,    // Reduced from 25
  PADDLE_SPEED: 5,   // Reduced from 10
  POINTS_PER_HIT: 8  // Reduced from 15
};

export const GAME_CONFIG = {
  PADDLE_WIDTH: 20,
  BALL_SIZE: 16,
  PADDLE_OFFSET: 40
};

```
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  paddle: {
    path: 'assets/paddle.png',
    width: 20,
    height: 100
  },
  ball: {
    path: 'assets/ball.png',
    width: 16,
    height: 16
  }
};

```
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} points)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Score: {game.score} | Balls: {game.ballCount} | Ball Speed: {game.ballSpeed.toFixed(0)} | Paddle Size: {game.paddleSize.toFixed(0)} | Points/Hit: {game.pointsPerHit}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeBallSpeed()} cost={game.ballSpeedCost}>Upgrade Ball Speed</Button>
        <Button onClick={() => game.upgradePaddleSize()} cost={game.paddleSizeCost}>Upgrade Paddle Size</Button>
        <Button onClick={() => game.addBall()} cost={game.ballCountCost}>Add Ball</Button>
        <Button onClick={() => game.upgradePaddleSpeed()} cost={game.paddleSpeedCost}>Upgrade Paddle Speed</Button>
        <Button onClick={() => game.upgradePointsPerHit()} cost={game.pointsPerHitCost}>Upgrade Points Per Hit</Button>
      </div>
    </div>
  );
};

export default GameUI;

```
```js src/game/fontManifest.js
export const FONTS = [
  'Press Start 2P',
  'Roboto:400,700',
  'Orbitron:400,700',
]
```

Only make changes to the GameUI or fontManifest file. Don't change anything about the logic or functionality but make the UI look much better and make it feel like a very well implemented game. You can add multilayered menu interactions.


Make sure that only the essential data (such as currency) is shown in the hud and the other stats are hidden in a stats modal

Upgrades should be in modals and submenus instead of being directly on the screen


Make sure that the theme of your UI matches with the theme of the game

Make sure all modals can be opened and closed

General Implementation Guidelines:
1. Write out all the code of the files you intend to edit. I will be copy-pasting them
2. Do not create new files, add to the existing files in the appropriate locations
3. Do not do any refactoring outside of what you are requested to do

Directions:
In your response, do both steps, one after the other
1. First think carefully and describe in detail how you will implement the game design. Make sure to follow all the guidelines
2. Then write each file, according to the plan

Write out all the files in the format:
```filetype filepath
content
```

MOST IMPORTANT: Do not write "existing code here" or similar placeholders. If a file has been edited in anyway,
EVERY original unchanged line must be rewritten in your output
__________________
Role: assistant
Content: Let me plan out the UI improvements:

1. Theme Analysis:
- The game appears to be a Pong-style game with a dark background (0x222C37)
- Will use a futuristic/cyber theme with neon accents
- Primary color: #7C45CB (purple) - will keep this as the accent
- Secondary colors: Cyan (#00FFFF) for highlights, Dark blues for backgrounds

2. UI Structure:
- HUD: Minimal, showing only score and essential stats
- Main Menu Button: Top-right corner
- Settings Button: Bottom-right (existing)

3. Modal System:
- Create a reusable Modal component
- Modals will have a dark, semi-transparent backdrop
- Animated entrance/exit

4. Menu Structure:
a) Main Menu:
- Stats Overview
- Upgrades
- Settings

b) Upgrades Menu:
- Ball Upgrades
- Paddle Upgrades
- Points Upgrades

5. Visual Improvements:
- Glowing effects on buttons
- Cyber-style borders
- Animated highlights
- Progress bars for upgrades

Now, I'll implement these changes:

```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';
import { Settings, X, Activity, ChevronRight, Award, Circle, Square } from 'lucide-react';

const Modal = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) return null;
  
  return (
    <div className="modal-backdrop" 
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0,0,0,0.85)',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 1000,
      }}>
      <div className="modal-content" 
        style={{
          backgroundColor: '#1a1f2e',
          border: '2px solid #7C45CB',
          borderRadius: '8px',
          padding: '20px',
          width: '80%',
          maxWidth: '500px',
          maxHeight: '80%',
          overflow: 'auto',
          position: 'relative',
          boxShadow: '0 0 20px rgba(124, 69, 203, 0.3)',
        }}>
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '20px',
          borderBottom: '2px solid #7C45CB',
          paddingBottom: '10px'
        }}>
          <h2 style={{ margin: 0, color: '#00FFFF', fontFamily: 'Orbitron' }}>{title}</h2>
          <X 
            onClick={onClose}
            style={{ cursor: 'pointer', color: '#00FFFF' }}
          />
        </div>
        {children}
      </div>
    </div>
  );
};

const Button = ({ onClick, children, cost, disabled }) => (
  <button 
    onClick={onClick}
    disabled={disabled}
    style={{
      margin: '5px',
      padding: '10px 20px',
      fontSize: '14px',
      color: disabled ? '#666' : '#00FFFF',
      border: '2px solid',
      borderColor: disabled ? '#444' : '#7C45CB',
      cursor: disabled ? 'not-allowed' : 'pointer',
      backgroundColor: '#1a1f2e',
      borderRadius: '4px',
      fontFamily: 'Orbitron',
      transition: 'all 0.3s ease',
      boxShadow: disabled ? 'none' : '0 0 10px rgba(124, 69, 203, 0.3)',
      ':hover': {
        boxShadow: disabled ? 'none' : '0 0 15px rgba(124, 69, 203, 0.5)',
      }
    }}>
    {children} {cost && `(${cost} points)`}
  </button>
);

const HUD = ({ game }) => (
  <div style={{ 
    position: 'absolute', 
    top: '10px', 
    left: '50%', 
    transform: 'translateX(-50%)',
    padding: '10px 20px',
    backgroundColor: 'rgba(26, 31, 46, 0.9)',
    color: '#00FFFF',
    borderRadius: '20px',
    border: '2px solid #7C45CB',
    fontFamily: 'Orbitron',
    boxShadow: '0 0 15px rgba(124, 69, 203, 0.3)',
  }}>
    <p style={{ margin: 0 }}>Score: {game.score}</p>
  </div>
);

const MenuButton = ({ icon: Icon, onClick, style }) => (
  <div
    onClick={onClick}
    style={{
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      width: '40px',
      height: '40px',
      backgroundColor: '#1a1f2e',
      border: '2px solid #7C45CB',
      borderRadius: '50%',
      cursor: 'pointer',
      boxShadow: '0 0 10px rgba(124, 69, 203, 0.3)',
      ...style
    }}
  >
    <Icon size={24} color="#00FFFF" />
  </div>
);

const UpgradeSection = ({ title, children }) => (
  <div style={{
    marginBottom: '20px',
    padding: '15px',
    backgroundColor: 'rgba(124, 69, 203, 0.1)',
    borderRadius: '8px',
    border: '1px solid #7C45CB',
  }}>
    <h3 style={{ 
      color: '#00FFFF', 
      marginTop: 0,
      marginBottom: '10px',
      fontFamily: 'Orbitron'
    }}>{title}</h3>
    {children}
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  const [showMainMenu, setShowMainMenu] = useState(false);
  const [showUpgrades, setShowUpgrades] = useState(false);
  const [showStats, setShowStats] = useState(false);

  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      
      <MenuButton 
        icon={Activity}
        onClick={() => setShowMainMenu(true)}
        style={{
          position: 'absolute',
          top: '10px',
          right: '10px',
        }}
      />

      <Modal isOpen={showMainMenu} onClose={() => setShowMainMenu(false)} title="Main Menu">
        <Button onClick={() => setShowStats(true)}>Statistics <ChevronRight size={16} /></Button>
        <Button onClick={() => setShowUpgrades(true)}>Upgrades <ChevronRight size={16} /></Button>
      </Modal>

      <Modal isOpen={showStats} onClose={() => setShowStats(false)} title="Statistics">
        <div style={{ color: '#00FFFF', fontFamily: 'Orbitron' }}>
          <p>Balls: {game.ballCount}</p>
          <p>Ball Speed: {game.ballSpeed.toFixed(0)}</p>
          <p>Paddle Size: {game.paddleSize.toFixed(0)}</p>
          <p>Paddle Speed: {game.paddleSpeed.toFixed(0)}</p>
          <p>Points per Hit: {game.pointsPerHit}</p>
        </div>
      </Modal>

      <Modal isOpen={showUpgrades} onClose={() => setShowUpgrades(false)} title="Upgrades">
        <UpgradeSection title="Ball Upgrades">
          <Button onClick={() => game.upgradeBallSpeed()} cost={game.ballSpeedCost} disabled={game.score < game.ballSpeedCost}>
            Upgrade Ball Speed
          </Button>
          <Button onClick={() => game.addBall()} cost={game.ballCountCost} disabled={game.score < game.ballCountCost}>
            Add Ball
          </Button>
        </UpgradeSection>

        <UpgradeSection title="Paddle Upgrades">
          <Button onClick={() => game.upgradePaddleSize()} cost={game.paddleSizeCost} disabled={game.score < game.paddleSizeCost}>
            Upgrade Paddle Size
          </Button>
          <Button onClick={() => game.upgradePaddleSpeed()} cost={game.paddleSpeedCost} disabled={game.score < game.paddleSpeedCost}>
            Upgrade Paddle Speed
          </Button>
        </UpgradeSection>

        <UpgradeSection title="Point Upgrades">
          <Button onClick={() => game.upgradePointsPerHit()} cost={game.pointsPerHitCost} disabled={game.score < game.pointsPerHitCost}>
            Upgrade Points Per Hit
          </Button>
        </UpgradeSection>
      </Modal>
    </div>
  );
};

export default GameUI;
```

```js src/game/fontManifest.js
export const FONTS = [
  'Orbitron:400,700',
  'Press Start 2P',
  'Roboto:400,700',
]
```

These changes create a sleek, cyber-themed UI with proper menu organization and visual hierarchy. The HUD is minimal, showing only the score, while all other information is organized in modal menus.
__________________
