Role: system
Content: You are an expert software developer. Your job is to make an existing simple UI look like the UI from an advanced video game
__________________
Role: user
Content: The existing codebase of the project is as follows:
```js src/Game.js
import React, { useRef, useState, useEffect } from 'react';
import { Settings } from 'lucide-react';
import { GameLogic } from './game/gameLogic';
import GameUI from './ui/GameUI';
import DebugUI from './ui/DebugUI';

const FRAME_RATE = 30;
const FRAME_INTERVAL = 1000 / FRAME_RATE;

const Game = () => {
  const containerRef = useRef(null);
  const gameRef = useRef(null);
  const [showDebugUI, setShowDebugUI] = useState(false);
  const [, setFrame] = useState(0);

  useEffect(() => {
    if (!containerRef.current) return;

    const game = new GameLogic(containerRef.current);
    window.game = game;
    gameRef.current = game;

    let lastTime = Date.now();
    let intervalId;
    const update = (currentTime) => {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // Force a re-render by updating the frame state
      setFrame(prevFrame => prevFrame + 1);
    };

    intervalId = setInterval(() => {
      update(Date.now());
    }, FRAME_INTERVAL);

    return () => {
      clearInterval(intervalId);
      if (gameRef.current) {
        gameRef.current.destroy();
        gameRef.current = null;
      }
      gameRef.current = null;
    };
  }, []);

  return (
    <div style={{
      position: 'relative',
      width: '800px',
      height: '600px',
      overflow: 'hidden'
    }}>
      <div ref={containerRef} style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%'
      }} />
      {gameRef.current && (
        <>
          <GameUI gameRef={gameRef} />
          {showDebugUI && <DebugUI gameRef={gameRef} />}
        </>
      )}
      <Settings
        onClick={() => setShowDebugUI(!showDebugUI)}
        style={{
          position: 'absolute',
          bottom: '10px',
          right: '10px',
          width: '24px',
          height: '24px',
          cursor: 'pointer',
          color: 'white'
        }}
      />
    </div>
  );
};

export default Game;
```
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, ENEMY_CONFIG } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils';

const SCREEN_SIZE = {
  width: 800,
  height: 600
};

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.credits = 0;
    this.tankSpeed = INITIAL_VALUES.TANK_SPEED;
    this.tankHealth = INITIAL_VALUES.TANK_HEALTH;
    this.tankDamage = INITIAL_VALUES.TANK_DAMAGE;
    this.fireRate = INITIAL_VALUES.FIRE_RATE;
    this.detectionRange = INITIAL_VALUES.DETECTION_RANGE;
    this.tankCount = INITIAL_VALUES.TANK_COUNT;
    
    this.costs = {...UPGRADE_COSTS};
    this.enemySpawnTimer = 0;
    this.lastTimestamp = performance.now();

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.friendlyTanks = new PIXI.Container();
    this.enemyTanks = new PIXI.Container();
    this.bullets = new PIXI.Container();
    this.healthBars = new PIXI.Container();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.friendlyTanks);
    this.app.stage.addChild(this.enemyTanks);
    this.app.stage.addChild(this.bullets);
    this.app.stage.addChild(this.healthBars);

    for (let i = 0; i < this.tankCount; i++) {
      this.createFriendlyTank();
    }
  }

  createFriendlyTank() {
    const tank = this.getSprite(SPRITES.friendlyTank);
    tank.anchor.set(0.5);
    tank.x = Math.random() * (this.app.screen.width / 2);
    tank.y = Math.random() * this.app.screen.height;
    tank.health = this.tankHealth;
    tank.shootTimer = 0;
    tank.targetX = Math.random() * (this.app.screen.width / 2);
    tank.targetY = Math.random() * this.app.screen.height;
    this.friendlyTanks.addChild(tank);
  }

  createEnemyTank() {
    const tank = this.getSprite(SPRITES.enemyTank);
    tank.anchor.set(0.5);
    tank.x = this.app.screen.width;
    tank.y = Math.random() * this.app.screen.height;
    tank.health = ENEMY_CONFIG.HEALTH;
    tank.shootTimer = 0;
    
    const healthBar = new PIXI.Graphics();
    healthBar.tank = tank;
    this.healthBars.addChild(healthBar);
    tank.healthBar = healthBar;
    
    this.enemyTanks.addChild(tank);
  }

  createBullet(x, y, targetX, targetY, friendly) {
    const bullet = new PIXI.Graphics();
    bullet.beginFill(friendly ? 0x00ff00 : 0xff0000);
    bullet.drawCircle(0, 0, 3);
    bullet.endFill();
    bullet.x = x;
    bullet.y = y;
    
    const angle = Math.atan2(targetY - y, targetX - x);
    bullet.dx = Math.cos(angle) * INITIAL_VALUES.BULLET_SPEED;
    bullet.dy = Math.sin(angle) * INITIAL_VALUES.BULLET_SPEED;
    bullet.friendly = friendly;
    bullet.damage = friendly ? this.tankDamage : ENEMY_CONFIG.DAMAGE;
    
    this.bullets.addChild(bullet);
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    this.updateTanks(elapsedSecs);
    this.updateBullets(elapsedSecs);
    this.updateHealthBars();
    this.spawnEnemies(elapsedSecs);
  }

  updateTanks(elapsedSecs) {
    this.friendlyTanks.children.forEach(tank => {
      tank.shootTimer -= elapsedSecs;
      
      let nearestEnemy = null;
      let minDist = this.detectionRange;
      
      this.enemyTanks.children.forEach(enemy => {
        const dist = Math.hypot(enemy.x - tank.x, enemy.y - tank.y);
        if (dist < minDist) {
          minDist = dist;
          nearestEnemy = enemy;
        }
      });

      if (nearestEnemy) {
        tank.targetX = nearestEnemy.x;
        tank.targetY = nearestEnemy.y;
        
        if (tank.shootTimer <= 0) {
          this.createBullet(tank.x, tank.y, nearestEnemy.x, nearestEnemy.y, true);
          tank.shootTimer = 1 / this.fireRate;
        }
      } else if (Math.hypot(tank.targetX - tank.x, tank.targetY - tank.y) < 10) {
        tank.targetX = Math.random() * (this.app.screen.width / 2);
        tank.targetY = Math.random() * this.app.screen.height;
      }

      const angle = Math.atan2(tank.targetY - tank.y, tank.targetX - tank.x);
      tank.rotation = angle + Math.PI/2;
      
      const speed = nearestEnemy ? this.tankSpeed : this.tankSpeed * 0.5;
      tank.x += Math.cos(angle) * speed * elapsedSecs;
      tank.y += Math.sin(angle) * speed * elapsedSecs;
    });

    this.enemyTanks.children.forEach(tank => {
      tank.shootTimer -= elapsedSecs;
      
      const nearestFriendly = this.friendlyTanks.children[0];
      if (nearestFriendly) {
        const angle = Math.atan2(nearestFriendly.y - tank.y, nearestFriendly.x - tank.x);
        tank.rotation = angle + Math.PI/2;
        
        tank.x += Math.cos(angle) * ENEMY_CONFIG.SPEED * elapsedSecs;
        tank.y += Math.sin(angle) * ENEMY_CONFIG.SPEED * elapsedSecs;
        
        if (tank.shootTimer <= 0) {
          this.createBullet(tank.x, tank.y, nearestFriendly.x, nearestFriendly.y, false);
          tank.shootTimer = 1 / ENEMY_CONFIG.FIRE_RATE;
        }
      }
    });
  }

  updateBullets(elapsedSecs) {
    this.bullets.children.forEach(bullet => {
      bullet.x += bullet.dx * elapsedSecs;
      bullet.y += bullet.dy * elapsedSecs;
      
      if (bullet.x < 0 || bullet.x > this.app.screen.width || 
          bullet.y < 0 || bullet.y > this.app.screen.height) {
        this.bullets.removeChild(bullet);
        return;
      }

      const targets = bullet.friendly ? this.enemyTanks : this.friendlyTanks;
      targets.children.forEach(tank => {
        if (Math.hypot(tank.x - bullet.x, tank.y - bullet.y) < 32) {
          tank.health -= bullet.damage;
          this.bullets.removeChild(bullet);
          
          if (tank.health <= 0) {
            if (!bullet.friendly) {
              tank.health = this.tankHealth;
              tank.x = Math.random() * (this.app.screen.width / 2);
              tank.y = Math.random() * this.app.screen.height;
            } else {
              this.credits += INITIAL_VALUES.CREDITS_PER_KILL;
              this.enemyTanks.removeChild(tank);
              this.healthBars.removeChild(tank.healthBar);
            }
          }
        }
      });
    });
  }

  updateHealthBars() {
    this.healthBars.children.forEach(bar => {
      const tank = bar.tank;
      bar.clear();
      bar.beginFill(0xff0000);
      bar.drawRect(tank.x - 32, tank.y - 40, 64, 5);
      bar.beginFill(0x00ff00);
      bar.drawRect(tank.x - 32, tank.y - 40, 64 * (tank.health / ENEMY_CONFIG.HEALTH), 5);
    });
  }

  spawnEnemies(elapsedSecs) {
    this.enemySpawnTimer -= elapsedSecs;
    if (this.enemySpawnTimer <= 0) {
      this.createEnemyTank();
      this.enemySpawnTimer = INITIAL_VALUES.ENEMY_SPAWN_RATE;
    }
  }

  upgradeTankCount() {
    if (this.credits >= this.costs.TANK_COUNT) {
      this.credits -= this.costs.TANK_COUNT;
      this.tankCount++;
      this.createFriendlyTank();
      this.costs.TANK_COUNT *= 2;
    }
  }

  upgradeTankSpeed() {
    if (this.credits >= this.costs.TANK_SPEED) {
      this.credits -= this.costs.TANK_SPEED;
      this.tankSpeed *= 1.2;
      this.costs.TANK_SPEED *= 2;
    }
  }

  upgradeTankDamage() {
    if (this.credits >= this.costs.TANK_DAMAGE) {
      this.credits -= this.costs.TANK_DAMAGE;
      this.tankDamage *= 1.2;
      this.costs.TANK_DAMAGE *= 2;
    }
  }

  upgradeTankHealth() {
    if (this.credits >= this.costs.TANK_HEALTH) {
      this.credits -= this.costs.TANK_HEALTH;
      this.tankHealth *= 1.2;
      this.friendlyTanks.children.forEach(tank => {
        tank.health = this.tankHealth;
      });
      this.costs.TANK_HEALTH *= 2;
    }
  }

  upgradeFireRate() {
    if (this.credits >= this.costs.FIRE_RATE) {
      this.credits -= this.costs.FIRE_RATE;
      this.fireRate *= 1.2;
      this.costs.FIRE_RATE *= 2;
    }
  }

  upgradeDetectionRange() {
    if (this.credits >= this.costs.DETECTION_RANGE) {
      this.credits -= this.costs.DETECTION_RANGE;
      this.detectionRange *= 1.2;
      this.costs.DETECTION_RANGE *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}

```
```js src/game/gameData.js
export const INITIAL_VALUES = {
  TANK_SPEED: 100,  // pixels per second
  TANK_HEALTH: 100,
  TANK_DAMAGE: 20,
  FIRE_RATE: 1,     // shots per second
  DETECTION_RANGE: 200,
  TANK_COUNT: 1,
  ENEMY_SPAWN_RATE: 3, // seconds between spawns
  CREDITS_PER_KILL: 10,
  BULLET_SPEED: 300,
};

export const UPGRADE_COSTS = {
  TANK_COUNT: 100,
  TANK_SPEED: 50,
  TANK_DAMAGE: 75,
  TANK_HEALTH: 60,
  FIRE_RATE: 80,
  DETECTION_RANGE: 40,
};

export const ENEMY_CONFIG = {
  HEALTH: 50,
  SPEED: 80,
  DAMAGE: 15,
  FIRE_RATE: 0.8,
};

```
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  friendlyTank: {
    path: 'assets/friendly_tank.png',
    width: 64,
    height: 64
  },
  enemyTank: {
    path: 'assets/enemy_tank.png',
    width: 64,
    height: 64
  }
};

```
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
    position: 'relative',
  }}>
    {children} ({cost} credits)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Credits: {game.credits} | Tanks: {game.tankCount} | Damage: {Math.floor(game.tankDamage)} | Health: {Math.floor(game.tankHealth)} | Fire Rate: {game.fireRate.toFixed(1)} | Range: {Math.floor(game.detectionRange)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeTankCount()} cost={game.costs.TANK_COUNT}>Add Tank</Button>
        <Button onClick={() => game.upgradeTankSpeed()} cost={game.costs.TANK_SPEED}>Upgrade Speed</Button>
        <Button onClick={() => game.upgradeTankDamage()} cost={game.costs.TANK_DAMAGE}>Upgrade Damage</Button>
        <Button onClick={() => game.upgradeTankHealth()} cost={game.costs.TANK_HEALTH}>Upgrade Health</Button>
        <Button onClick={() => game.upgradeFireRate()} cost={game.costs.FIRE_RATE}>Upgrade Fire Rate</Button>
        <Button onClick={() => game.upgradeDetectionRange()} cost={game.costs.DETECTION_RANGE}>Upgrade Range</Button>
      </div>
    </div>
  );
};

export default GameUI;

```
```js src/game/fontManifest.js
export const FONTS = [
  'Press Start 2P',
  'Roboto:400,700',
  'Orbitron:400,700',
]
```

Only make changes to the GameUI or fontManifest file. Don't change anything about the logic or functionality but make the UI look much better and make it feel like a very well implemented game. You can add multilayered menu interactions.


Make sure that only the essential data (such as currency) is shown in the hud and the other stats are hidden in a stats modal

Upgrades should be in modals and submenus instead of being directly on the screen


Make sure that the theme of your UI matches with the theme of the game

Make sure all modals can be opened and closed

General Implementation Guidelines:
1. Write out all the code of the files you intend to edit. I will be copy-pasting them
2. Do not create new files, add to the existing files in the appropriate locations
3. Do not do any refactoring outside of what you are requested to do

Directions:
In your response, do both steps, one after the other
1. First think carefully and describe in detail how you will implement the game design. Make sure to follow all the guidelines
2. Then write each file, according to the plan

Write out all the files in the format:
```filetype filepath
content
```

MOST IMPORTANT: Do not write "existing code here" or similar placeholders. If a file has been edited in anyway,
EVERY original unchanged line must be rewritten in your output
__________________
Role: assistant
Content: Let me plan out the UI improvements first:

PLAN:
1. Theme: Since this is a tank battle game, we'll use a military/tech theme with:
   - Dark backgrounds (deep blues and grays)
   - Neon accents (cyan, green)
   - Angular, tech-inspired borders
   - Military-style fonts (Orbitron for headers, Roboto for body)

2. HUD Improvements:
   - Minimize HUD to show only credits and tank count
   - Add pulsing effects for important information
   - Use military-style iconography

3. Modal System:
   - Create a base Modal component
   - Stats Modal: Shows detailed tank statistics
   - Upgrade Modal: Categories for different upgrade types
   - Nested upgrade menus:
     * Offensive (Damage, Fire Rate)
     * Defensive (Health, Range)
     * Tactical (Tank Count, Speed)

4. Button Improvements:
   - Hexagonal or angular shapes
   - Hover effects with glow
   - Clear cost indicators
   - Disabled state when can't afford

Now, let's implement these changes:

```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';
import { Shield, Zap, Target, X, BarChart2, ChevronUp } from 'lucide-react';

const Modal = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) return null;
  
  return (
    <div style={{
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.7)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 1000
    }}>
      <div style={{
        backgroundColor: '#1a2634',
        border: '2px solid #30465c',
        borderRadius: '8px',
        padding: '20px',
        minWidth: '300px',
        position: 'relative',
        boxShadow: '0 0 20px rgba(0,149,255,0.15)'
      }}>
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '15px'
        }}>
          <h2 style={{
            margin: 0,
            fontFamily: 'Orbitron',
            color: '#00ff88',
            fontSize: '18px'
          }}>{title}</h2>
          <X
            onClick={onClose}
            style={{
              cursor: 'pointer',
              color: '#6c8aa3'
            }}
          />
        </div>
        {children}
      </div>
    </div>
  );
};

const Button = ({ onClick, children, cost, game, disabled }) => {
  const canAfford = game.credits >= cost;
  
  return (
    <button
      onClick={onClick}
      disabled={disabled || !canAfford}
      style={{
        margin: '5px',
        padding: '8px 15px',
        fontSize: '14px',
        color: canAfford ? '#d3d3d3' : '#666',
        border: 'none',
        cursor: canAfford ? 'pointer' : 'not-allowed',
        backgroundColor: canAfford ? '#1c3854' : '#1a2634',
        borderRadius: '4px',
        fontFamily: 'Roboto',
        transition: 'all 0.2s',
        position: 'relative',
        boxShadow: canAfford ? '0 0 10px rgba(0,149,255,0.15)' : 'none',
        ':hover': {
          backgroundColor: '#264666'
        }
      }}>
      {children}
      <div style={{
        fontSize: '12px',
        color: canAfford ? '#00ff88' : '#666'
      }}>
        {cost} credits
      </div>
    </button>
  );
};

const HUD = ({ game, onOpenStats, onOpenUpgrades }) => (
  <div style={{
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    padding: '15px',
    background: 'linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%)',
    color: '#d3d3d3',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    fontFamily: 'Orbitron'
  }}>
    <div style={{ display: 'flex', gap: '20px' }}>
      <div style={{ color: '#00ff88' }}>Credits: {game.credits}</div>
      <div>Tanks: {game.tankCount}</div>
    </div>
    <div style={{ display: 'flex', gap: '10px' }}>
      <button
        onClick={onOpenStats}
        style={{
          backgroundColor: 'transparent',
          border: '1px solid #30465c',
          borderRadius: '4px',
          padding: '5px 10px',
          color: '#6c8aa3',
          cursor: 'pointer',
          display: 'flex',
          alignItems: 'center',
          gap: '5px'
        }}
      >
        <BarChart2 size={16} /> Stats
      </button>
      <button
        onClick={onOpenUpgrades}
        style={{
          backgroundColor: '#1c3854',
          border: 'none',
          borderRadius: '4px',
          padding: '5px 10px',
          color: '#00ff88',
          cursor: 'pointer',
          display: 'flex',
          alignItems: 'center',
          gap: '5px'
        }}
      >
        <ChevronUp size={16} /> Upgrades
      </button>
    </div>
  </div>
);

const StatsModal = ({ isOpen, onClose, game }) => (
  <Modal isOpen={isOpen} onClose={onClose} title="Tank Statistics">
    <div style={{
      display: 'grid',
      gridTemplateColumns: '1fr 1fr',
      gap: '15px',
      color: '#d3d3d3',
      fontFamily: 'Roboto'
    }}>
      <div>Damage: {Math.floor(game.tankDamage)}</div>
      <div>Health: {Math.floor(game.tankHealth)}</div>
      <div>Fire Rate: {game.fireRate.toFixed(1)}/s</div>
      <div>Range: {Math.floor(game.detectionRange)}</div>
      <div>Speed: {Math.floor(game.tankSpeed)}</div>
      <div>Tank Count: {game.tankCount}</div>
    </div>
  </Modal>
);

const UpgradeModal = ({ isOpen, onClose, game }) => {
  const [category, setCategory] = useState(null);
  
  const categories = {
    offensive: {
      icon: <Zap />,
      title: "Offensive",
      upgrades: [
        { name: "Damage", action: () => game.upgradeTankDamage(), cost: game.costs.TANK_DAMAGE },
        { name: "Fire Rate", action: () => game.upgradeFireRate(), cost: game.costs.FIRE_RATE }
      ]
    },
    defensive: {
      icon: <Shield />,
      title: "Defensive",
      upgrades: [
        { name: "Health", action: () => game.upgradeTankHealth(), cost: game.costs.TANK_HEALTH },
        { name: "Range", action: () => game.upgradeDetectionRange(), cost: game.costs.DETECTION_RANGE }
      ]
    },
    tactical: {
      icon: <Target />,
      title: "Tactical",
      upgrades: [
        { name: "Add Tank", action: () => game.upgradeTankCount(), cost: game.costs.TANK_COUNT },
        { name: "Speed", action: () => game.upgradeTankSpeed(), cost: game.costs.TANK_SPEED }
      ]
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Upgrades">
      {!category ? (
        <div style={{
          display: 'grid',
          gridTemplateColumns: '1fr 1fr 1fr',
          gap: '10px'
        }}>
          {Object.entries(categories).map(([key, cat]) => (
            <button
              key={key}
              onClick={() => setCategory(key)}
              style={{
                padding: '15px',
                backgroundColor: '#1c3854',
                border: 'none',
                borderRadius: '4px',
                color: '#00ff88',
                cursor: 'pointer',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                gap: '10px'
              }}
            >
              {cat.icon}
              {cat.title}
            </button>
          ))}
        </div>
      ) : (
        <div>
          <button
            onClick={() => setCategory(null)}
            style={{
              backgroundColor: 'transparent',
              border: 'none',
              color: '#6c8aa3',
              cursor: 'pointer',
              marginBottom: '15px'
            }}
          >
            ← Back
          </button>
          <div style={{
            display: 'flex',
            flexDirection: 'column',
            gap: '10px'
          }}>
            {categories[category].upgrades.map((upgrade, index) => (
              <Button
                key={index}
                onClick={upgrade.action}
                cost={upgrade.cost}
                game={game}
              >
                {upgrade.name}
              </Button>
            ))}
          </div>
        </div>
      )}
    </Modal>
  );
};

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  const [showStats, setShowStats] = useState(false);
  const [showUpgrades, setShowUpgrades] = useState(false);

  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD
        game={game}
        onOpenStats={() => setShowStats(true)}
        onOpenUpgrades={() => setShowUpgrades(true)}
      />
      <StatsModal
        isOpen={showStats}
        onClose={() => setShowStats(false)}
        game={game}
      />
      <UpgradeModal
        isOpen={showUpgrades}
        onClose={() => setShowUpgrades(false)}
        game={game}
      />
    </div>
  );
};

export default GameUI;
```

```js src/game/fontManifest.js
export const FONTS = [
  'Orbitron:400,700',
  'Roboto:400,700'
];
```

These changes create a much more polished, game-like UI with:
1. A minimal HUD showing only essential information
2. A dedicated stats screen
3. A categorized upgrade system
4. Military/tech visual theme
5. Improved button and modal designs
6. Better typography with gaming-appropriate fonts
7. Visual feedback for affordability of upgrades
8. Proper modal system with transitions
__________________
