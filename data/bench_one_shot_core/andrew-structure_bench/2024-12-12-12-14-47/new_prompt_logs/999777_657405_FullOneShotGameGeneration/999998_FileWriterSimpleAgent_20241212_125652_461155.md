Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Implementation Plan:
- The game is a tank battle where we can upgrade various tank attributes
- From gameData.js, we can see the upgradeable attributes are:
  * TANK_COUNT
  * TANK_SPEED
  * TANK_DAMAGE
  * TANK_HEALTH
  * FIRE_RATE
  * DETECTION_RANGE

- We need to:
  1. Define UPGRADES array with all possible upgrades
  2. Implement getMainCurrency() to return game.credits
  3. In setupExperimentalMode(), set infinite credits
  4. In updateGameStats(), show all relevant game stats (credits, tank stats)
  5. In checkCheapestUpgrade(), check costs of all upgrades and buy cheapest affordable one
  6. In performUpgrade(), implement switch case for each upgrade type

2. Implementation:

# Excerpt ID: 609a14ae-43a6-41ab-a73c-cf3a05762697
```javascript src/GameAI.js
import { AIUtils } from './AIUtils';
import { INITIAL_VALUES, UPGRADE_COSTS, ENEMY_CONFIG } from './game/gameData';

const UPGRADES = [
  'TANK_COUNT',
  'TANK_SPEED', 
  'TANK_DAMAGE',
  'TANK_HEALTH',
  'FIRE_RATE',
  'DETECTION_RANGE'
];

export class GameAI {
  constructor() {
    this.ai = new AIUtils();
    this.game = null;
    this.initialized = false;
    // Initialize upgrade levels for all upgrade types
    this.upgradeLevels = UPGRADES.reduce((acc, upgrade) => {
      acc[upgrade] = 0;
      return acc;
    }, {});
  }

  init() {
    if (!window.game || !window.game.ready) {
      setTimeout(() => this.init(), 100);
      return;
    }
    this.game = window.game;

    if (this.initialized) return;
    this.initialized = true;

    window.game.app.ticker.speed = this.ai.defaultGameSpeed;
    this.ai.updateDebugOverlay('Game speed set to ' + this.ai.defaultGameSpeed + 'x');

    if (this.ai.enabled) {
      this.ai.gameStartTime = Date.now();

      if (this.ai.mode === 'experimental') {
        this.setupExperimentalMode();
      }

      this.ai.startLoggingLoop(this.getMainCurrency.bind(this));
      this.startUpgradeLoop();
      this.updateGameStats();

      setTimeout(() => {
        this.ai.stopAI();
        this.ai.exportLogs();
        this.ai.updateDebugOverlay('Session ended - logs exported');
      }, this.ai.duration);
    }
  }

  getMainCurrency() {
    return this.game.credits;
  }

  setupExperimentalMode() {
    // Give infinite currency for experimental mode
    this.game.credits = Number.MAX_SAFE_INTEGER;

    // Randomly upgrade each stat between 0-10 times
    UPGRADES.forEach(upgrade => {
      const times = Math.floor(Math.random() * 11); // 0 to 10
      for (let i = 0; i < times; i++) {
        this.performUpgrade(upgrade, 0, true);
      }
    });

    this.ai.updateDebugOverlay('Experimental mode initialized with random upgrades');
  }

  updateGameStats() {
    const stats = {
      Credits: this.game.credits,
      'Tank Count': this.game.tankCount,
      'Tank Speed': Math.floor(this.game.tankSpeed),
      'Tank Damage': Math.floor(this.game.tankDamage),
      'Tank Health': Math.floor(this.game.tankHealth),
      'Fire Rate': this.game.fireRate.toFixed(1),
      'Detection Range': Math.floor(this.game.detectionRange)
    };

    this.ai.updateDebugOverlay('Game stats updated', stats);
  }

  startUpgradeLoop() {
    if (!this.ai.enabled || this.ai.mode === 'experimental') return;

    this.upgradeInterval = setInterval(() => {
      this.checkCheapestUpgrade();
      this.updateGameStats();
    }, 100);
  }

  checkCheapestUpgrade() {
    let cheapestUpgrade = null;
    let lowestCost = Infinity;

    for (const upgrade of UPGRADES) {
      const cost = this.game.costs[upgrade];
      if (cost <= this.game.credits && cost < lowestCost) {
        cheapestUpgrade = upgrade;
        lowestCost = cost;
      }
    }

    if (cheapestUpgrade) {
      this.performUpgrade(cheapestUpgrade, lowestCost);
    }
  }

  performUpgrade(upgradeName, cost, skipLogging = false) {
    // Increment the upgrade level before performing the upgrade
    this.upgradeLevels[upgradeName]++;
    const currentLevel = this.upgradeLevels[upgradeName];

    switch (upgradeName) {
      case 'TANK_COUNT':
        this.game.upgradeTankCount();
        break;
      case 'TANK_SPEED':
        this.game.upgradeTankSpeed();
        break;
      case 'TANK_DAMAGE':
        this.game.upgradeTankDamage();
        break;
      case 'TANK_HEALTH':
        this.game.upgradeTankHealth();
        break;
      case 'FIRE_RATE':
        this.game.upgradeFireRate();
        break;
      case 'DETECTION_RANGE':
        this.game.upgradeDetectionRange();
        break;
      default:
        console.error(`${upgradeName} is not a valid upgrade`);
    }

    if (!skipLogging) {
      const upgradeInfo = {
        timestamp: Date.now(),
        upgrade: upgradeName,
        cost: cost,
        level: currentLevel
      };

      this.ai.logUpgrade(upgradeInfo);
      this.ai.updateDebugOverlay(`Purchased ${upgradeName} upgrade for ${cost} (Level ${currentLevel})`);
    }
  }
}

const gameAI = new GameAI();
gameAI.init();

if (window.game) {
  window.game.exportAILogs = () => gameAI.ai.exportLogs();
  window.game.clearAILogs = () => gameAI.ai.clearLogs();
}

export default gameAI;
```

The implementation:
1. Defines UPGRADES array with all possible upgrades from gameData.js
2. getMainCurrency() returns game.credits which is the main currency
3. setupExperimentalMode() sets infinite credits and randomly upgrades each stat
4. updateGameStats() shows all relevant game stats including credits and tank attributes
5. checkCheapestUpgrade() loops through all upgrades to find cheapest affordable one
6. performUpgrade() implements all upgrade types by calling corresponding game methods

The AI will automatically buy the cheapest available upgrade in normal mode, or randomly upgrade in experimental mode. It logs all actions and maintains stats in the debug overlay.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
