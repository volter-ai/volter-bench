Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Implementation Plan:
- The game is a tank defense game where you upgrade various tank attributes
- Main currency is "credits" earned from killing enemies
- Need to track upgrades for: TANK_SPEED, TANK_HEALTH, TANK_DAMAGE, TANK_FIRE_RATE, TANK_RANGE, TANK_COUNT
- For experimental mode:
  * Set credits to max value
  * Randomly apply 0-10 upgrades for each upgrade type
- For standard mode:
  * Check costs of all possible upgrades
  * Buy the cheapest one available
- Need to track stats like:
  * Current credits
  * Number of tanks
  * Tank speed, health, damage, fire rate, range
  * Current upgrade costs
- Will use the AIUtils for:
  * Logging upgrades and currency over time
  * Displaying debug overlay
  * Managing experimental vs standard modes
  * Controlling game speed

2. Here's the implementation:

# Excerpt ID: 73eb6ea7-496a-4ead-b328-c7a48f8aa60d
```javascript src/GameAI.js
import { AIUtils } from './AIUtils';
import { INITIAL_VALUES, UPGRADE_COSTS } from './game/gameData';

const UPGRADES = [
  'TANK_SPEED',
  'TANK_HEALTH', 
  'TANK_DAMAGE',
  'TANK_FIRE_RATE',
  'TANK_RANGE',
  'TANK_COUNT'
];

export class GameAI {
  constructor() {
    this.ai = new AIUtils();
    this.game = null;
    this.initialized = false;
    // Initialize upgrade levels for all upgrade types
    this.upgradeLevels = UPGRADES.reduce((acc, upgrade) => {
      acc[upgrade] = 0;
      return acc;
    }, {});
  }

  init() {
    if (!window.game || !window.game.ready) {
      setTimeout(() => this.init(), 100);
      return;
    }
    this.game = window.game;

    if (this.initialized) return;
    this.initialized = true;

    window.game.app.ticker.speed = this.ai.defaultGameSpeed;
    this.ai.updateDebugOverlay('Game speed set to ' + this.ai.defaultGameSpeed + 'x');

    if (this.ai.enabled) {
      this.ai.gameStartTime = Date.now();

      if (this.ai.mode === 'experimental') {
        this.setupExperimentalMode();
      }

      this.ai.startLoggingLoop(this.getMainCurrency.bind(this));
      this.startUpgradeLoop();
      this.updateGameStats();

      setTimeout(() => {
        this.ai.stopAI();
        this.ai.exportLogs();
        this.ai.updateDebugOverlay('Session ended - logs exported');
      }, this.ai.duration);
    }
  }

  getMainCurrency() {
    return this.game.credits;
  }

  setupExperimentalMode() {
    // Give infinite currency for experimental mode
    this.game.credits = Number.MAX_SAFE_INTEGER;

    // Randomly upgrade each stat between 0-10 times
    UPGRADES.forEach(upgrade => {
      const times = Math.floor(Math.random() * 11); // 0 to 10
      for (let i = 0; i < times; i++) {
        this.performUpgrade(upgrade, 0, true);
      }
    });

    this.ai.updateDebugOverlay('Experimental mode initialized with random upgrades');
  }

  updateGameStats() {
    const stats = {
      Credits: this.game.credits,
      'Tank Count': this.game.tankCount,
      'Tank Speed': this.game.tankSpeed.toFixed(1),
      'Tank Health': this.game.tankHealth.toFixed(0),
      'Tank Damage': this.game.tankDamage.toFixed(1),
      'Fire Rate': this.game.tankFireRate.toFixed(1),
      'Tank Range': this.game.tankRange.toFixed(0),
      'Speed Cost': this.game.costs.TANK_SPEED,
      'Health Cost': this.game.costs.TANK_HEALTH,
      'Damage Cost': this.game.costs.TANK_DAMAGE,
      'Fire Rate Cost': this.game.costs.TANK_FIRE_RATE,
      'Range Cost': this.game.costs.TANK_RANGE,
      'Tank Count Cost': this.game.costs.TANK_COUNT
    };

    this.ai.updateDebugOverlay('Game stats updated', stats);
  }

  startUpgradeLoop() {
    if (!this.ai.enabled || this.ai.mode === 'experimental') return;

    this.upgradeInterval = setInterval(() => {
      this.checkCheapestUpgrade();
      this.updateGameStats();
    }, 100);
  }

  checkCheapestUpgrade() {
    let cheapestUpgrade = null;
    let lowestCost = Infinity;

    for (const upgrade of UPGRADES) {
      const cost = this.game.costs[upgrade];
      if (cost <= this.game.credits && cost < lowestCost) {
        cheapestUpgrade = upgrade;
        lowestCost = cost;
      }
    }

    if (cheapestUpgrade) {
      this.performUpgrade(cheapestUpgrade, lowestCost);
    }
  }

  performUpgrade(upgradeName, cost, skipLogging = false) {
    // Increment the upgrade level before performing the upgrade
    this.upgradeLevels[upgradeName]++;
    const currentLevel = this.upgradeLevels[upgradeName];

    switch (upgradeName) {
      case 'TANK_SPEED':
        this.game.upgradeTankSpeed();
        break;
      case 'TANK_HEALTH':
        this.game.upgradeTankHealth();
        break;
      case 'TANK_DAMAGE':
        this.game.upgradeTankDamage();
        break;
      case 'TANK_FIRE_RATE':
        this.game.upgradeFireRate();
        break;
      case 'TANK_RANGE':
        this.game.upgradeRange();
        break;
      case 'TANK_COUNT':
        this.game.upgradeTankCount();
        break;
      default:
        console.error(`${upgradeName} is not a valid upgrade`);
    }

    if (!skipLogging) {
      const upgradeInfo = {
        timestamp: Date.now(),
        upgrade: upgradeName,
        cost: cost,
        level: currentLevel
      };

      this.ai.logUpgrade(upgradeInfo);
      this.ai.updateDebugOverlay(`Purchased ${upgradeName} upgrade for ${cost} (Level ${currentLevel})`);
    }
  }
}

const gameAI = new GameAI();
gameAI.init();

if (window.game) {
  window.game.exportAILogs = () => gameAI.ai.exportLogs();
  window.game.clearAILogs = () => gameAI.ai.clearLogs();
}

export default gameAI;
```

This implementation:
1. Defines all possible upgrades
2. Tracks upgrade levels
3. Implements experimental mode with random upgrades
4. Implements standard mode that buys cheapest available upgrade
5. Tracks and displays all relevant game stats
6. Uses AIUtils for logging and debug display
7. Properly handles both game modes
8. Maintains upgrade history and logging

The AI will continuously buy the cheapest available upgrade in standard mode, while experimental mode will randomly apply upgrades to see how different combinations affect gameplay.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
