Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data Requirements:
- Initial values for tank attributes (damage, speed, fire rate, etc)
- Base upgrade costs and multipliers
- Screen dimensions and gameplay constants

2. Asset Requirements:
- Tank sprite
- Base sprite
- Projectile (can be drawn with PIXI.Graphics)
- Health bar (PIXI.Graphics)
- Background

3. Game Logic Implementation:
- Track tanks, bases, and projectiles in separate PIXI.Containers
- Tank spawning system with timer
- Base spawning system
- Movement system for tanks and projectiles
- Collision detection between projectiles and bases
- Health system for bases
- Coin reward system
- Upgrade system with costs doubling

4. UI Requirements:
- Display current coins
- Show upgrade buttons with costs
- Display current stats

Now, I'll implement each file:

# Excerpt ID: 19f85753-1b5b-4425-97d9-c8eb788c2d6a
```js src/game/gameData.js
export const INITIAL_VALUES = {
  TANK_DAMAGE: 10,
  TANK_SPEED: 100,
  TANK_FIRE_RATE: 1,
  MAX_TANKS: 3,
  MULTI_SHOT: 1,
  BASE_COIN_VALUE: 10,
  BASE_HEALTH: 100,
  TANK_SPAWN_RATE: 3,
  BASE_SPAWN_DELAY: 2,
  FIRING_RANGE: 200,
};

export const UPGRADE_COSTS = {
  TANK_DAMAGE: 10,
  TANK_SPEED: 15,
  TANK_FIRE_RATE: 20,
  MAX_TANKS: 50,
  MULTI_SHOT: 100,
  BASE_COIN_VALUE: 25,
};

export const GAMEPLAY_CONSTANTS = {
  PROJECTILE_SPEED: 300,
};
```

# Excerpt ID: b7f4e8f7-8146-4b29-8eb8-cc30ebf624bf
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  tank: {
    path: 'assets/tank.png',
    width: 64,
    height: 64
  },
  base: {
    path: 'assets/base.png',
    width: 64,
    height: 64
  }
};
```

# Excerpt ID: 07853d33-d386-4ea8-a47d-e53d38361dc8
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAMEPLAY_CONSTANTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.coins = 0;
    this.tankDamage = INITIAL_VALUES.TANK_DAMAGE;
    this.tankSpeed = INITIAL_VALUES.TANK_SPEED;
    this.tankFireRate = INITIAL_VALUES.TANK_FIRE_RATE;
    this.maxTanks = INITIAL_VALUES.MAX_TANKS;
    this.multiShot = INITIAL_VALUES.MULTI_SHOT;
    this.baseCoinValue = INITIAL_VALUES.BASE_COIN_VALUE;
    
    this.tankSpawnTimer = 0;
    this.lastTimestamp = performance.now();

    this.upgradeCosts = {...UPGRADE_COSTS};

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.tanks = new PIXI.Container();
    this.bases = new PIXI.Container();
    this.projectiles = new PIXI.Container();
    this.effects = new PIXI.Container();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.tanks);
    this.app.stage.addChild(this.bases);
    this.app.stage.addChild(this.projectiles);
    this.app.stage.addChild(this.effects);

    this.spawnBase();
  }

  createTank() {
    if (this.tanks.children.length >= this.maxTanks) return;
    
    const tank = this.getSprite(SPRITES.tank);
    tank.anchor.set(0.5);
    tank.x = 50;
    tank.y = Math.random() * (this.app.screen.height - 100) + 50;
    tank.fireTimer = 0;
    this.tanks.addChild(tank);
  }

  spawnBase() {
    const base = this.getSprite(SPRITES.base);
    base.anchor.set(0.5);
    base.x = this.app.screen.width - 50;
    base.y = Math.random() * (this.app.screen.height - 100) + 50;
    base.health = INITIAL_VALUES.BASE_HEALTH;
    base.maxHealth = INITIAL_VALUES.BASE_HEALTH;

    const healthBar = new PIXI.Graphics();
    base.healthBar = healthBar;
    healthBar.y = -40;
    base.addChild(healthBar);
    this.updateHealthBar(base);

    this.bases.addChild(base);
  }

  createProjectile(tank, target) {
    const projectile = new PIXI.Graphics();
    projectile.beginFill(0xff0000);
    projectile.drawCircle(0, 0, 4);
    projectile.endFill();
    projectile.x = tank.x;
    projectile.y = tank.y;
    
    const angle = Math.atan2(target.y - tank.y, target.x - tank.x);
    projectile.dx = Math.cos(angle) * GAMEPLAY_CONSTANTS.PROJECTILE_SPEED;
    projectile.dy = Math.sin(angle) * GAMEPLAY_CONSTANTS.PROJECTILE_SPEED;
    projectile.damage = this.tankDamage;
    
    this.projectiles.addChild(projectile);
  }

  updateHealthBar(base) {
    const healthBar = base.healthBar;
    healthBar.clear();
    healthBar.beginFill(0xff0000);
    healthBar.drawRect(-30, 0, 60, 5);
    healthBar.beginFill(0x00ff00);
    healthBar.drawRect(-30, 0, (base.health / base.maxHealth) * 60, 5);
    healthBar.endFill();
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    this.tankSpawnTimer += elapsedSecs;
    if (this.tankSpawnTimer >= INITIAL_VALUES.TANK_SPAWN_RATE) {
      this.createTank();
      this.tankSpawnTimer = 0;
    }

    // Update tanks
    this.tanks.children.forEach(tank => {
      const nearestBase = this.bases.children[0];
      if (!nearestBase) return;

      const dx = nearestBase.x - tank.x;
      const dy = nearestBase.y - tank.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance > INITIAL_VALUES.FIRING_RANGE) {
        tank.x += (this.tankSpeed * elapsedSecs * dx) / distance;
        tank.y += (this.tankSpeed * elapsedSecs * dy) / distance;
      } else {
        tank.fireTimer += elapsedSecs;
        if (tank.fireTimer >= 1 / this.tankFireRate) {
          this.createProjectile(tank, nearestBase);
          tank.fireTimer = 0;
        }
      }
    });

    // Update projectiles
    this.projectiles.children.forEach(projectile => {
      projectile.x += projectile.dx * elapsedSecs;
      projectile.y += projectile.dy * elapsedSecs;

      if (projectile.x < 0 || projectile.x > this.app.screen.width ||
          projectile.y < 0 || projectile.y > this.app.screen.height) {
        this.projectiles.removeChild(projectile);
      }
    });

    // Check collisions
    this.projectiles.children.forEach(projectile => {
      let hitCount = 0;
      this.bases.children.forEach(base => {
        const dx = projectile.x - base.x;
        const dy = projectile.y - base.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < 32 && hitCount < this.multiShot) {
          base.health -= projectile.damage;
          this.updateHealthBar(base);
          hitCount++;

          if (base.health <= 0) {
            this.coins += this.baseCoinValue;
            this.bases.removeChild(base);
            setTimeout(() => this.spawnBase(), INITIAL_VALUES.BASE_SPAWN_DELAY * 1000);
          }
        }
      });
      if (hitCount > 0) {
        this.projectiles.removeChild(projectile);
      }
    });
  }

  upgradeTankDamage() {
    if (this.coins >= this.upgradeCosts.TANK_DAMAGE) {
      this.coins -= this.upgradeCosts.TANK_DAMAGE;
      this.tankDamage *= 1.2;
      this.upgradeCosts.TANK_DAMAGE *= 2;
    }
  }

  upgradeTankSpeed() {
    if (this.coins >= this.upgradeCosts.TANK_SPEED) {
      this.coins -= this.upgradeCosts.TANK_SPEED;
      this.tankSpeed *= 1.2;
      this.upgradeCosts.TANK_SPEED *= 2;
    }
  }

  upgradeTankFireRate() {
    if (this.coins >= this.upgradeCosts.TANK_FIRE_RATE) {
      this.coins -= this.upgradeCosts.TANK_FIRE_RATE;
      this.tankFireRate *= 1.2;
      this.upgradeCosts.TANK_FIRE_RATE *= 2;
    }
  }

  upgradeMaxTanks() {
    if (this.coins >= this.upgradeCosts.MAX_TANKS) {
      this.coins -= this.upgradeCosts.MAX_TANKS;
      this.maxTanks += 1;
      this.upgradeCosts.MAX_TANKS *= 2;
    }
  }

  upgradeMultiShot() {
    if (this.coins >= this.upgradeCosts.MULTI_SHOT) {
      this.coins -= this.upgradeCosts.MULTI_SHOT;
      this.multiShot += 1;
      this.upgradeCosts.MULTI_SHOT *= 2;
    }
  }

  upgradeBaseCoinValue() {
    if (this.coins >= this.upgradeCosts.BASE_COIN_VALUE) {
      this.coins -= this.upgradeCosts.BASE_COIN_VALUE;
      this.baseCoinValue *= 1.5;
      this.upgradeCosts.BASE_COIN_VALUE *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: 359f8f8b-9615-4984-83a5-0f2f400ffde3
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} coins)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Coins: {Math.floor(game.coins)} | Tanks: {game.tanks.children.length}/{game.maxTanks} | Damage: {game.tankDamage.toFixed(1)} | Fire Rate: {game.tankFireRate.toFixed(1)} | Multi-shot: {game.multiShot}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeTankDamage()} cost={game.upgradeCosts.TANK_DAMAGE}>Upgrade Damage</Button>
        <Button onClick={() => game.upgradeTankSpeed()} cost={game.upgradeCosts.TANK_SPEED}>Upgrade Speed</Button>
        <Button onClick={() => game.upgradeTankFireRate()} cost={game.upgradeCosts.TANK_FIRE_RATE}>Upgrade Fire Rate</Button>
        <Button onClick={() => game.upgradeMaxTanks()} cost={game.upgradeCosts.MAX_TANKS}>Increase Max Tanks</Button>
        <Button onClick={() => game.upgradeMultiShot()} cost={game.upgradeCosts.MULTI_SHOT}>Upgrade Multi-shot</Button>
        <Button onClick={() => game.upgradeBaseCoinValue()} cost={game.upgradeCosts.BASE_COIN_VALUE}>Upgrade Coin Value</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the features described in the overview:
1. Auto-playing tanks that spawn and attack bases
2. Upgrade system with doubling costs
3. Coin rewards for destroying bases
4. Tank movement and targeting system
5. Health bars for bases
6. All six specified upgrades
7. Proper timing system using elapsed seconds
8. Sprite-based rendering with appropriate sizes

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
