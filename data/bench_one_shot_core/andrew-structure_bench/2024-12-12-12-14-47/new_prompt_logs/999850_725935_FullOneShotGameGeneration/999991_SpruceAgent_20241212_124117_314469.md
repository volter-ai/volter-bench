Role: system
Content: You are an expert software developer. Your job is to make an existing simple UI look like the UI from an advanced video game
__________________
Role: user
Content: The existing codebase of the project is as follows:
```js src/Game.js
import React, { useRef, useState, useEffect } from 'react';
import { Settings } from 'lucide-react';
import { GameLogic } from './game/gameLogic';
import GameUI from './ui/GameUI';
import DebugUI from './ui/DebugUI';

const FRAME_RATE = 30;
const FRAME_INTERVAL = 1000 / FRAME_RATE;

const Game = () => {
  const containerRef = useRef(null);
  const gameRef = useRef(null);
  const [showDebugUI, setShowDebugUI] = useState(false);
  const [, setFrame] = useState(0);

  useEffect(() => {
    if (!containerRef.current) return;

    const game = new GameLogic(containerRef.current);
    window.game = game;
    gameRef.current = game;

    let lastTime = Date.now();
    let intervalId;
    const update = (currentTime) => {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // Force a re-render by updating the frame state
      setFrame(prevFrame => prevFrame + 1);
    };

    intervalId = setInterval(() => {
      update(Date.now());
    }, FRAME_INTERVAL);

    return () => {
      clearInterval(intervalId);
      if (gameRef.current) {
        gameRef.current.destroy();
        gameRef.current = null;
      }
      gameRef.current = null;
    };
  }, []);

  return (
    <div style={{
      position: 'relative',
      width: '800px',
      height: '600px',
      overflow: 'hidden'
    }}>
      <div ref={containerRef} style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%'
      }} />
      {gameRef.current && (
        <>
          <GameUI gameRef={gameRef} />
          {showDebugUI && <DebugUI gameRef={gameRef} />}
        </>
      )}
      <Settings
        onClick={() => setShowDebugUI(!showDebugUI)}
        style={{
          position: 'absolute',
          bottom: '10px',
          right: '10px',
          width: '24px',
          height: '24px',
          cursor: 'pointer',
          color: 'white'
        }}
      />
    </div>
  );
};

export default Game;
```
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, TRACK_SPACING } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.coinCount = 0;
    this.runnerSpeed = INITIAL_VALUES.RUNNER_SPEED;
    this.runnerCount = INITIAL_VALUES.RUNNER_COUNT;
    this.trackCount = INITIAL_VALUES.TRACK_COUNT;
    this.coinValue = INITIAL_VALUES.COIN_VALUE;
    this.coinSpawnRate = INITIAL_VALUES.COIN_SPAWN_RATE;
    this.collisionRadius = INITIAL_VALUES.COLLISION_RADIUS;
    
    this.runnerSpeedCost = UPGRADE_COSTS.RUNNER_SPEED;
    this.runnerCountCost = UPGRADE_COSTS.RUNNER_COUNT;
    this.trackCountCost = UPGRADE_COSTS.TRACK_COUNT;
    this.coinValueCost = UPGRADE_COSTS.COIN_VALUE;
    this.coinSpawnRateCost = UPGRADE_COSTS.COIN_SPAWN_RATE;
    this.collisionRadiusCost = UPGRADE_COSTS.COLLISION_RADIUS;

    this.coinSpawnTimer = 0;
    this.obstacleSpawnTimer = 0;
    this.lastTimestamp = performance.now();

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteKey) {
    const texture = PIXI.Texture.from(spriteKey);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = SPRITES[spriteKey].width;
    sprite.height = SPRITES[spriteKey].height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite('background');
    this.runners = new PIXI.Container();
    this.coinContainer = new PIXI.Container();
    this.obstacles = new PIXI.Container();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.coinContainer);
    this.app.stage.addChild(this.obstacles);
    this.app.stage.addChild(this.runners);

    for (let i = 0; i < this.runnerCount; i++) {
      this.createRunner();
    }
  }

  createRunner() {
    const runner = this.getSprite('runner');
    runner.anchor.set(0.5);
    runner.x = 0;
    runner.y = this.getTrackY(Math.floor(Math.random() * this.trackCount));
    runner.currentTrack = Math.floor(runner.y / TRACK_SPACING);
    this.runners.addChild(runner);
  }

  getTrackY(trackIndex) {
    return 100 + trackIndex * TRACK_SPACING;
  }

  spawnCoin() {
    const coin = this.getSprite('coin');
    coin.anchor.set(0.5);
    coin.x = SCREEN_SIZE.width;
    coin.y = this.getTrackY(Math.floor(Math.random() * this.trackCount));
    this.coinContainer.addChild(coin);
  }

  spawnObstacle() {
    const obstacle = this.getSprite('obstacle');
    obstacle.anchor.set(0.5);
    obstacle.x = SCREEN_SIZE.width;
    obstacle.y = this.getTrackY(Math.floor(Math.random() * this.trackCount));
    this.obstacles.addChild(obstacle);
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Spawn timers
    this.coinSpawnTimer += elapsedSecs;
    if (this.coinSpawnTimer >= 1 / this.coinSpawnRate) {
      this.spawnCoin();
      this.coinSpawnTimer = 0;
    }

    this.obstacleSpawnTimer += elapsedSecs;
    if (this.obstacleSpawnTimer >= INITIAL_VALUES.OBSTACLE_SPAWN_RATE) {
      this.spawnObstacle();
      this.obstacleSpawnTimer = 0;
    }

    // Move runners
    this.runners.children.forEach(runner => {
      runner.x += this.runnerSpeed * elapsedSecs;
      if (runner.x > SCREEN_SIZE.width) {
        runner.x = 0;
      }

      // Check for nearby obstacles and avoid
      this.obstacles.children.forEach(obstacle => {
        if (Math.abs(obstacle.x - runner.x) < 100 && 
            Math.abs(obstacle.y - runner.y) < TRACK_SPACING) {
          const newTrack = runner.currentTrack + (runner.y > obstacle.y ? 1 : -1);
          if (newTrack >= 0 && newTrack < this.trackCount) {
            runner.y = this.getTrackY(newTrack);
            runner.currentTrack = newTrack;
          }
        }
      });
    });

    // Move coins and obstacles
    this.coinContainer.children.forEach(coin => {
      coin.x -= 50 * elapsedSecs;
      if (coin.x < 0) {
        this.coinContainer.removeChild(coin);
      }
    });

    this.obstacles.children.forEach(obstacle => {
      obstacle.x -= 50 * elapsedSecs;
      if (obstacle.x < 0) {
        this.obstacles.removeChild(obstacle);
      }
    });

    // Check coin collection
    this.runners.children.forEach(runner => {
      this.coinContainer.children.forEach(coin => {
        const dx = runner.x - coin.x;
        const dy = runner.y - coin.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < this.collisionRadius) {
          this.coinContainer.removeChild(coin);
          this.coinCount += this.coinValue;
        }
      });
    });
  }

  upgradeRunnerSpeed() {
    if (this.coinCount >= this.runnerSpeedCost) {
      this.coinCount -= this.runnerSpeedCost;
      this.runnerSpeed *= 1.2;
      this.runnerSpeedCost *= 2;
    }
  }

  upgradeRunnerCount() {
    if (this.coinCount >= this.runnerCountCost) {
      this.coinCount -= this.runnerCountCost;
      this.runnerCount++;
      this.createRunner();
      this.runnerCountCost *= 2;
    }
  }

  upgradeTrackCount() {
    if (this.coinCount >= this.trackCountCost) {
      this.coinCount -= this.trackCountCost;
      this.trackCount++;
      this.trackCountCost *= 2;
    }
  }

  upgradeCoinValue() {
    if (this.coinCount >= this.coinValueCost) {
      this.coinCount -= this.coinValueCost;
      this.coinValue *= 1.5;
      this.coinValueCost *= 2;
    }
  }

  upgradeCoinSpawnRate() {
    if (this.coinCount >= this.coinSpawnRateCost) {
      this.coinCount -= this.coinSpawnRateCost;
      this.coinSpawnRate *= 1.2;
      this.coinSpawnRateCost *= 2;
    }
  }

  upgradeCollisionRadius() {
    if (this.coinCount >= this.collisionRadiusCost) {
      this.coinCount -= this.collisionRadiusCost;
      this.collisionRadius += 5;
      this.collisionRadiusCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}

```
```js src/game/gameData.js
export const INITIAL_VALUES = {
  RUNNER_SPEED: 100,
  RUNNER_COUNT: 1,
  TRACK_COUNT: 3,
  COIN_VALUE: 1,
  COIN_SPAWN_RATE: 1,
  COLLISION_RADIUS: 20,
  OBSTACLE_SPAWN_RATE: 2
};

export const UPGRADE_COSTS = {
  RUNNER_SPEED: 10,
  RUNNER_COUNT: 25,
  TRACK_COUNT: 50,
  COIN_VALUE: 15,
  COIN_SPAWN_RATE: 20,
  COLLISION_RADIUS: 30
};

export const TRACK_SPACING = 80;

```
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  runner: {
    path: 'assets/runner.png',
    width: 64,
    height: 64
  },
  coin: {
    path: 'assets/coin.png',
    width: 32,
    height: 32
  },
  obstacle: {
    path: 'assets/obstacle.png',
    width: 48,
    height: 48
  }
};

```
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} coins)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Coins: {Math.floor(game.coinCount)} | Runners: {game.runnerCount} | Tracks: {game.trackCount} | Coin Value: {game.coinValue.toFixed(1)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeRunnerSpeed()} cost={game.runnerSpeedCost}>Upgrade Runner Speed</Button>
        <Button onClick={() => game.upgradeRunnerCount()} cost={game.runnerCountCost}>Add Runner</Button>
        <Button onClick={() => game.upgradeTrackCount()} cost={game.trackCountCost}>Add Track</Button>
        <Button onClick={() => game.upgradeCoinValue()} cost={game.coinValueCost}>Increase Coin Value</Button>
        <Button onClick={() => game.upgradeCoinSpawnRate()} cost={game.coinSpawnRateCost}>Increase Coin Spawn Rate</Button>
        <Button onClick={() => game.upgradeCollisionRadius()} cost={game.collisionRadiusCost}>Increase Collection Range</Button>
      </div>
    </div>
  );
};

export default GameUI;

```
```js src/game/fontManifest.js
export const FONTS = [
  'Press Start 2P',
  'Roboto:400,700',
  'Orbitron:400,700',
]
```

Only make changes to the GameUI or fontManifest file. Don't change anything about the logic or functionality but make the UI look much better and make it feel like a very well implemented game. You can add multilayered menu interactions.


Make sure that only the essential data (such as currency) is shown in the hud and the other stats are hidden in a stats modal

Upgrades should be in modals and submenus instead of being directly on the screen


Make sure that the theme of your UI matches with the theme of the game

Make sure all modals can be opened and closed

General Implementation Guidelines:
1. Write out all the code of the files you intend to edit. I will be copy-pasting them
2. Do not create new files, add to the existing files in the appropriate locations
3. Do not do any refactoring outside of what you are requested to do

Directions:
In your response, do both steps, one after the other
1. First think carefully and describe in detail how you will implement the game design. Make sure to follow all the guidelines
2. Then write each file, according to the plan

Write out all the files in the format:
```filetype filepath
content
```

MOST IMPORTANT: Do not write "existing code here" or similar placeholders. If a file has been edited in anyway,
EVERY original unchanged line must be rewritten in your output
__________________
Role: assistant
Content: Let me plan out the UI improvements:

1. Theme Analysis:
- Based on the codebase, this appears to be a runner-style game with coin collection
- The color scheme uses purples (#7C45CB) and dark backgrounds, suggesting a cyber/neon aesthetic
- We'll enhance this with a futuristic, cyber-runner theme

2. UI Structure:
- Main HUD: Minimal, showing only coins and essential stats
- Stats Modal: Detailed runner and game statistics
- Upgrade Modal: Categories for different upgrade types
  - Runner Upgrades (speed, count)
  - Track Upgrades
  - Coin Upgrades (value, spawn rate, collection)
- Each modal will have a sleek, cyber design with glowing borders

3. Specific Improvements:
- Add cyberpunk-style fonts (Orbitron)
- Create floating panels with semi-transparent backgrounds
- Add hover effects and transitions
- Implement modal system with proper open/close functionality
- Group upgrades into logical categories
- Add tooltips for detailed information

Now, let's implement these changes:

```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Modal = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) return null;
  return (
    <div style={{
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.7)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 1000
    }}>
      <div style={{
        backgroundColor: 'rgba(20, 20, 35, 0.95)',
        border: '2px solid #7C45CB',
        borderRadius: '8px',
        padding: '20px',
        minWidth: '300px',
        maxWidth: '80%',
        maxHeight: '80%',
        overflow: 'auto',
        boxShadow: '0 0 20px rgba(124, 69, 203, 0.3)',
        color: '#d3d3d3',
        fontFamily: 'Orbitron, sans-serif'
      }}>
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '15px',
          borderBottom: '1px solid #7C45CB',
          paddingBottom: '10px'
        }}>
          <h2 style={{ margin: 0, color: '#fff' }}>{title}</h2>
          <button onClick={onClose} style={{
            background: 'none',
            border: 'none',
            color: '#d3d3d3',
            fontSize: '20px',
            cursor: 'pointer'
          }}>Ã—</button>
        </div>
        {children}
      </div>
    </div>
  );
};

const Button = ({ onClick, children, cost, disabled }) => (
  <button 
    onClick={onClick}
    disabled={disabled}
    style={{
      margin: '5px',
      padding: '8px 15px',
      fontSize: '14px',
      color: disabled ? '#666' : '#fff',
      border: '1px solid #7C45CB',
      borderRadius: '4px',
      cursor: disabled ? 'not-allowed' : 'pointer',
      backgroundColor: disabled ? '#2a2a2a' : 'rgba(124, 69, 203, 0.2)',
      transition: 'all 0.2s ease',
      fontFamily: 'Orbitron, sans-serif',
      ':hover': {
        backgroundColor: disabled ? '#2a2a2a' : 'rgba(124, 69, 203, 0.4)'
      }
    }}>
    {children} ({cost} coins)
  </button>
);

const MenuButton = ({ onClick, children }) => (
  <button 
    onClick={onClick}
    style={{
      margin: '5px',
      padding: '8px 15px',
      fontSize: '14px',
      color: '#fff',
      border: '1px solid #7C45CB',
      borderRadius: '4px',
      cursor: 'pointer',
      backgroundColor: 'rgba(124, 69, 203, 0.2)',
      transition: 'all 0.2s ease',
      fontFamily: 'Orbitron, sans-serif'
    }}>
    {children}
  </button>
);

const HUD = ({ game }) => (
  <div style={{
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    padding: '15px',
    background: 'linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%)',
    color: '#fff',
    fontFamily: 'Orbitron, sans-serif'
  }}>
    <div style={{ fontSize: '18px' }}>
      Coins: {Math.floor(game.coinCount)}
    </div>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  const [showStats, setShowStats] = useState(false);
  const [showUpgrades, setShowUpgrades] = useState(false);
  const [upgradeCategory, setUpgradeCategory] = useState(null);

  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  const renderUpgradeCategory = () => {
    switch (upgradeCategory) {
      case 'runners':
        return (
          <div>
            <h3>Runner Upgrades</h3>
            <Button onClick={() => game.upgradeRunnerSpeed()} cost={game.runnerSpeedCost} disabled={game.coinCount < game.runnerSpeedCost}>
              Upgrade Runner Speed
            </Button>
            <Button onClick={() => game.upgradeRunnerCount()} cost={game.runnerCountCost} disabled={game.coinCount < game.runnerCountCost}>
              Add Runner
            </Button>
          </div>
        );
      case 'tracks':
        return (
          <div>
            <h3>Track Upgrades</h3>
            <Button onClick={() => game.upgradeTrackCount()} cost={game.trackCountCost} disabled={game.coinCount < game.trackCountCost}>
              Add Track
            </Button>
          </div>
        );
      case 'coins':
        return (
          <div>
            <h3>Coin Upgrades</h3>
            <Button onClick={() => game.upgradeCoinValue()} cost={game.coinValueCost} disabled={game.coinCount < game.coinValueCost}>
              Increase Coin Value
            </Button>
            <Button onClick={() => game.upgradeCoinSpawnRate()} cost={game.coinSpawnRateCost} disabled={game.coinCount < game.coinSpawnRateCost}>
              Increase Coin Spawn Rate
            </Button>
            <Button onClick={() => game.upgradeCollisionRadius()} cost={game.collisionRadiusCost} disabled={game.coinCount < game.collisionRadiusCost}>
              Increase Collection Range
            </Button>
          </div>
        );
      default:
        return (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
            <MenuButton onClick={() => setUpgradeCategory('runners')}>Runner Upgrades</MenuButton>
            <MenuButton onClick={() => setUpgradeCategory('tracks')}>Track Upgrades</MenuButton>
            <MenuButton onClick={() => setUpgradeCategory('coins')}>Coin Upgrades</MenuButton>
          </div>
        );
    }
  };

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      
      <div style={{ position: 'absolute', bottom: '10px', right: '10px' }}>
        <MenuButton onClick={() => setShowStats(true)}>Stats</MenuButton>
        <MenuButton onClick={() => setShowUpgrades(true)}>Upgrades</MenuButton>
      </div>

      <Modal isOpen={showStats} onClose={() => setShowStats(false)} title="Game Statistics">
        <div style={{ display: 'grid', gap: '10px' }}>
          <p>Runners: {game.runnerCount}</p>
          <p>Tracks: {game.trackCount}</p>
          <p>Runner Speed: {game.runnerSpeed.toFixed(1)}</p>
          <p>Coin Value: {game.coinValue.toFixed(1)}</p>
          <p>Coin Spawn Rate: {game.coinSpawnRate.toFixed(1)}/s</p>
          <p>Collection Range: {game.collisionRadius}</p>
        </div>
      </Modal>

      <Modal 
        isOpen={showUpgrades} 
        onClose={() => {
          setShowUpgrades(false);
          setUpgradeCategory(null);
        }} 
        title={upgradeCategory ? `Upgrades - ${upgradeCategory}` : 'Upgrades'}
      >
        {renderUpgradeCategory()}
        {upgradeCategory && (
          <button
            onClick={() => setUpgradeCategory(null)}
            style={{
              marginTop: '15px',
              padding: '5px 10px',
              background: 'none',
              border: '1px solid #7C45CB',
              color: '#d3d3d3',
              cursor: 'pointer'
            }}
          >
            Back
          </button>
        )}
      </Modal>
    </div>
  );
};

export default GameUI;
```

```js src/game/fontManifest.js
export const FONTS = [
  'Orbitron:400,700',
  'Press Start 2P',
  'Roboto:400,700'
];
```

These changes implement a cyberpunk-themed UI with modal-based menus, organized upgrade categories, and a clean HUD. The fonts have been updated to prioritize Orbitron for the cyber aesthetic.
__________________
