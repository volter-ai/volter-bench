Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data (gameData.js):
- Define initial values for barista count, speeds, customer capacity, coffee price
- Define base upgrade costs and multipliers
- Define movement speeds and processing times

2. Asset Manifest (assetManifest.js):
- Add sprites for barista, customer, coffee station, counter, pickup area
- Use appropriate sizes (64x64 minimum)

3. Game Logic (gameLogic.js):
- Track money, upgrade levels, and costs
- Manage customer spawning based on capacity
- Handle customer and barista movement between points
- Implement order processing and money generation
- Create upgrade functions
- Use containers for customers and baristas
- Track order status for each customer

4. Game UI (GameUI.js):
- Display current money and stats
- Show upgrade buttons with costs
- Update display frequently

Implementation Plan:
- Use PIXI.Container for customers and baristas
- Store target positions for movement
- Use simple state machines for customer/barista behavior
- Implement straight-line movement between points
- Track order status as text above customers
- Use timers for spawning and processing

Now, I'll write out the complete implementation:

# Excerpt ID: df833e5b-52ac-4def-9045-f7c8ea0893e6
```js src/game/gameData.js
export const INITIAL_VALUES = {
  MONEY: 0,
  BARISTA_COUNT: 1,
  BARISTA_SPEED: 1,
  CUSTOMER_CAPACITY: 3,
  COFFEE_PRICE: 5,
  PROCESSING_SPEED: 1,
  CUSTOMER_SPAWN_RATE: 3, // seconds between spawns
  COFFEE_MAKE_TIME: 5, // seconds to make coffee
};

export const UPGRADE_COSTS = {
  BARISTA: 100,
  BARISTA_SPEED: 150,
  CUSTOMER_CAPACITY: 200,
  COFFEE_PRICE: 250,
  PROCESSING_SPEED: 300,
};

export const POSITIONS = {
  ENTRANCE: { x: 50, y: 500 },
  COUNTER: { x: 300, y: 300 },
  COFFEE_STATION: { x: 500, y: 200 },
  PICKUP: { x: 600, y: 300 },
  EXIT: { x: 750, y: 500 }
};
```

# Excerpt ID: 6472a318-23e7-4fe6-84f2-4389cbe37682
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  barista: {
    path: 'assets/barista.png',
    width: 64,
    height: 64
  },
  customer: {
    path: 'assets/customer.png',
    width: 64,
    height: 64
  },
  counter: {
    path: 'assets/counter.png',
    width: 128,
    height: 64
  },
  coffee_station: {
    path: 'assets/coffee_station.png',
    width: 128,
    height: 64
  },
  pickup: {
    path: 'assets/pickup.png',
    width: 128,
    height: 64
  }
};
```

# Excerpt ID: 8cb3e144-e581-432e-815c-6e2d32f5ff56
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, POSITIONS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils';

const SCREEN_SIZE = {
  width: 800,
  height: 600
};

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.money = INITIAL_VALUES.MONEY;
    this.baristaCount = INITIAL_VALUES.BARISTA_COUNT;
    this.baristaSpeed = INITIAL_VALUES.BARISTA_SPEED;
    this.customerCapacity = INITIAL_VALUES.CUSTOMER_CAPACITY;
    this.coffeePrice = INITIAL_VALUES.COFFEE_PRICE;
    this.processingSpeed = INITIAL_VALUES.PROCESSING_SPEED;

    this.baristaCost = UPGRADE_COSTS.BARISTA;
    this.baristaSpeedCost = UPGRADE_COSTS.BARISTA_SPEED;
    this.customerCapacityCost = UPGRADE_COSTS.CUSTOMER_CAPACITY;
    this.coffeePriceCost = UPGRADE_COSTS.COFFEE_PRICE;
    this.processingSpeedCost = UPGRADE_COSTS.PROCESSING_SPEED;

    this.customerSpawnTimer = 0;
    this.lastTimestamp = performance.now();

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.counter = this.getSprite(SPRITES.counter);
    this.coffeeStation = this.getSprite(SPRITES.coffee_station);
    this.pickup = this.getSprite(SPRITES.pickup);

    this.counter.position.set(POSITIONS.COUNTER.x, POSITIONS.COUNTER.y);
    this.coffeeStation.position.set(POSITIONS.COFFEE_STATION.x, POSITIONS.COFFEE_STATION.y);
    this.pickup.position.set(POSITIONS.PICKUP.x, POSITIONS.PICKUP.y);

    this.customers = new PIXI.Container();
    this.baristas = new PIXI.Container();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.counter);
    this.app.stage.addChild(this.coffeeStation);
    this.app.stage.addChild(this.pickup);
    this.app.stage.addChild(this.customers);
    this.app.stage.addChild(this.baristas);

    for (let i = 0; i < this.baristaCount; i++) {
      this.createBarista();
    }
  }

  createCustomer() {
    const customer = this.getSprite(SPRITES.customer);
    customer.anchor.set(0.5);
    customer.position.set(POSITIONS.ENTRANCE.x, POSITIONS.ENTRANCE.y);
    customer.state = 'moving_to_counter';
    customer.orderStatus = new PIXI.Text('Moving to counter...', {
      fontSize: 12,
      fill: 0xFFFFFF
    });
    customer.orderStatus.anchor.set(0.5, 1);
    customer.orderStatus.position.set(customer.width/2, -10);
    customer.addChild(customer.orderStatus);
    this.customers.addChild(customer);
  }

  createBarista() {
    const barista = this.getSprite(SPRITES.barista);
    barista.anchor.set(0.5);
    barista.position.set(POSITIONS.COUNTER.x, POSITIONS.COUNTER.y);
    barista.state = 'idle';
    barista.assignedCustomer = null;
    this.baristas.addChild(barista);
  }

  moveTowards(entity, target, speed, elapsedSecs) {
    const dx = target.x - entity.x;
    const dy = target.y - entity.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < 2) return true;

    const moveSpeed = speed * elapsedSecs;
    entity.x += (dx / distance) * moveSpeed;
    entity.y += (dy / distance) * moveSpeed;
    return false;
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    this.customerSpawnTimer += elapsedSecs;
    if (this.customerSpawnTimer >= INITIAL_VALUES.CUSTOMER_SPAWN_RATE && 
        this.customers.children.length < this.customerCapacity) {
      this.createCustomer();
      this.customerSpawnTimer = 0;
    }

    this.customers.children.forEach(customer => {
      switch (customer.state) {
        case 'moving_to_counter':
          if (this.moveTowards(customer, POSITIONS.COUNTER, 100 * this.baristaSpeed, elapsedSecs)) {
            customer.state = 'waiting_for_barista';
            customer.orderStatus.text = 'Waiting for barista...';
          }
          break;
        case 'moving_to_pickup':
          if (this.moveTowards(customer, POSITIONS.PICKUP, 100 * this.baristaSpeed, elapsedSecs)) {
            customer.state = 'collecting';
            customer.orderStatus.text = 'Collecting coffee...';
            setTimeout(() => {
              customer.state = 'leaving';
              customer.orderStatus.text = 'Thank you!';
              this.money += this.coffeePrice;
            }, 1000 / this.processingSpeed);
          }
          break;
        case 'leaving':
          if (this.moveTowards(customer, POSITIONS.EXIT, 100 * this.baristaSpeed, elapsedSecs)) {
            this.customers.removeChild(customer);
          }
          break;
      }
    });

    this.baristas.children.forEach(barista => {
      switch (barista.state) {
        case 'idle':
          const waitingCustomer = this.customers.children.find(c => 
            c.state === 'waiting_for_barista' && !this.baristas.children.some(b => 
              b.assignedCustomer === c));
          if (waitingCustomer) {
            barista.assignedCustomer = waitingCustomer;
            barista.state = 'moving_to_station';
            waitingCustomer.orderStatus.text = 'Order taken...';
          }
          break;
        case 'moving_to_station':
          if (this.moveTowards(barista, POSITIONS.COFFEE_STATION, 150 * this.baristaSpeed, elapsedSecs)) {
            barista.state = 'making_coffee';
            barista.coffeeTimer = 0;
          }
          break;
        case 'making_coffee':
          barista.coffeeTimer += elapsedSecs * this.processingSpeed;
          if (barista.coffeeTimer >= INITIAL_VALUES.COFFEE_MAKE_TIME) {
            barista.state = 'moving_to_pickup';
          }
          break;
        case 'moving_to_pickup':
          if (this.moveTowards(barista, POSITIONS.PICKUP, 150 * this.baristaSpeed, elapsedSecs)) {
            barista.assignedCustomer.state = 'moving_to_pickup';
            barista.state = 'returning';
          }
          break;
        case 'returning':
          if (this.moveTowards(barista, POSITIONS.COUNTER, 150 * this.baristaSpeed, elapsedSecs)) {
            barista.state = 'idle';
            barista.assignedCustomer = null;
          }
          break;
      }
    });
  }

  upgradeBarista() {
    if (this.money >= this.baristaCost) {
      this.money -= this.baristaCost;
      this.baristaCount++;
      this.createBarista();
      this.baristaCost *= 2;
    }
  }

  upgradeBaristaSpeed() {
    if (this.money >= this.baristaSpeedCost) {
      this.money -= this.baristaSpeedCost;
      this.baristaSpeed *= 1.2;
      this.baristaSpeedCost *= 2;
    }
  }

  upgradeCustomerCapacity() {
    if (this.money >= this.customerCapacityCost) {
      this.money -= this.customerCapacityCost;
      this.customerCapacity++;
      this.customerCapacityCost *= 2;
    }
  }

  upgradeCoffeePrice() {
    if (this.money >= this.coffeePriceCost) {
      this.money -= this.coffeePriceCost;
      this.coffeePrice = Math.floor(this.coffeePrice * 1.2);
      this.coffeePriceCost *= 2;
    }
  }

  upgradeProcessingSpeed() {
    if (this.money >= this.processingSpeedCost) {
      this.money -= this.processingSpeedCost;
      this.processingSpeed *= 1.2;
      this.processingSpeedCost *= 2;
    }
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: e9fa9f47-70b6-4515-b363-4bbaf7a80885
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#FFFFFF',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#4A90E2',
  }}>
    {children} (${cost})
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#FFFFFF' }}>
    <p>Money: ${game.money} | Baristas: {game.baristaCount} | Customers: {game.customers.children.length}/{game.customerCapacity} | Coffee Price: ${game.coffeePrice}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#FFFFFF' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeBarista()} cost={game.baristaCost}>
          Hire Barista
        </Button>
        <Button onClick={() => game.upgradeBaristaSpeed()} cost={game.baristaSpeedCost}>
          Upgrade Barista Speed
        </Button>
        <Button onClick={() => game.upgradeCustomerCapacity()} cost={game.customerCapacityCost}>
          Increase Customer Capacity
        </Button>
        <Button onClick={() => game.upgradeCoffeePrice()} cost={game.coffeePriceCost}>
          Increase Coffee Price
        </Button>
        <Button onClick={() => game.upgradeProcessingSpeed()} cost={game.processingSpeedCost}>
          Upgrade Processing Speed
        </Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the required features:
- Automatic customer spawning and movement
- Barista AI for taking and fulfilling orders
- Upgrade system with doubling costs
- Status display above customers
- Straight-line movement between points
- All core game mechanics working automatically
- Complete UI with money display and upgrade buttons

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
