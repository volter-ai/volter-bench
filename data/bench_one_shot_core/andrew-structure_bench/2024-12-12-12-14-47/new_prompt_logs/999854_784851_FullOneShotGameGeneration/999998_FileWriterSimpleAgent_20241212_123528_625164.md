Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Implementation Plan:
- The game is a runner/idle game where runners collect coins automatically
- We need to track 5 types of upgrades:
  * RUNNER_SPEED: Makes runners move faster
  * COIN_VALUE: Makes each coin worth more
  * COIN_SPAWN_RATE: Spawns coins more frequently 
  * RUNNER_COUNT: Adds more runners
  * TRACK_COUNT: Adds more tracks for runners

- For the GameAI implementation:
  1. Import all upgrade types and costs from gameData
  2. getMainCurrency will return game.coins
  3. For experimental mode:
     - Set coins to max value
     - Randomly apply 0-10 upgrades of each type
  4. For standard mode:
     - Check all upgrade costs
     - Buy the cheapest available upgrade
  5. Track stats for:
     - Current coins
     - Number of runners
     - Number of tracks
     - Runner speed
     - Coin value
     - Spawn rate
  6. Implement upgrade handling for all 5 upgrade types

2. Here's the complete GameAI.js implementation:

# Excerpt ID: a02d09cb-14f8-4cfa-af9b-3cbdd6c9a9d8
```javascript src/GameAI.js
import { AIUtils } from './AIUtils';
import { UPGRADE_COSTS } from './game/gameData';

const UPGRADES = [
  'RUNNER_SPEED',
  'COIN_VALUE', 
  'COIN_SPAWN_RATE',
  'RUNNER_COUNT',
  'TRACK_COUNT'
];

export class GameAI {
  constructor() {
    this.ai = new AIUtils();
    this.game = null;
    this.initialized = false;
    // Initialize upgrade levels for all upgrade types
    this.upgradeLevels = UPGRADES.reduce((acc, upgrade) => {
      acc[upgrade] = 0;
      return acc;
    }, {});
  }

  init() {
    if (!window.game || !window.game.ready) {
      setTimeout(() => this.init(), 100);
      return;
    }
    this.game = window.game;

    if (this.initialized) return;
    this.initialized = true;

    window.game.app.ticker.speed = this.ai.defaultGameSpeed;
    this.ai.updateDebugOverlay('Game speed set to ' + this.ai.defaultGameSpeed + 'x');

    if (this.ai.enabled) {
      this.ai.gameStartTime = Date.now();

      if (this.ai.mode === 'experimental') {
        this.setupExperimentalMode();
      }

      this.ai.startLoggingLoop(this.getMainCurrency.bind(this));
      this.startUpgradeLoop();
      this.updateGameStats();

      setTimeout(() => {
        this.ai.stopAI();
        this.ai.exportLogs();
        this.ai.updateDebugOverlay('Session ended - logs exported');
      }, this.ai.duration);
    }
  }

  getMainCurrency() {
    return this.game.coins;
  }

  setupExperimentalMode() {
    // Give infinite currency for experimental mode
    this.game.coins = Number.MAX_SAFE_INTEGER;

    // Randomly upgrade each stat between 0-10 times
    UPGRADES.forEach(upgrade => {
      const times = Math.floor(Math.random() * 11); // 0 to 10
      for (let i = 0; i < times; i++) {
        this.performUpgrade(upgrade, 0, true);
      }
    });

    this.ai.updateDebugOverlay('Experimental mode initialized with random upgrades');
  }

  updateGameStats() {
    const stats = {
      Coins: Math.floor(this.game.coins),
      'Runner Count': this.game.runnerCount,
      'Track Count': this.game.trackCount,
      'Runner Speed': this.game.runnerSpeed.toFixed(1),
      'Coin Value': this.game.coinValue.toFixed(1),
      'Spawn Rate': this.game.coinSpawnRate.toFixed(1)
    };

    this.ai.updateDebugOverlay('Game stats updated', stats);
  }

  startUpgradeLoop() {
    if (!this.ai.enabled || this.ai.mode === 'experimental') return;

    this.upgradeInterval = setInterval(() => {
      this.checkCheapestUpgrade();
      this.updateGameStats();
    }, 100);
  }

  checkCheapestUpgrade() {
    let cheapestUpgrade = null;
    let lowestCost = Infinity;

    const costs = {
      RUNNER_SPEED: this.game.runnerSpeedCost,
      COIN_VALUE: this.game.coinValueCost,
      COIN_SPAWN_RATE: this.game.coinSpawnRateCost,
      RUNNER_COUNT: this.game.runnerCountCost,
      TRACK_COUNT: this.game.trackCountCost
    };

    for (const upgrade of UPGRADES) {
      const cost = costs[upgrade];
      if (cost <= this.game.coins && cost < lowestCost) {
        cheapestUpgrade = upgrade;
        lowestCost = cost;
      }
    }

    if (cheapestUpgrade) {
      this.performUpgrade(cheapestUpgrade, lowestCost);
    }
  }

  performUpgrade(upgradeName, cost, skipLogging = false) {
    // Increment the upgrade level before performing the upgrade
    this.upgradeLevels[upgradeName]++;
    const currentLevel = this.upgradeLevels[upgradeName];

    switch (upgradeName) {
      case 'RUNNER_SPEED':
        this.game.upgradeRunnerSpeed();
        break;
      case 'COIN_VALUE':
        this.game.upgradeCoinValue();
        break;
      case 'COIN_SPAWN_RATE':
        this.game.upgradeCoinSpawnRate();
        break;
      case 'RUNNER_COUNT':
        this.game.upgradeRunnerCount();
        break;
      case 'TRACK_COUNT':
        this.game.upgradeTrackCount();
        break;
      default:
        console.error(`${upgradeName} is not a valid upgrade`);
    }

    if (!skipLogging) {
      const upgradeInfo = {
        timestamp: Date.now(),
        upgrade: upgradeName,
        cost: cost,
        level: currentLevel
      };

      this.ai.logUpgrade(upgradeInfo);
      this.ai.updateDebugOverlay(`Purchased ${upgradeName} upgrade for ${cost} (Level ${currentLevel})`);
    }
  }
}

const gameAI = new GameAI();
gameAI.init();

if (window.game) {
  window.game.exportAILogs = () => gameAI.ai.exportLogs();
  window.game.clearAILogs = () => gameAI.ai.clearLogs();
}

export default gameAI;
```

This implementation:
1. Defines all 5 upgrade types
2. Tracks upgrade levels separately from the game
3. Implements both experimental and standard modes
4. Provides detailed stats tracking
5. Handles all upgrade types through the game's existing upgrade methods
6. Maintains logs of all actions and currency changes

The AI will automatically purchase the cheapest available upgrade in standard mode, or randomly apply upgrades in experimental mode. All actions are logged and can be exported for analysis.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
