Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data Requirements:
- Initial values for tank attributes (speed, health, damage, etc)
- Base upgrade costs
- Screen dimensions and gameplay constants

2. Asset Requirements:
- Tank sprite (friendly)
- Enemy tank sprite
- Background
- Health bar graphics

3. Core Game Logic:
- Tank class with properties: health, speed, damage, position, rotation
- Spawn system for enemy tanks at screen edges
- Movement system with constant velocity
- Targeting system to find nearest enemy
- Combat system with health reduction
- Credit award system
- Upgrade system with cost scaling

4. UI Requirements:
- Display credits
- Show upgrade buttons with costs
- Display tank stats
- Health bars above tanks

Now let's implement the files:

# Excerpt ID: b2cc5753-fbe5-424a-8c8b-f8fbc4a4315f
```js src/game/gameData.js
export const INITIAL_VALUES = {
  TANK_SPEED: 100, // pixels per second
  TANK_HEALTH: 100,
  TANK_DAMAGE: 20,
  TANK_FIRE_RATE: 1, // shots per second
  TANK_RANGE: 200, // pixels
  TANK_COUNT: 1,
  ENEMY_SPAWN_RATE: 2, // seconds between spawns
  CREDITS_PER_KILL: 10
};

export const UPGRADE_COSTS = {
  TANK_SPEED: 10,
  TANK_HEALTH: 15,
  TANK_DAMAGE: 20,
  TANK_FIRE_RATE: 25,
  TANK_RANGE: 30,
  TANK_COUNT: 50
};

export const GAMEPLAY = {
  ENEMY_SPEED: 60,
  ENEMY_HEALTH: 50,
  ENEMY_DAMAGE: 10,
  BULLET_SPEED: 300
};
```

# Excerpt ID: b1540b4d-ea73-4bb9-b424-2cef8b99dc38
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  friendlyTank: {
    path: 'assets/friendly_tank.png',
    width: 64,
    height: 64
  },
  enemyTank: {
    path: 'assets/enemy_tank.png',
    width: 64,
    height: 64
  }
};
```

# Excerpt ID: e26092c4-7300-401a-a6ee-6ddfcdcb04fe
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAMEPLAY } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils';

const SCREEN_SIZE = {
  width: 800,
  height: 600
};

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.credits = 0;
    this.tankSpeed = INITIAL_VALUES.TANK_SPEED;
    this.tankHealth = INITIAL_VALUES.TANK_HEALTH;
    this.tankDamage = INITIAL_VALUES.TANK_DAMAGE;
    this.tankFireRate = INITIAL_VALUES.TANK_FIRE_RATE;
    this.tankRange = INITIAL_VALUES.TANK_RANGE;
    this.tankCount = INITIAL_VALUES.TANK_COUNT;

    this.costs = {...UPGRADE_COSTS};
    
    this.enemySpawnTimer = 0;
    this.lastTimestamp = performance.now();

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.tanks = new PIXI.Container();
    this.enemies = new PIXI.Container();
    this.bullets = new PIXI.Container();
    this.healthBars = new PIXI.Container();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.tanks);
    this.app.stage.addChild(this.enemies);
    this.app.stage.addChild(this.bullets);
    this.app.stage.addChild(this.healthBars);

    // Create initial tanks
    for (let i = 0; i < this.tankCount; i++) {
      this.createTank();
    }
  }

  createTank() {
    const tank = this.getSprite(SPRITES.friendlyTank);
    tank.anchor.set(0.5);
    tank.x = SCREEN_SIZE.width / 2;
    tank.y = SCREEN_SIZE.height / 2;
    tank.health = this.tankHealth;
    tank.fireTimer = 0;
    this.tanks.addChild(tank);
    this.createHealthBar(tank);
  }

  createEnemy() {
    const enemy = this.getSprite(SPRITES.enemyTank);
    enemy.anchor.set(0.5);
    
    // Spawn at random edge
    const side = Math.floor(Math.random() * 4);
    switch(side) {
      case 0: // top
        enemy.x = Math.random() * SCREEN_SIZE.width;
        enemy.y = -32;
        break;
      case 1: // right
        enemy.x = SCREEN_SIZE.width + 32;
        enemy.y = Math.random() * SCREEN_SIZE.height;
        break;
      case 2: // bottom
        enemy.x = Math.random() * SCREEN_SIZE.width;
        enemy.y = SCREEN_SIZE.height + 32;
        break;
      case 3: // left
        enemy.x = -32;
        enemy.y = Math.random() * SCREEN_SIZE.height;
        break;
    }
    
    enemy.health = GAMEPLAY.ENEMY_HEALTH;
    this.enemies.addChild(enemy);
    this.createHealthBar(enemy);
  }

  createHealthBar(entity) {
    const bar = new PIXI.Graphics();
    bar.beginFill(0x00ff00);
    bar.drawRect(-25, -40, 50, 5);
    bar.endFill();
    bar.owner = entity;
    this.healthBars.addChild(bar);
  }

  createBullet(shooter, target) {
    const bullet = new PIXI.Graphics();
    bullet.beginFill(0xffff00);
    bullet.drawCircle(0, 0, 3);
    bullet.endFill();
    bullet.x = shooter.x;
    bullet.y = shooter.y;
    
    const angle = Math.atan2(target.y - shooter.y, target.x - shooter.x);
    bullet.rotation = angle;
    bullet.dx = Math.cos(angle) * GAMEPLAY.BULLET_SPEED;
    bullet.dy = Math.sin(angle) * GAMEPLAY.BULLET_SPEED;
    bullet.damage = shooter.parent === this.tanks ? this.tankDamage : GAMEPLAY.ENEMY_DAMAGE;
    
    this.bullets.addChild(bullet);
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    this.enemySpawnTimer += elapsedSecs;
    if (this.enemySpawnTimer >= INITIAL_VALUES.ENEMY_SPAWN_RATE) {
      this.createEnemy();
      this.enemySpawnTimer = 0;
    }

    this.updateTanks(elapsedSecs);
    this.updateEnemies(elapsedSecs);
    this.updateBullets(elapsedSecs);
    this.updateHealthBars();
  }

  updateTanks(elapsedSecs) {
    this.tanks.children.forEach(tank => {
      const target = this.findNearestEnemy(tank);
      if (target) {
        const dx = target.x - tank.x;
        const dy = target.y - tank.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        tank.rotation = Math.atan2(dy, dx);

        if (distance > this.tankRange) {
          tank.x += (dx / distance) * this.tankSpeed * elapsedSecs;
          tank.y += (dy / distance) * this.tankSpeed * elapsedSecs;
        }

        tank.fireTimer += elapsedSecs;
        if (tank.fireTimer >= 1 / this.tankFireRate) {
          this.createBullet(tank, target);
          tank.fireTimer = 0;
        }
      }
    });
  }

  updateEnemies(elapsedSecs) {
    this.enemies.children.forEach(enemy => {
      const dx = SCREEN_SIZE.width/2 - enemy.x;
      const dy = SCREEN_SIZE.height/2 - enemy.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      enemy.rotation = Math.atan2(dy, dx);

      enemy.x += (dx / distance) * GAMEPLAY.ENEMY_SPEED * elapsedSecs;
      enemy.y += (dy / distance) * GAMEPLAY.ENEMY_SPEED * elapsedSecs;
    });
  }

  updateBullets(elapsedSecs) {
    this.bullets.children.forEach(bullet => {
      bullet.x += bullet.dx * elapsedSecs;
      bullet.y += bullet.dy * elapsedSecs;

      if (bullet.x < 0 || bullet.x > SCREEN_SIZE.width || 
          bullet.y < 0 || bullet.y > SCREEN_SIZE.height) {
        this.bullets.removeChild(bullet);
        return;
      }

      const targets = bullet.damage === this.tankDamage ? this.enemies : this.tanks;
      targets.children.forEach(target => {
        if (this.checkCollision(bullet, target)) {
          target.health -= bullet.damage;
          this.bullets.removeChild(bullet);
          
          if (target.health <= 0) {
            if (targets === this.enemies) {
              this.credits += INITIAL_VALUES.CREDITS_PER_KILL;
            }
            this.removeEntity(target);
          }
        }
      });
    });
  }

  updateHealthBars() {
    this.healthBars.children.forEach(bar => {
      if (!bar.owner.parent) {
        this.healthBars.removeChild(bar);
        return;
      }
      bar.x = bar.owner.x;
      bar.y = bar.owner.y;
      bar.scale.x = bar.owner.health / (bar.owner.parent === this.tanks ? this.tankHealth : GAMEPLAY.ENEMY_HEALTH);
    });
  }

  findNearestEnemy(tank) {
    let nearest = null;
    let minDistance = Infinity;
    
    this.enemies.children.forEach(enemy => {
      const dx = enemy.x - tank.x;
      const dy = enemy.y - tank.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < minDistance) {
        minDistance = distance;
        nearest = enemy;
      }
    });
    
    return nearest;
  }

  checkCollision(obj1, obj2) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (obj1.width + obj2.width) / 4;
  }

  removeEntity(entity) {
    entity.parent.removeChild(entity);
  }

  upgradeTankSpeed() {
    if (this.credits >= this.costs.TANK_SPEED) {
      this.credits -= this.costs.TANK_SPEED;
      this.tankSpeed *= 1.1;
      this.costs.TANK_SPEED *= 2;
    }
  }

  upgradeTankHealth() {
    if (this.credits >= this.costs.TANK_HEALTH) {
      this.credits -= this.costs.TANK_HEALTH;
      this.tankHealth *= 1.2;
      this.costs.TANK_HEALTH *= 2;
    }
  }

  upgradeTankDamage() {
    if (this.credits >= this.costs.TANK_DAMAGE) {
      this.credits -= this.costs.TANK_DAMAGE;
      this.tankDamage *= 1.2;
      this.costs.TANK_DAMAGE *= 2;
    }
  }

  upgradeFireRate() {
    if (this.credits >= this.costs.TANK_FIRE_RATE) {
      this.credits -= this.costs.TANK_FIRE_RATE;
      this.tankFireRate *= 1.1;
      this.costs.TANK_FIRE_RATE *= 2;
    }
  }

  upgradeRange() {
    if (this.credits >= this.costs.TANK_RANGE) {
      this.credits -= this.costs.TANK_RANGE;
      this.tankRange *= 1.1;
      this.costs.TANK_RANGE *= 2;
    }
  }

  upgradeTankCount() {
    if (this.credits >= this.costs.TANK_COUNT) {
      this.credits -= this.costs.TANK_COUNT;
      this.tankCount++;
      this.createTank();
      this.costs.TANK_COUNT *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: 2277daba-1434-44cb-8a20-8d8be445a3f8
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
    position: 'relative',
  }}>
    {children} ({cost} credits)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Credits: {game.credits} | Tanks: {game.tankCount} | Speed: {game.tankSpeed.toFixed(1)} | Health: {game.tankHealth.toFixed(0)} | Damage: {game.tankDamage.toFixed(1)} | Fire Rate: {game.tankFireRate.toFixed(1)} | Range: {game.tankRange.toFixed(0)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeTankCount()} cost={game.costs.TANK_COUNT}>Add Tank</Button>
        <Button onClick={() => game.upgradeTankSpeed()} cost={game.costs.TANK_SPEED}>Upgrade Speed</Button>
        <Button onClick={() => game.upgradeTankHealth()} cost={game.costs.TANK_HEALTH}>Upgrade Health</Button>
        <Button onClick={() => game.upgradeTankDamage()} cost={game.costs.TANK_DAMAGE}>Upgrade Damage</Button>
        <Button onClick={() => game.upgradeFireRate()} cost={game.costs.TANK_FIRE_RATE}>Upgrade Fire Rate</Button>
        <Button onClick={() => game.upgradeRange()} cost={game.costs.TANK_RANGE}>Upgrade Range</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the requested features:
1. Auto-playing tanks that target nearest enemies
2. Enemy tanks spawning at edges and moving toward center
3. Health bars for all tanks
4. Credit system with rewards for destroying enemies
5. All 6 requested upgrades with doubling costs
6. Proper movement and rotation
7. Combat system with bullets and damage
8. Complete UI showing all stats and upgrade buttons

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
