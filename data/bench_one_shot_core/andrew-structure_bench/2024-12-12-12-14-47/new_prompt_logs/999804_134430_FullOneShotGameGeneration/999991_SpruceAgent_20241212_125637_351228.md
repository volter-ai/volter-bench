Role: system
Content: You are an expert software developer. Your job is to make an existing simple UI look like the UI from an advanced video game
__________________
Role: user
Content: The existing codebase of the project is as follows:
```js src/Game.js
import React, { useRef, useState, useEffect } from 'react';
import { Settings } from 'lucide-react';
import { GameLogic } from './game/gameLogic';
import GameUI from './ui/GameUI';
import DebugUI from './ui/DebugUI';

const FRAME_RATE = 30;
const FRAME_INTERVAL = 1000 / FRAME_RATE;

const Game = () => {
  const containerRef = useRef(null);
  const gameRef = useRef(null);
  const [showDebugUI, setShowDebugUI] = useState(false);
  const [, setFrame] = useState(0);

  useEffect(() => {
    if (!containerRef.current) return;

    const game = new GameLogic(containerRef.current);
    window.game = game;
    gameRef.current = game;

    let lastTime = Date.now();
    let intervalId;
    const update = (currentTime) => {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // Force a re-render by updating the frame state
      setFrame(prevFrame => prevFrame + 1);
    };

    intervalId = setInterval(() => {
      update(Date.now());
    }, FRAME_INTERVAL);

    return () => {
      clearInterval(intervalId);
      if (gameRef.current) {
        gameRef.current.destroy();
        gameRef.current = null;
      }
      gameRef.current = null;
    };
  }, []);

  return (
    <div style={{
      position: 'relative',
      width: '800px',
      height: '600px',
      overflow: 'hidden'
    }}>
      <div ref={containerRef} style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%'
      }} />
      {gameRef.current && (
        <>
          <GameUI gameRef={gameRef} />
          {showDebugUI && <DebugUI gameRef={gameRef} />}
        </>
      )}
      <Settings
        onClick={() => setShowDebugUI(!showDebugUI)}
        style={{
          position: 'absolute',
          bottom: '10px',
          right: '10px',
          width: '24px',
          height: '24px',
          cursor: 'pointer',
          color: 'white'
        }}
      />
    </div>
  );
};

export default Game;
```
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAME_CONFIG } from './gameData';
import { SPRITES } from './assetManifest';

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;
    this.paddleSize = INITIAL_VALUES.PADDLE_SIZE;
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.pointsMultiplier = INITIAL_VALUES.POINTS_MULTIPLIER;
    this.ballCount = INITIAL_VALUES.BALL_COUNT;

    this.paddleSizeCost = UPGRADE_COSTS.PADDLE_SIZE;
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.multiBallCost = UPGRADE_COSTS.MULTI_BALL;
    this.pointsMultiplierCost = UPGRADE_COSTS.POINTS_MULTIPLIER;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;

    // Create containers first
    this.paddles = new PIXI.Container();
    this.balls = new PIXI.Container();
    this.app.stage.addChild(this.paddles);
    this.app.stage.addChild(this.balls);

    // Load assets
    const loader = new PIXI.Loader();
    Object.values(SPRITES).forEach(sprite => {
      loader.add(sprite.path, sprite.path);
    });

    loader.load(() => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.app.stage.addChild(this.background);
    
    // Create left paddle
    this.leftPaddle = this.getSprite(SPRITES.paddle);
    this.leftPaddle.x = 50;
    this.leftPaddle.y = SCREEN_SIZE.height / 2;
    this.leftPaddle.anchor.set(0.5);
    this.leftPaddle.height = this.paddleSize;
    
    // Create right paddle
    this.rightPaddle = this.getSprite(SPRITES.paddle);
    this.rightPaddle.x = SCREEN_SIZE.width - 50;
    this.rightPaddle.y = SCREEN_SIZE.height / 2;
    this.rightPaddle.anchor.set(0.5);
    this.rightPaddle.height = this.paddleSize;

    this.paddles.addChild(this.leftPaddle);
    this.paddles.addChild(this.rightPaddle);

    this.createBall();
  }

  createBall() {
    const ball = this.getSprite(SPRITES.ball);
    ball.anchor.set(0.5);
    this.resetBall(ball);
    ball.currentSpeed = this.ballSpeed;
    this.balls.addChild(ball);
  }

  resetBall(ball) {
    ball.x = SCREEN_SIZE.width / 2;
    ball.y = SCREEN_SIZE.height / 2;
    const angle = (Math.random() * Math.PI / 2) - Math.PI / 4;
    ball.dx = Math.cos(angle) * (Math.random() < 0.5 ? 1 : -1);
    ball.dy = Math.sin(angle);
    ball.currentSpeed = this.ballSpeed;
  }

  gameLoop(delta) {
    const elapsedSecs = delta / 60;
    
    // Move paddles
    [this.leftPaddle, this.rightPaddle].forEach(paddle => {
      let nearestBall = null;
      let nearestDist = Infinity;
      
      this.balls.children.forEach(ball => {
        const dist = Math.abs(ball.y - paddle.y);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestBall = ball;
        }
      });

      if (nearestBall) {
        const targetY = nearestBall.y;
        const dy = targetY - paddle.y;
        const moveAmount = Math.min(Math.abs(dy), this.paddleSpeed * elapsedSecs);
        paddle.y += Math.sign(dy) * moveAmount;
      }

      paddle.y = Math.max(paddle.height/2, Math.min(SCREEN_SIZE.height - paddle.height/2, paddle.y));
    });

    // Move balls
    this.balls.children.forEach(ball => {
      ball.x += ball.dx * ball.currentSpeed * elapsedSecs;
      ball.y += ball.dy * ball.currentSpeed * elapsedSecs;

      // Bounce off top/bottom
      if (ball.y < 0 || ball.y > SCREEN_SIZE.height) {
        ball.dy *= -1;
      }

      // Check paddle collisions
      [this.leftPaddle, this.rightPaddle].forEach(paddle => {
        if (this.checkCollision(ball, paddle)) {
          ball.dx *= -1;
          ball.currentSpeed *= GAME_CONFIG.BALL_ACCELERATION;
          this.score += GAME_CONFIG.BASE_POINTS * this.pointsMultiplier;
        }
      });

      // Score/Reset
      if (ball.x < 0 || ball.x > SCREEN_SIZE.width) {
        this.resetBall(ball);
      }
    });
  }

  checkCollision(ball, paddle) {
    return ball.x > paddle.x - paddle.width/2 &&
           ball.x < paddle.x + paddle.width/2 &&
           ball.y > paddle.y - paddle.height/2 &&
           ball.y < paddle.y + paddle.height/2;
  }

  upgradePaddleSize() {
    if (this.score >= this.paddleSizeCost) {
      this.score -= this.paddleSizeCost;
      this.paddleSize += 20;
      this.leftPaddle.height = this.paddleSize;
      this.rightPaddle.height = this.paddleSize;
      this.paddleSizeCost *= 2;
    }
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed *= 1.2;
      this.ballSpeedCost *= 2;
    }
  }

  upgradeMultiBall() {
    if (this.score >= this.multiBallCost) {
      this.score -= this.multiBallCost;
      this.ballCount++;
      this.createBall();
      this.multiBallCost *= 2;
    }
  }

  upgradePointsMultiplier() {
    if (this.score >= this.pointsMultiplierCost) {
      this.score -= this.pointsMultiplierCost;
      this.pointsMultiplier *= 2;
      this.pointsMultiplierCost *= 2;
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed *= 1.2;
      this.paddleSpeedCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}

```
```js src/game/gameData.js
export const INITIAL_VALUES = {
  PADDLE_SIZE: 100,
  BALL_SPEED: 200,
  PADDLE_SPEED: 300,
  POINTS_MULTIPLIER: 1,
  BALL_COUNT: 1,
};

export const UPGRADE_COSTS = {
  PADDLE_SIZE: 10,
  BALL_SPEED: 15,
  MULTI_BALL: 50,
  POINTS_MULTIPLIER: 25,
  PADDLE_SPEED: 20,
};

export const GAME_CONFIG = {
  PADDLE_WIDTH: 20,
  BALL_SIZE: 16,
  BALL_ACCELERATION: 1.1,
  BASE_POINTS: 1,
};

```
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  paddle: {
    path: 'assets/paddle.png',
    width: 20,
    height: 100
  },
  ball: {
    path: 'assets/ball.png',
    width: 16,
    height: 16
  }
};

```
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} points)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Score: {game.score}</p>
    <p>Paddle Size: {game.paddleSize} | Ball Speed: {game.ballSpeed.toFixed(1)} | Balls: {game.ballCount} | Points Multiplier: {game.pointsMultiplier}x | Paddle Speed: {game.paddleSpeed.toFixed(1)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradePaddleSize()} cost={game.paddleSizeCost}>Upgrade Paddle Size</Button>
        <Button onClick={() => game.upgradeBallSpeed()} cost={game.ballSpeedCost}>Upgrade Ball Speed</Button>
        <Button onClick={() => game.upgradeMultiBall()} cost={game.multiBallCost}>Add Ball</Button>
        <Button onClick={() => game.upgradePointsMultiplier()} cost={game.pointsMultiplierCost}>Upgrade Points Multiplier</Button>
        <Button onClick={() => game.upgradePaddleSpeed()} cost={game.paddleSpeedCost}>Upgrade Paddle Speed</Button>
      </div>
    </div>
  );
};

export default GameUI;

```
```js src/game/fontManifest.js
export const FONTS = [
  'Press Start 2P',
  'Roboto:400,700',
  'Orbitron:400,700',
]
```

Only make changes to the GameUI or fontManifest file. Don't change anything about the logic or functionality but make the UI look much better and make it feel like a very well implemented game. You can add multilayered menu interactions.


Make sure that only the essential data (such as currency) is shown in the hud and the other stats are hidden in a stats modal

Upgrades should be in modals and submenus instead of being directly on the screen


Make sure that the theme of your UI matches with the theme of the game

Make sure all modals can be opened and closed

General Implementation Guidelines:
1. Write out all the code of the files you intend to edit. I will be copy-pasting them
2. Do not create new files, add to the existing files in the appropriate locations
3. Do not do any refactoring outside of what you are requested to do

Directions:
In your response, do both steps, one after the other
1. First think carefully and describe in detail how you will implement the game design. Make sure to follow all the guidelines
2. Then write each file, according to the plan

Write out all the files in the format:
```filetype filepath
content
```

MOST IMPORTANT: Do not write "existing code here" or similar placeholders. If a file has been edited in anyway,
EVERY original unchanged line must be rewritten in your output
__________________
Role: assistant
Content: Let me plan out the UI redesign for this futuristic pong-like game.

DESIGN PLAN:
1. Theme: Cyber/Neon futuristic aesthetic with glowing elements and dark backgrounds
2. UI Structure:
   - Minimal HUD showing only score and a few key buttons
   - Main menu button that opens a sleek modal with sections:
     * Stats Overview
     * Upgrades
     * Settings
   - Upgrades organized into categories:
     * Paddle Enhancements (size, speed)
     * Ball Modifications (speed, multi-ball)
     * Score Multipliers
   - All modals will have smooth transitions and cyber-themed borders
   - Custom styled buttons with hover effects
3. Font Usage:
   - Adding "Orbitron" for main headings
   - "Press Start 2P" for score display
   - "Roboto" for general text

Now, let's implement the files:

```js src/game/fontManifest.js
export const FONTS = [
  'Press Start 2P',
  'Roboto:400,700',
  'Orbitron:400,700',
];
```

```jsx src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Modal = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) return null;
  return (
    <div className="modal-overlay" style={{
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.85)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 1000
    }}>
      <div className="modal-content" style={{
        backgroundColor: '#1a1a2e',
        border: '2px solid #7C45CB',
        borderRadius: '8px',
        padding: '20px',
        width: '80%',
        maxWidth: '600px',
        maxHeight: '80vh',
        overflow: 'auto',
        boxShadow: '0 0 20px rgba(124, 69, 203, 0.3)',
        position: 'relative'
      }}>
        <h2 style={{
          fontFamily: 'Orbitron',
          color: '#fff',
          marginBottom: '20px',
          borderBottom: '2px solid #7C45CB',
          paddingBottom: '10px'
        }}>{title}</h2>
        <button onClick={onClose} style={{
          position: 'absolute',
          top: '10px',
          right: '10px',
          background: 'none',
          border: 'none',
          color: '#fff',
          fontSize: '20px',
          cursor: 'pointer'
        }}>×</button>
        {children}
      </div>
    </div>
  );
};

const Button = ({ onClick, children, cost, style }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '10px 20px',
    fontSize: '14px',
    color: '#fff',
    border: '2px solid #7C45CB',
    borderRadius: '4px',
    cursor: 'pointer',
    backgroundColor: 'rgba(124, 69, 203, 0.2)',
    transition: 'all 0.3s ease',
    fontFamily: 'Roboto',
    ...style,
    ':hover': {
      backgroundColor: 'rgba(124, 69, 203, 0.4)',
      transform: 'translateY(-2px)'
    }
  }}>
    {children} {cost && `(${cost} points)`}
  </button>
);

const HUD = ({ game, onOpenMenu }) => (
  <div style={{
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    padding: '15px',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    background: 'linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%)'
  }}>
    <div style={{ fontFamily: 'Press Start 2P', fontSize: '20px', color: '#fff' }}>
      {game.score}
    </div>
    <Button onClick={onOpenMenu} style={{ backgroundColor: 'rgba(124, 69, 203, 0.3)' }}>
      Menu
    </Button>
  </div>
);

const StatsPanel = ({ game }) => (
  <div style={{ color: '#fff', fontFamily: 'Roboto' }}>
    <div style={{ marginBottom: '20px' }}>
      <h3 style={{ fontFamily: 'Orbitron', color: '#7C45CB' }}>Paddle Stats</h3>
      <p>Size: {game.paddleSize}</p>
      <p>Speed: {game.paddleSpeed.toFixed(1)}</p>
    </div>
    <div style={{ marginBottom: '20px' }}>
      <h3 style={{ fontFamily: 'Orbitron', color: '#7C45CB' }}>Ball Stats</h3>
      <p>Speed: {game.ballSpeed.toFixed(1)}</p>
      <p>Count: {game.ballCount}</p>
    </div>
    <div>
      <h3 style={{ fontFamily: 'Orbitron', color: '#7C45CB' }}>Scoring</h3>
      <p>Multiplier: {game.pointsMultiplier}x</p>
    </div>
  </div>
);

const UpgradePanel = ({ game }) => (
  <div style={{ color: '#fff', fontFamily: 'Roboto' }}>
    <div style={{ marginBottom: '20px' }}>
      <h3 style={{ fontFamily: 'Orbitron', color: '#7C45CB' }}>Paddle Upgrades</h3>
      <Button onClick={() => game.upgradePaddleSize()} cost={game.paddleSizeCost}>
        Increase Size
      </Button>
      <Button onClick={() => game.upgradePaddleSpeed()} cost={game.paddleSpeedCost}>
        Increase Speed
      </Button>
    </div>
    <div style={{ marginBottom: '20px' }}>
      <h3 style={{ fontFamily: 'Orbitron', color: '#7C45CB' }}>Ball Upgrades</h3>
      <Button onClick={() => game.upgradeBallSpeed()} cost={game.ballSpeedCost}>
        Increase Speed
      </Button>
      <Button onClick={() => game.upgradeMultiBall()} cost={game.multiBallCost}>
        Add Ball
      </Button>
    </div>
    <div>
      <h3 style={{ fontFamily: 'Orbitron', color: '#7C45CB' }}>Score Upgrades</h3>
      <Button onClick={() => game.upgradePointsMultiplier()} cost={game.pointsMultiplierCost}>
        Increase Multiplier
      </Button>
    </div>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  const [menuOpen, setMenuOpen] = useState(false);
  const [activeTab, setActiveTab] = useState('stats');

  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%' }}>
      <HUD game={game} onOpenMenu={() => setMenuOpen(true)} />
      
      <Modal isOpen={menuOpen} onClose={() => setMenuOpen(false)} title="Game Menu">
        <div style={{ marginBottom: '20px' }}>
          <Button 
            onClick={() => setActiveTab('stats')} 
            style={{ backgroundColor: activeTab === 'stats' ? 'rgba(124, 69, 203, 0.4)' : undefined }}
          >
            Stats
          </Button>
          <Button 
            onClick={() => setActiveTab('upgrades')} 
            style={{ backgroundColor: activeTab === 'upgrades' ? 'rgba(124, 69, 203, 0.4)' : undefined }}
          >
            Upgrades
          </Button>
        </div>
        
        {activeTab === 'stats' && <StatsPanel game={game} />}
        {activeTab === 'upgrades' && <UpgradePanel game={game} />}
      </Modal>
    </div>
  );
};

export default GameUI;
```

This implementation creates a sleek, cyber-themed UI with:
1. A minimal HUD showing only the score and menu button
2. A modal system for displaying additional information
3. Organized upgrade categories
4. Consistent styling with the cyber theme
5. Proper font usage for different elements
6. Tab system for switching between stats and upgrades
7. Hover effects and transitions for better interactivity
__________________
