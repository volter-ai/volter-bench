Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let's trace the error:

1. Error Analysis:
The error occurs in utils.js line 47:
# Excerpt ID: c3aeea1c-0159-4155-be38-72ea8f8a3c17
```javascript
PIXI.Texture.addToCache(resources.default.texture, ASSET_MANIFEST[key].path);
```

The issue is that we're referencing ASSET_MANIFEST but we're passing SPRITES to the loadAssets function. We need to:
1. Fix the utils.js file to use the correct manifest reference
2. Ensure proper error handling for texture loading

Here are the complete fixed files:

# Excerpt ID: 26190896-e3af-48d4-b6e3-326f3828af63
```js src/game/utils.js
import * as PIXI from 'pixi.js';

export function loadAssets(spriteManifest, onComplete) {
  const loader = new PIXI.Loader();
  
  // Add all sprites to the loader
  Object.entries(spriteManifest).forEach(([key, sprite]) => {
    loader.add(key, sprite.path);
  });

  loader.load((loader, resources) => {
    // Create and cache textures
    Object.keys(resources).forEach(key => {
      if (resources[key].texture) {
        PIXI.Texture.addToCache(resources[key].texture, spriteManifest[key].path);
      }
    });

    if (onComplete) {
      onComplete();
    }
  });

  loader.onError.add((error) => {
    console.error("Error loading assets:", error);
  });
}
```

# Excerpt ID: e37dba44-0d49-49fa-98a0-e3fa9f9271e4
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, TRACK_CONFIG } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;
    this.runnerSpeed = INITIAL_VALUES.RUNNER_SPEED;
    this.coinSpawnRate = INITIAL_VALUES.COIN_SPAWN_RATE;
    this.coinValue = INITIAL_VALUES.COIN_VALUE;
    this.runnerCount = INITIAL_VALUES.RUNNER_COUNT;
    this.trackCount = INITIAL_VALUES.TRACK_COUNT;
    
    this.runnerSpeedCost = UPGRADE_COSTS.RUNNER_SPEED;
    this.coinSpawnRateCost = UPGRADE_COSTS.COIN_SPAWN_RATE;
    this.coinValueCost = UPGRADE_COSTS.COIN_VALUE;
    this.runnerCountCost = UPGRADE_COSTS.RUNNER_COUNT;
    this.trackCountCost = UPGRADE_COSTS.TRACK_COUNT;

    this.coinSpawnTimer = 0;
    this.lastTimestamp = performance.now();

    // Initialize containers first
    this.runners = new PIXI.Container();
    this.coinContainer = new PIXI.Container();
    this.app.stage.addChild(this.runners);
    this.app.stage.addChild(this.coinContainer);

    // Load assets and create objects after loading
    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    try {
      const texture = PIXI.Texture.from(spriteConfig.path);
      const sprite = new PIXI.Sprite(texture);
      sprite.width = spriteConfig.width;
      sprite.height = spriteConfig.height;
      return sprite;
    } catch (error) {
      console.error("Error creating sprite:", error);
      return null;
    }
  }

  createGameObjects() {
    // Create and add background first
    const background = this.getSprite(SPRITES.background);
    if (background) {
      this.app.stage.addChildAt(background, 0);
    }

    // Create initial runners
    for (let i = 0; i < this.runnerCount; i++) {
      this.createRunner();
    }
  }

  createRunner() {
    const runner = this.getSprite(SPRITES.runner);
    if (!runner) return;
    
    const trackIndex = this.runners.children.length % this.trackCount;
    runner.anchor.set(0.5);
    runner.x = SCREEN_SIZE.width - runner.width/2;
    runner.y = TRACK_CONFIG.START_Y + (trackIndex * TRACK_CONFIG.SPACING);
    this.runners.addChild(runner);
  }

  spawnCoin() {
    const coin = this.getSprite(SPRITES.coin);
    if (!coin) return;

    coin.anchor.set(0.5);
    const trackIndex = Math.floor(Math.random() * this.trackCount);
    coin.x = Math.random() * (SCREEN_SIZE.width - coin.width) + coin.width/2;
    coin.y = TRACK_CONFIG.START_Y + (trackIndex * TRACK_CONFIG.SPACING);
    this.coinContainer.addChild(coin);
  }

  gameLoop() {
    if (!this.ready) return;

    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Move runners
    this.runners.children.forEach(runner => {
      runner.x -= this.runnerSpeed * elapsedSecs;
      if (runner.x < -runner.width/2) {
        runner.x = SCREEN_SIZE.width + runner.width/2;
      }
    });

    // Spawn coins
    this.coinSpawnTimer += elapsedSecs * this.coinSpawnRate;
    while (this.coinSpawnTimer >= 1) {
      this.spawnCoin();
      this.coinSpawnTimer--;
    }

    // Check coin collection
    this.runners.children.forEach(runner => {
      this.coinContainer.children.forEach(coin => {
        if (this.checkCollision(runner, coin)) {
          this.coinContainer.removeChild(coin);
          this.score += this.coinValue;
        }
      });
    });
  }

  checkCollision(obj1, obj2) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (obj1.width/2 + obj2.width/2);
  }

  upgradeRunnerSpeed() {
    if (this.score >= this.runnerSpeedCost) {
      this.score -= this.runnerSpeedCost;
      this.runnerSpeed *= 1.1;
      this.runnerSpeedCost *= 2;
    }
  }

  upgradeCoinSpawnRate() {
    if (this.score >= this.coinSpawnRateCost) {
      this.score -= this.coinSpawnRateCost;
      this.coinSpawnRate *= 1.1;
      this.coinSpawnRateCost *= 2;
    }
  }

  upgradeCoinValue() {
    if (this.score >= this.coinValueCost) {
      this.score -= this.coinValueCost;
      this.coinValue *= 1.1;
      this.coinValueCost *= 2;
    }
  }

  upgradeRunnerCount() {
    if (this.score >= this.runnerCountCost) {
      this.score -= this.runnerCountCost;
      this.runnerCount++;
      this.createRunner();
      this.runnerCountCost *= 2;
    }
  }

  upgradeTrackCount() {
    if (this.score >= this.trackCountCost && this.trackCount < INITIAL_VALUES.MAX_TRACKS) {
      this.score -= this.trackCountCost;
      this.trackCount++;
      this.trackCountCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

The main changes are:
1. Fixed utils.js to use the correct spriteManifest parameter instead of ASSET_MANIFEST
2. Added proper error handling for texture loading
3. Added try/catch in getSprite
4. Improved error handling in asset loading callback

This should resolve the texture loading errors while maintaining all the game functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
