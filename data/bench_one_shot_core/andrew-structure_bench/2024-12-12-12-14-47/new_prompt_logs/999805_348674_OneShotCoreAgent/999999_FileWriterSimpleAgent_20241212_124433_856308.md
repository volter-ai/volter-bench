Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Design Implementation Plan:

a) GameData.js will contain:
- Initial values for tank attributes (health, damage, fire rate, range)
- Base upgrade costs
- Battle positions for friendly/enemy tanks
- Credit reward per tank destroyed

b) AssetManifest.js will need:
- Background image
- Friendly tank sprite
- Enemy tank sprite
- Projectile sprite

c) GameLogic.js core mechanics:
- Track tanks in separate containers for friendly/enemy
- Implement tank spawning system with positions
- Add tank movement to battle positions
- Create projectile firing system
- Handle collisions between projectiles and tanks
- Manage tank health and destruction
- Award credits on enemy tank destruction
- Implement all upgrades affecting tank attributes

d) GameUI.js will show:
- Credit counter
- Current stats (tank count, damage, fire rate, health, range)
- Upgrade buttons with costs

Now I'll implement each file:

# Excerpt ID: 023d614b-b0ef-49af-bc05-cdf4dcf70aae
```javascript src/game/gameData.js
export const INITIAL_VALUES = {
  TANK_COUNT: 1,
  TANK_DAMAGE: 10,
  FIRE_RATE: 1,
  TANK_HEALTH: 100,
  TANK_RANGE: 200,
  TANK_SPEED: 100,
  PROJECTILE_SPEED: 300,
  ENEMY_COUNT: 3,
  CREDITS_PER_KILL: 10
};

export const UPGRADE_COSTS = {
  TANK_COUNT: 100,
  TANK_DAMAGE: 50,
  FIRE_RATE: 75,
  TANK_HEALTH: 60,
  TANK_RANGE: 80
};

export const BATTLE_POSITIONS = {
  FRIENDLY: [
    {x: 200, y: 150},
    {x: 200, y: 300},
    {x: 200, y: 450},
    {x: 150, y: 200},
    {x: 150, y: 350}
  ],
  ENEMY: [
    {x: 600, y: 150},
    {x: 600, y: 300},
    {x: 600, y: 450},
    {x: 650, y: 200},
    {x: 650, y: 350}
  ]
};
```

# Excerpt ID: 3d92ca20-3659-4b54-972f-1a9f5c36d2ae
```javascript src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  friendlyTank: {
    path: 'assets/friendly_tank.png',
    width: 64,
    height: 64
  },
  enemyTank: {
    path: 'assets/enemy_tank.png',
    width: 64,
    height: 64
  }
};
```

# Excerpt ID: 04a5dca4-69df-42c1-b931-9eb53e1b60ec
```javascript src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, BATTLE_POSITIONS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.credits = 0;
    this.lastTimestamp = performance.now();

    // Game attributes
    this.tankCount = INITIAL_VALUES.TANK_COUNT;
    this.tankDamage = INITIAL_VALUES.TANK_DAMAGE;
    this.fireRate = INITIAL_VALUES.FIRE_RATE;
    this.tankHealth = INITIAL_VALUES.TANK_HEALTH;
    this.tankRange = INITIAL_VALUES.TANK_RANGE;

    // Upgrade costs
    this.tankCountCost = UPGRADE_COSTS.TANK_COUNT;
    this.tankDamageCost = UPGRADE_COSTS.TANK_DAMAGE;
    this.fireRateCost = UPGRADE_COSTS.FIRE_RATE;
    this.tankHealthCost = UPGRADE_COSTS.TANK_HEALTH;
    this.tankRangeCost = UPGRADE_COSTS.TANK_RANGE;

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.friendlyTanks = new PIXI.Container();
    this.enemyTanks = new PIXI.Container();
    this.projectiles = new PIXI.Container();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.friendlyTanks);
    this.app.stage.addChild(this.enemyTanks);
    this.app.stage.addChild(this.projectiles);

    // Initial spawn
    this.spawnInitialTanks();
  }

  spawnInitialTanks() {
    for (let i = 0; i < this.tankCount; i++) {
      this.spawnFriendlyTank(i);
    }
    for (let i = 0; i < INITIAL_VALUES.ENEMY_COUNT; i++) {
      this.spawnEnemyTank(i);
    }
  }

  spawnFriendlyTank(position) {
    const tank = this.getSprite(SPRITES.friendlyTank);
    tank.anchor.set(0.5);
    tank.x = 0;
    tank.y = SCREEN_SIZE.height / 2;
    tank.targetX = BATTLE_POSITIONS.FRIENDLY[position].x;
    tank.targetY = BATTLE_POSITIONS.FRIENDLY[position].y;
    tank.health = this.tankHealth;
    tank.fireTimer = 0;
    this.friendlyTanks.addChild(tank);
  }

  spawnEnemyTank(position) {
    const tank = this.getSprite(SPRITES.enemyTank);
    tank.anchor.set(0.5);
    tank.x = SCREEN_SIZE.width;
    tank.y = SCREEN_SIZE.height / 2;
    tank.targetX = BATTLE_POSITIONS.ENEMY[position].x;
    tank.targetY = BATTLE_POSITIONS.ENEMY[position].y;
    tank.health = INITIAL_VALUES.TANK_HEALTH;
    tank.fireTimer = 0;
    this.enemyTanks.addChild(tank);
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    this.moveTanks(elapsedSecs);
    this.updateCombat(elapsedSecs);
    this.moveProjectiles(elapsedSecs);
    this.checkProjectileCollisions();
  }

  moveTanks(elapsedSecs) {
    const moveToTarget = (tank) => {
      const dx = tank.targetX - tank.x;
      const dy = tank.targetY - tank.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > 1) {
        tank.x += (dx / distance) * INITIAL_VALUES.TANK_SPEED * elapsedSecs;
        tank.y += (dy / distance) * INITIAL_VALUES.TANK_SPEED * elapsedSecs;
      }
    };

    this.friendlyTanks.children.forEach(moveToTarget);
    this.enemyTanks.children.forEach(moveToTarget);
  }

  updateCombat(elapsedSecs) {
    this.friendlyTanks.children.forEach(tank => {
      tank.fireTimer += elapsedSecs;
      if (tank.fireTimer >= 1 / this.fireRate) {
        this.fireAtNearestEnemy(tank, true);
        tank.fireTimer = 0;
      }
    });

    this.enemyTanks.children.forEach(tank => {
      tank.fireTimer += elapsedSecs;
      if (tank.fireTimer >= 1 / INITIAL_VALUES.FIRE_RATE) {
        this.fireAtNearestEnemy(tank, false);
        tank.fireTimer = 0;
      }
    });
  }

  fireAtNearestEnemy(tank, isFriendly) {
    const targets = isFriendly ? this.enemyTanks.children : this.friendlyTanks.children;
    let nearest = null;
    let minDistance = Infinity;

    targets.forEach(target => {
      const distance = Math.sqrt(
        Math.pow(target.x - tank.x, 2) + 
        Math.pow(target.y - tank.y, 2)
      );
      if (distance < minDistance) {
        minDistance = distance;
        nearest = target;
      }
    });

    if (nearest && minDistance <= (isFriendly ? this.tankRange : INITIAL_VALUES.TANK_RANGE)) {
      this.createProjectile(tank, nearest, isFriendly);
    }
  }

  createProjectile(source, target, isFriendly) {
    const projectile = new PIXI.Graphics();
    projectile.beginFill(isFriendly ? 0x00ff00 : 0xff0000);
    projectile.drawCircle(0, 0, 3);
    projectile.endFill();
    projectile.x = source.x;
    projectile.y = source.y;
    
    const angle = Math.atan2(target.y - source.y, target.x - source.x);
    projectile.dx = Math.cos(angle) * INITIAL_VALUES.PROJECTILE_SPEED;
    projectile.dy = Math.sin(angle) * INITIAL_VALUES.PROJECTILE_SPEED;
    projectile.isFriendly = isFriendly;
    projectile.damage = isFriendly ? this.tankDamage : INITIAL_VALUES.TANK_DAMAGE;
    
    this.projectiles.addChild(projectile);
  }

  moveProjectiles(elapsedSecs) {
    this.projectiles.children.forEach(projectile => {
      projectile.x += projectile.dx * elapsedSecs;
      projectile.y += projectile.dy * elapsedSecs;

      if (projectile.x < 0 || projectile.x > SCREEN_SIZE.width ||
          projectile.y < 0 || projectile.y > SCREEN_SIZE.height) {
        this.projectiles.removeChild(projectile);
      }
    });
  }

  checkProjectileCollisions() {
    this.projectiles.children.forEach(projectile => {
      const targets = projectile.isFriendly ? this.enemyTanks : this.friendlyTanks;
      
      targets.children.forEach(tank => {
        const dx = projectile.x - tank.x;
        const dy = projectile.y - tank.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < tank.width / 3) {
          tank.health -= projectile.damage;
          this.projectiles.removeChild(projectile);

          if (tank.health <= 0) {
            targets.removeChild(tank);
            if (!projectile.isFriendly) {
              this.spawnFriendlyTank(this.friendlyTanks.children.length);
            } else {
              this.credits += INITIAL_VALUES.CREDITS_PER_KILL;
              this.spawnEnemyTank(this.enemyTanks.children.length);
            }
          }
        }
      });
    });
  }

  upgradeTankCount() {
    if (this.credits >= this.tankCountCost) {
      this.credits -= this.tankCountCost;
      this.tankCount++;
      this.spawnFriendlyTank(this.friendlyTanks.children.length);
      this.tankCountCost *= 2;
    }
  }

  upgradeTankDamage() {
    if (this.credits >= this.tankDamageCost) {
      this.credits -= this.tankDamageCost;
      this.tankDamage *= 1.2;
      this.tankDamageCost *= 2;
    }
  }

  upgradeFireRate() {
    if (this.credits >= this.fireRateCost) {
      this.credits -= this.fireRateCost;
      this.fireRate *= 1.2;
      this.fireRateCost *= 2;
    }
  }

  upgradeTankHealth() {
    if (this.credits >= this.tankHealthCost) {
      this.credits -= this.tankHealthCost;
      this.tankHealth *= 1.2;
      this.tankHealthCost *= 2;
    }
  }

  upgradeTankRange() {
    if (this.credits >= this.tankRangeCost) {
      this.credits -= this.tankRangeCost;
      this.tankRange *= 1.2;
      this.tankRangeCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: 0da17f8e-5699-4623-88ac-5c6b475821ee
```javascript src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
    position: 'relative',
  }}>
    {children} ({cost} credits)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Credits: {Math.floor(game.credits)} | Tanks: {game.tankCount} | Damage: {game.tankDamage.toFixed(1)} | Fire Rate: {game.fireRate.toFixed(1)} | Health: {game.tankHealth.toFixed(0)} | Range: {game.tankRange.toFixed(0)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeTankCount()} cost={game.tankCountCost}>Add Tank</Button>
        <Button onClick={() => game.upgradeTankDamage()} cost={game.tankDamageCost}>Upgrade Damage</Button>
        <Button onClick={() => game.upgradeFireRate()} cost={game.fireRateCost}>Upgrade Fire Rate</Button>
        <Button onClick={() => game.upgradeTankHealth()} cost={game.tankHealthCost}>Upgrade Health</Button>
        <Button onClick={() => game.upgradeTankRange()} cost={game.tankRangeCost}>Upgrade Range</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the requested features:
1. Auto-playing idle game with upgrades
2. Tank spawning and movement to battle positions
3. Automatic combat system
4. Credit accumulation from destroying enemy tanks
5. All five requested upgrades
6. Proper scaling of upgrade costs
7. Automated enemy respawning
8. Clear UI showing all relevant information

The game should run smoothly with proper timing and collision detection while following all the implementation guidelines.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
