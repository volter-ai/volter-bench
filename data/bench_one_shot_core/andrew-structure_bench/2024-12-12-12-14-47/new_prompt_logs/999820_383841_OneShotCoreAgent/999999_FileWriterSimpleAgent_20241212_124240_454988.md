Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data (gameData.js):
- Define initial values for paddle size, ball speed, points multiplier, paddle speed
- Define base upgrade costs and cost multiplier (2x)

2. Asset Manifest (assetManifest.js):
- Add paddle and ball sprites
- Keep background

3. Game Logic (gameLogic.js):
- Track score, upgrade levels and costs
- Create paddles container and balls container
- Implement paddle AI movement toward nearest ball
- Handle ball movement, bouncing, scoring
- Ball speed acceleration over time
- Reset ball to center when scored
- Points earned on paddle hits
- Upgrade functions for each attribute

4. Game UI (GameUI.js):
- Display current score
- Show upgrade buttons with costs
- Display current level of each upgrade
- Show stats like points per hit, ball speed etc

Now let's implement each file:

# Excerpt ID: 593ee312-c90d-400c-80e0-dd2fbb523b5f
```js src/game/gameData.js
export const INITIAL_VALUES = {
  PADDLE_SIZE: 100,
  BALL_SPEED: 200,
  PADDLE_SPEED: 300,
  POINTS_MULTIPLIER: 1,
  BALL_COUNT: 1,
};

export const UPGRADE_COSTS = {
  PADDLE_SIZE: 10,
  BALL_SPEED: 15,
  MULTI_BALL: 50,
  POINTS_MULTIPLIER: 25,
  PADDLE_SPEED: 20,
};

export const GAME_CONFIG = {
  PADDLE_WIDTH: 20,
  BALL_SIZE: 16,
  BALL_ACCELERATION: 1.1,
  BASE_POINTS: 1,
};
```

# Excerpt ID: 3780a807-b30e-4e26-b95d-9e3535d07e78
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  paddle: {
    path: 'assets/paddle.png',
    width: 20,
    height: 100
  },
  ball: {
    path: 'assets/ball.png',
    width: 16,
    height: 16
  }
};
```

# Excerpt ID: afc39e47-18ae-4426-b678-0e2f6caabdc3
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAME_CONFIG } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;
    this.paddleSize = INITIAL_VALUES.PADDLE_SIZE;
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.pointsMultiplier = INITIAL_VALUES.POINTS_MULTIPLIER;
    this.ballCount = INITIAL_VALUES.BALL_COUNT;

    this.paddleSizeCost = UPGRADE_COSTS.PADDLE_SIZE;
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.multiBallCost = UPGRADE_COSTS.MULTI_BALL;
    this.pointsMultiplierCost = UPGRADE_COSTS.POINTS_MULTIPLIER;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    
    this.paddles = new PIXI.Container();
    this.balls = new PIXI.Container();

    // Create left paddle
    this.leftPaddle = this.getSprite(SPRITES.paddle);
    this.leftPaddle.x = 50;
    this.leftPaddle.y = SCREEN_SIZE.height / 2;
    this.leftPaddle.anchor.set(0.5);
    
    // Create right paddle
    this.rightPaddle = this.getSprite(SPRITES.paddle);
    this.rightPaddle.x = SCREEN_SIZE.width - 50;
    this.rightPaddle.y = SCREEN_SIZE.height / 2;
    this.rightPaddle.anchor.set(0.5);

    this.paddles.addChild(this.leftPaddle);
    this.paddles.addChild(this.rightPaddle);

    this.createBall();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.paddles);
    this.app.stage.addChild(this.balls);
  }

  createBall() {
    const ball = this.getSprite(SPRITES.ball);
    ball.anchor.set(0.5);
    this.resetBall(ball);
    ball.currentSpeed = this.ballSpeed;
    this.balls.addChild(ball);
  }

  resetBall(ball) {
    ball.x = SCREEN_SIZE.width / 2;
    ball.y = SCREEN_SIZE.height / 2;
    const angle = (Math.random() * Math.PI / 2) - Math.PI / 4;
    ball.dx = Math.cos(angle) * (Math.random() < 0.5 ? 1 : -1);
    ball.dy = Math.sin(angle);
    ball.currentSpeed = this.ballSpeed;
  }

  gameLoop(delta) {
    const elapsedSecs = delta / 60;
    
    // Move paddles
    [this.leftPaddle, this.rightPaddle].forEach(paddle => {
      let nearestBall = null;
      let nearestDist = Infinity;
      
      this.balls.children.forEach(ball => {
        const dist = Math.abs(ball.y - paddle.y);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestBall = ball;
        }
      });

      if (nearestBall) {
        const targetY = nearestBall.y;
        const dy = targetY - paddle.y;
        const moveAmount = Math.min(Math.abs(dy), this.paddleSpeed * elapsedSecs);
        paddle.y += Math.sign(dy) * moveAmount;
      }

      paddle.y = Math.max(paddle.height/2, Math.min(SCREEN_SIZE.height - paddle.height/2, paddle.y));
    });

    // Move balls
    this.balls.children.forEach(ball => {
      ball.x += ball.dx * ball.currentSpeed * elapsedSecs;
      ball.y += ball.dy * ball.currentSpeed * elapsedSecs;

      // Bounce off top/bottom
      if (ball.y < 0 || ball.y > SCREEN_SIZE.height) {
        ball.dy *= -1;
      }

      // Check paddle collisions
      [this.leftPaddle, this.rightPaddle].forEach(paddle => {
        if (this.checkCollision(ball, paddle)) {
          ball.dx *= -1;
          ball.currentSpeed *= GAME_CONFIG.BALL_ACCELERATION;
          this.score += GAME_CONFIG.BASE_POINTS * this.pointsMultiplier;
        }
      });

      // Score/Reset
      if (ball.x < 0 || ball.x > SCREEN_SIZE.width) {
        this.resetBall(ball);
      }
    });
  }

  checkCollision(ball, paddle) {
    return ball.x > paddle.x - paddle.width/2 &&
           ball.x < paddle.x + paddle.width/2 &&
           ball.y > paddle.y - paddle.height/2 &&
           ball.y < paddle.y + paddle.height/2;
  }

  upgradePaddleSize() {
    if (this.score >= this.paddleSizeCost) {
      this.score -= this.paddleSizeCost;
      this.paddleSize += 20;
      this.leftPaddle.height = this.paddleSize;
      this.rightPaddle.height = this.paddleSize;
      this.paddleSizeCost *= 2;
    }
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed *= 1.2;
      this.ballSpeedCost *= 2;
    }
  }

  upgradeMultiBall() {
    if (this.score >= this.multiBallCost) {
      this.score -= this.multiBallCost;
      this.ballCount++;
      this.createBall();
      this.multiBallCost *= 2;
    }
  }

  upgradePointsMultiplier() {
    if (this.score >= this.pointsMultiplierCost) {
      this.score -= this.pointsMultiplierCost;
      this.pointsMultiplier *= 2;
      this.pointsMultiplierCost *= 2;
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed *= 1.2;
      this.paddleSpeedCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: 77ed5a7f-13d4-4c0d-a448-ee6bc2ac6977
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} points)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Score: {game.score}</p>
    <p>Paddle Size: {game.paddleSize} | Ball Speed: {game.ballSpeed.toFixed(1)} | Balls: {game.ballCount} | Points Multiplier: {game.pointsMultiplier}x | Paddle Speed: {game.paddleSpeed.toFixed(1)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradePaddleSize()} cost={game.paddleSizeCost}>Upgrade Paddle Size</Button>
        <Button onClick={() => game.upgradeBallSpeed()} cost={game.ballSpeedCost}>Upgrade Ball Speed</Button>
        <Button onClick={() => game.upgradeMultiBall()} cost={game.multiBallCost}>Add Ball</Button>
        <Button onClick={() => game.upgradePointsMultiplier()} cost={game.pointsMultiplierCost}>Upgrade Points Multiplier</Button>
        <Button onClick={() => game.upgradePaddleSpeed()} cost={game.paddleSpeedCost}>Upgrade Paddle Speed</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation follows all the requirements from the overview document:
1. Automated paddle movement tracking nearest ball
2. Multiple balls possible through upgrades
3. Ball speed acceleration until scored
4. Points earned on paddle hits
5. All 5 specified upgrades implemented with doubling costs
6. Proper time-based movement using elapsed seconds
7. Appropriate sprite sizes (paddles and balls are visible)
8. Complete UI showing all stats and upgrade buttons

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
