Role: system
Content: You are an expert software developer. Your job is to make an existing simple UI look like the UI from an advanced video game
__________________
Role: user
Content: The existing codebase of the project is as follows:
```js src/Game.js
import React, { useRef, useState, useEffect } from 'react';
import { Settings } from 'lucide-react';
import { GameLogic } from './game/gameLogic';
import GameUI from './ui/GameUI';
import DebugUI from './ui/DebugUI';

const FRAME_RATE = 30;
const FRAME_INTERVAL = 1000 / FRAME_RATE;

const Game = () => {
  const containerRef = useRef(null);
  const gameRef = useRef(null);
  const [showDebugUI, setShowDebugUI] = useState(false);
  const [, setFrame] = useState(0);

  useEffect(() => {
    if (!containerRef.current) return;

    const game = new GameLogic(containerRef.current);
    window.game = game;
    gameRef.current = game;

    let lastTime = Date.now();
    let intervalId;
    const update = (currentTime) => {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // Force a re-render by updating the frame state
      setFrame(prevFrame => prevFrame + 1);
    };

    intervalId = setInterval(() => {
      update(Date.now());
    }, FRAME_INTERVAL);

    return () => {
      clearInterval(intervalId);
      if (gameRef.current) {
        gameRef.current.destroy();
        gameRef.current = null;
      }
      gameRef.current = null;
    };
  }, []);

  return (
    <div style={{
      position: 'relative',
      width: '800px',
      height: '600px',
      overflow: 'hidden'
    }}>
      <div ref={containerRef} style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%'
      }} />
      {gameRef.current && (
        <>
          <GameUI gameRef={gameRef} />
          {showDebugUI && <DebugUI gameRef={gameRef} />}
        </>
      )}
      <Settings
        onClick={() => setShowDebugUI(!showDebugUI)}
        style={{
          position: 'absolute',
          bottom: '10px',
          right: '10px',
          width: '24px',
          height: '24px',
          cursor: 'pointer',
          color: 'white'
        }}
      />
    </div>
  );
};

export default Game;
```
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;  // Changed from this.coins to this.score
    this.runnerSpeed = INITIAL_VALUES.RUNNER_SPEED;
    this.coinSpawnRate = INITIAL_VALUES.COIN_SPAWN_RATE;
    this.coinValue = INITIAL_VALUES.COIN_VALUE;
    this.runnerCount = INITIAL_VALUES.RUNNER_COUNT;
    this.trackWidth = INITIAL_VALUES.TRACK_WIDTH;
    
    this.runnerSpeedCost = UPGRADE_COSTS.RUNNER_SPEED;
    this.coinSpawnRateCost = UPGRADE_COSTS.COIN_SPAWN_RATE;
    this.coinValueCost = UPGRADE_COSTS.COIN_VALUE;
    this.runnerCountCost = UPGRADE_COSTS.RUNNER_COUNT;
    this.trackWidthCost = UPGRADE_COSTS.TRACK_WIDTH;

    this.coinSpawnTimer = 0;
    this.lastTimestamp = performance.now();

    this.textures = {};

    const loader = PIXI.Loader.shared;
    
    if (SPRITES) {
      for (const key in SPRITES) {
        loader.add(key, SPRITES[key].path);
      }
    }

    loader.load((loader, resources) => {
      if (!resources) return;
      
      for (const key in SPRITES) {
        if (resources[key] && resources[key].texture) {
          this.textures[key] = resources[key].texture;
        }
      }

      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteKey) {
    if (!this.textures[spriteKey]) {
      console.error(`Texture not found for key: ${spriteKey}`);
      return new PIXI.Sprite();
    }
    const sprite = new PIXI.Sprite(this.textures[spriteKey]);
    sprite.width = SPRITES[spriteKey].width;
    sprite.height = SPRITES[spriteKey].height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite('background');
    this.runners = new PIXI.Container();
    this.coinsContainer = new PIXI.Container();  // Renamed to coinsContainer

    this.createRunner();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.runners);
    this.app.stage.addChild(this.coinsContainer);  // Updated reference
  }

  createRunner() {
    const runner = this.getSprite('runner');
    runner.anchor.set(0.5);
    runner.x = 0;
    runner.y = SCREEN_SIZE.height/2 + (Math.random() - 0.5) * 200;
    this.runners.addChild(runner);
  }

  createCoin() {
    const coin = this.getSprite('coin');
    coin.anchor.set(0.5);
    coin.x = Math.random() * this.trackWidth;
    coin.y = SCREEN_SIZE.height/2 + (Math.random() - 0.5) * 200;
    this.coinsContainer.addChild(coin);  // Updated reference
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    if (this.runners && this.runners.children) {
      this.runners.children.forEach(runner => {
        runner.x += this.runnerSpeed * elapsedSecs;
        if (runner.x > SCREEN_SIZE.width) {
          runner.x = 0;
        }
      });
    }

    this.coinSpawnTimer += elapsedSecs;
    if (this.coinSpawnTimer >= 1/this.coinSpawnRate) {
      this.createCoin();
      this.coinSpawnTimer = 0;
    }

    if (this.runners && this.runners.children && this.coinsContainer && this.coinsContainer.children) {
      this.runners.children.forEach(runner => {
        this.coinsContainer.children.forEach(coin => {  // Updated reference
          if (this.checkCollision(runner, coin)) {
            this.coinsContainer.removeChild(coin);  // Updated reference
            this.score += this.coinValue;  // Updated to use score
          }
        });
      });
    }
  }

  checkCollision(obj1, obj2) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (obj1.width/2 + obj2.width/2);
  }

  upgradeRunnerSpeed() {
    if (this.score >= this.runnerSpeedCost) {  // Updated to use score
      this.score -= this.runnerSpeedCost;
      this.runnerSpeed *= 1.2;
      this.runnerSpeedCost *= 2;
    }
  }

  upgradeCoinSpawnRate() {
    if (this.score >= this.coinSpawnRateCost) {  // Updated to use score
      this.score -= this.coinSpawnRateCost;
      this.coinSpawnRate *= 1.2;
      this.coinSpawnRateCost *= 2;
    }
  }

  upgradeCoinValue() {
    if (this.score >= this.coinValueCost) {  // Updated to use score
      this.score -= this.coinValueCost;
      this.coinValue *= 1.5;
      this.coinValueCost *= 2;
    }
  }

  upgradeRunnerCount() {
    if (this.score >= this.runnerCountCost) {  // Updated to use score
      this.score -= this.runnerCountCost;
      this.runnerCount++;
      this.createRunner();
      this.runnerCountCost *= 2;
    }
  }

  upgradeTrackWidth() {
    if (this.score >= this.trackWidthCost) {  // Updated to use score
      this.score -= this.trackWidthCost;
      this.trackWidth *= 1.2;
      this.trackWidthCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}

```
```js src/game/gameData.js
export const INITIAL_VALUES = {
  RUNNER_SPEED: 100, // pixels per second
  COIN_SPAWN_RATE: 1, // coins per second
  COIN_VALUE: 1,
  RUNNER_COUNT: 1,
  TRACK_WIDTH: 600
};

export const UPGRADE_COSTS = {
  RUNNER_SPEED: 10,
  COIN_SPAWN_RATE: 15,
  COIN_VALUE: 20,
  RUNNER_COUNT: 25,
  TRACK_WIDTH: 50
};

```
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  runner: {
    path: 'assets/runner.png',
    width: 64,
    height: 64
  },
  coin: {
    path: 'assets/coin.png',
    width: 32,
    height: 32
  }
};

```
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    backgroundColor: '#4CAF50',
    border: 'none',
    color: 'white',
    cursor: 'pointer'
  }}>
    {children} ({cost} coins)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: 'white' }}>
    <p>Coins: {Math.floor(game.score)} | Runners: {game.runnerCount} | Speed: {game.runnerSpeed.toFixed(1)} | Coin Value: {game.coinValue.toFixed(1)} | Spawn Rate: {game.coinSpawnRate.toFixed(1)}/s | Track Width: {Math.floor(game.trackWidth)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%'}}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeRunnerSpeed()} cost={game.runnerSpeedCost}>Upgrade Runner Speed</Button>
        <Button onClick={() => game.upgradeCoinSpawnRate()} cost={game.coinSpawnRateCost}>Upgrade Spawn Rate</Button>
        <Button onClick={() => game.upgradeCoinValue()} cost={game.coinValueCost}>Upgrade Coin Value</Button>
        <Button onClick={() => game.upgradeRunnerCount()} cost={game.runnerCountCost}>Add Runner</Button>
        <Button onClick={() => game.upgradeTrackWidth()} cost={game.trackWidthCost}>Expand Track</Button>
      </div>
    </div>
  );
};

export default GameUI;

```
```js src/game/fontManifest.js
export const FONTS = [
  'Press Start 2P',
  'Roboto:400,700',
  'Orbitron:400,700',
]
```

Only make changes to the GameUI or fontManifest file. Don't change anything about the logic or functionality but make the UI look much better and make it feel like a very well implemented game. You can add multilayered menu interactions.


Make sure that only the essential data (such as currency) is shown in the hud and the other stats are hidden in a stats modal

Upgrades should be in modals and submenus instead of being directly on the screen


Make sure that the theme of your UI matches with the theme of the game

Make sure all modals can be opened and closed

General Implementation Guidelines:
1. Write out all the code of the files you intend to edit. I will be copy-pasting them
2. Do not create new files, add to the existing files in the appropriate locations
3. Do not do any refactoring outside of what you are requested to do

Directions:
In your response, do both steps, one after the other
1. First think carefully and describe in detail how you will implement the game design. Make sure to follow all the guidelines
2. Then write each file, according to the plan

Write out all the files in the format:
```filetype filepath
content
```

MOST IMPORTANT: Do not write "existing code here" or similar placeholders. If a file has been edited in anyway,
EVERY original unchanged line must be rewritten in your output
__________________
Role: assistant
Content: Let me plan out the UI improvements:

1. Theme Analysis:
- The game appears to be a runner/collector game
- Will use a futuristic/cyber theme with neon colors and sleek interfaces
- Primary colors: Deep blues, neon cyan, electric purple

2. UI Structure:
- Clean, minimal HUD showing only score
- Main menu button in top-right corner
- Three main modals:
  a. Stats Panel: Shows detailed runner/game statistics
  b. Upgrades Panel: Categorized upgrades (Runner, Economy, Track)
  c. Settings Panel (already implemented with gear icon)

3. Specific Improvements:
- Add smooth transitions for modals
- Use Orbitron font for headers, Roboto for body text
- Add hover effects and visual feedback
- Implement nested upgrade categories
- Add tooltips for upgrade explanations

4. Modal System:
- Implement a modal manager to handle multiple modals
- Add overlay backdrop
- Smooth animations for opening/closing
- Close buttons and escape key functionality

Here are the complete file implementations:

```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';
import { Settings, X, Activity, ArrowUp, Layout } from 'lucide-react';

const Modal = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) return null;
  
  return (
    <div style={{
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.7)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 1000,
    }}>
      <div style={{
        backgroundColor: '#1a1a2e',
        borderRadius: '8px',
        padding: '20px',
        minWidth: '300px',
        maxWidth: '600px',
        border: '1px solid #4a4a6a',
        boxShadow: '0 0 20px rgba(0,0,0,0.5)',
        color: '#fff',
        fontFamily: 'Roboto, sans-serif',
      }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
          <h2 style={{ margin: 0, fontFamily: 'Orbitron, sans-serif', color: '#00ff9d' }}>{title}</h2>
          <X onClick={onClose} style={{ cursor: 'pointer', color: '#888' }} />
        </div>
        {children}
      </div>
    </div>
  );
};

const Button = ({ onClick, children, cost, disabled }) => (
  <button 
    onClick={onClick} 
    disabled={disabled}
    style={{
      margin: '5px',
      padding: '10px 15px',
      backgroundColor: disabled ? '#2a2a3e' : '#2a2a8e',
      border: 'none',
      borderRadius: '4px',
      color: disabled ? '#666' : 'white',
      cursor: disabled ? 'not-allowed' : 'pointer',
      fontFamily: 'Roboto, sans-serif',
      transition: 'all 0.2s',
      width: '100%',
      textAlign: 'left',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
    }}
  >
    <span>{children}</span>
    <span style={{ 
      backgroundColor: disabled ? '#1a1a2e' : '#1a1a4e',
      padding: '4px 8px',
      borderRadius: '4px',
      fontSize: '0.9em'
    }}>
      {cost} coins
    </span>
  </button>
);

const HUD = ({ game }) => (
  <div style={{ 
    position: 'absolute', 
    top: '20px', 
    left: '20px', 
    padding: '10px 20px', 
    backgroundColor: 'rgba(26,26,46,0.9)', 
    color: '#00ff9d',
    borderRadius: '8px',
    fontFamily: 'Orbitron, sans-serif',
    fontSize: '1.2em',
    boxShadow: '0 0 10px rgba(0,255,157,0.2)',
  }}>
    <p style={{ margin: 0 }}>Score: {Math.floor(game.score)}</p>
  </div>
);

const MenuButton = ({ icon: Icon, onClick, style }) => (
  <button onClick={onClick} style={{
    backgroundColor: 'rgba(26,26,46,0.9)',
    border: 'none',
    borderRadius: '8px',
    padding: '10px',
    cursor: 'pointer',
    color: '#00ff9d',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    transition: 'all 0.2s',
    ...style,
  }}>
    <Icon size={24} />
  </button>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  const [showStats, setShowStats] = useState(false);
  const [showUpgrades, setShowUpgrades] = useState(false);
  
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;
  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%'}}>
      <HUD game={game} />
      
      <div style={{ 
        position: 'absolute', 
        top: '20px', 
        right: '20px',
        display: 'flex',
        gap: '10px',
      }}>
        <MenuButton icon={Activity} onClick={() => setShowStats(true)} />
        <MenuButton icon={ArrowUp} onClick={() => setShowUpgrades(true)} />
      </div>

      <Modal isOpen={showStats} onClose={() => setShowStats(false)} title="Statistics">
        <div style={{ display: 'grid', gap: '10px' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', padding: '10px', backgroundColor: '#2a2a3e', borderRadius: '4px' }}>
            <span>Runners</span>
            <span>{game.runnerCount}</span>
          </div>
          <div style={{ display: 'flex', justifyContent: 'space-between', padding: '10px', backgroundColor: '#2a2a3e', borderRadius: '4px' }}>
            <span>Speed</span>
            <span>{game.runnerSpeed.toFixed(1)}</span>
          </div>
          <div style={{ display: 'flex', justifyContent: 'space-between', padding: '10px', backgroundColor: '#2a2a3e', borderRadius: '4px' }}>
            <span>Coin Value</span>
            <span>{game.coinValue.toFixed(1)}</span>
          </div>
          <div style={{ display: 'flex', justifyContent: 'space-between', padding: '10px', backgroundColor: '#2a2a3e', borderRadius: '4px' }}>
            <span>Spawn Rate</span>
            <span>{game.coinSpawnRate.toFixed(1)}/s</span>
          </div>
          <div style={{ display: 'flex', justifyContent: 'space-between', padding: '10px', backgroundColor: '#2a2a3e', borderRadius: '4px' }}>
            <span>Track Width</span>
            <span>{Math.floor(game.trackWidth)}</span>
          </div>
        </div>
      </Modal>

      <Modal isOpen={showUpgrades} onClose={() => setShowUpgrades(false)} title="Upgrades">
        <div style={{ display: 'grid', gap: '15px' }}>
          <div>
            <h3 style={{ color: '#00ff9d', fontFamily: 'Orbitron, sans-serif', fontSize: '1em', marginBottom: '10px' }}>Runner Upgrades</h3>
            <Button onClick={() => game.upgradeRunnerSpeed()} cost={game.runnerSpeedCost} disabled={game.score < game.runnerSpeedCost}>
              Upgrade Runner Speed
            </Button>
            <Button onClick={() => game.upgradeRunnerCount()} cost={game.runnerCountCost} disabled={game.score < game.runnerCountCost}>
              Add Runner
            </Button>
          </div>
          
          <div>
            <h3 style={{ color: '#00ff9d', fontFamily: 'Orbitron, sans-serif', fontSize: '1em', marginBottom: '10px' }}>Economy Upgrades</h3>
            <Button onClick={() => game.upgradeCoinSpawnRate()} cost={game.coinSpawnRateCost} disabled={game.score < game.coinSpawnRateCost}>
              Upgrade Spawn Rate
            </Button>
            <Button onClick={() => game.upgradeCoinValue()} cost={game.coinValueCost} disabled={game.score < game.coinValueCost}>
              Upgrade Coin Value
            </Button>
          </div>
          
          <div>
            <h3 style={{ color: '#00ff9d', fontFamily: 'Orbitron, sans-serif', fontSize: '1em', marginBottom: '10px' }}>Track Upgrades</h3>
            <Button onClick={() => game.upgradeTrackWidth()} cost={game.trackWidthCost} disabled={game.score < game.trackWidthCost}>
              Expand Track
            </Button>
          </div>
        </div>
      </Modal>
    </div>
  );
};

export default GameUI;
```

```js src/game/fontManifest.js
export const FONTS = [
  'Orbitron:400,700',
  'Roboto:400,700'
];
```

These changes create a sleek, futuristic UI with better organization and visual hierarchy. The HUD is minimized to show only essential information, while detailed stats and upgrades are accessible through well-designed modals.
__________________
