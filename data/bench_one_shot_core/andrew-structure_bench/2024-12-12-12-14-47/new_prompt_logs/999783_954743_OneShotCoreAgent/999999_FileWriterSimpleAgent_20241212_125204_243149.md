Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data Requirements:
- Initial values for tank attributes (speed, health, damage, etc)
- Base upgrade costs
- Screen dimensions and gameplay constants

2. Asset Requirements:
- Tank sprite (friendly)
- Enemy tank sprite
- Background
- Health bar graphics

3. Game Logic Implementation:
- Tank class with properties: health, speed, damage, position, rotation
- Spawn system for enemy tanks at screen edges
- Movement system with constant velocity
- Target acquisition system (find nearest enemy)
- Combat system with health bars
- Upgrade system affecting tank attributes
- Credit/scoring system

4. UI Requirements:
- Display current credits
- Show upgrade buttons with costs
- Display current stats

Now, let's implement the files:

# Excerpt ID: 5e38b507-0d13-42a6-b148-4a8dba755fc1
```js src/game/gameData.js
export const INITIAL_VALUES = {
  TANK_SPEED: 100, // pixels per second
  TANK_HEALTH: 100,
  TANK_DAMAGE: 20,
  TANK_FIRE_RATE: 1, // shots per second
  TANK_RANGE: 200,
  TANK_COUNT: 1,
  ENEMY_SPAWN_RATE: 2, // seconds between spawns
  ENEMY_SPEED: 60,
  ENEMY_HEALTH: 100,
  ENEMY_DAMAGE: 15,
  CREDITS_PER_KILL: 10
};

export const UPGRADE_COSTS = {
  TANK_SPEED: 10,
  TANK_HEALTH: 15,
  TANK_DAMAGE: 20,
  TANK_FIRE_RATE: 25,
  TANK_RANGE: 30,
  TANK_COUNT: 50
};
```

# Excerpt ID: 28925f17-f318-477e-bb04-2c153904b32d
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  friendlyTank: {
    path: 'assets/friendly_tank.png',
    width: 64,
    height: 64
  },
  enemyTank: {
    path: 'assets/enemy_tank.png',
    width: 64,
    height: 64
  }
};
```

# Excerpt ID: ce1f17ef-ad11-4e7c-af3b-a00485cae742
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.credits = 0;
    this.lastTimestamp = performance.now();
    
    // Game attributes
    this.tankSpeed = INITIAL_VALUES.TANK_SPEED;
    this.tankHealth = INITIAL_VALUES.TANK_HEALTH;
    this.tankDamage = INITIAL_VALUES.TANK_DAMAGE;
    this.tankFireRate = INITIAL_VALUES.TANK_FIRE_RATE;
    this.tankRange = INITIAL_VALUES.TANK_RANGE;
    this.tankCount = INITIAL_VALUES.TANK_COUNT;

    // Upgrade costs
    this.tankSpeedCost = UPGRADE_COSTS.TANK_SPEED;
    this.tankHealthCost = UPGRADE_COSTS.TANK_HEALTH;
    this.tankDamageCost = UPGRADE_COSTS.TANK_DAMAGE;
    this.tankFireRateCost = UPGRADE_COSTS.TANK_FIRE_RATE;
    this.tankRangeCost = UPGRADE_COSTS.TANK_RANGE;
    this.tankCountCost = UPGRADE_COSTS.TANK_COUNT;

    // Timers
    this.enemySpawnTimer = 0;

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.friendlyTanks = new PIXI.Container();
    this.enemyTanks = new PIXI.Container();
    this.bullets = new PIXI.Container();
    
    // Create initial friendly tanks
    for (let i = 0; i < this.tankCount; i++) {
      this.createFriendlyTank();
    }

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.friendlyTanks);
    this.app.stage.addChild(this.enemyTanks);
    this.app.stage.addChild(this.bullets);
  }

  createFriendlyTank() {
    const tank = this.getSprite(SPRITES.friendlyTank);
    tank.anchor.set(0.5);
    tank.x = SCREEN_SIZE.width / 2 + (Math.random() - 0.5) * 100;
    tank.y = SCREEN_SIZE.height / 2 + (Math.random() - 0.5) * 100;
    tank.health = this.tankHealth;
    tank.fireTimer = 0;
    
    // Create health bar
    tank.healthBar = new PIXI.Graphics();
    tank.healthBar.y = -40;
    tank.addChild(tank.healthBar);
    this.updateHealthBar(tank);
    
    this.friendlyTanks.addChild(tank);
  }

  createEnemyTank() {
    const tank = this.getSprite(SPRITES.enemyTank);
    tank.anchor.set(0.5);
    
    // Spawn at random edge position
    const side = Math.floor(Math.random() * 4);
    switch(side) {
      case 0: // top
        tank.x = Math.random() * SCREEN_SIZE.width;
        tank.y = -32;
        break;
      case 1: // right
        tank.x = SCREEN_SIZE.width + 32;
        tank.y = Math.random() * SCREEN_SIZE.height;
        break;
      case 2: // bottom
        tank.x = Math.random() * SCREEN_SIZE.width;
        tank.y = SCREEN_SIZE.height + 32;
        break;
      case 3: // left
        tank.x = -32;
        tank.y = Math.random() * SCREEN_SIZE.height;
        break;
    }
    
    tank.health = INITIAL_VALUES.ENEMY_HEALTH;
    
    // Create health bar
    tank.healthBar = new PIXI.Graphics();
    tank.healthBar.y = -40;
    tank.addChild(tank.healthBar);
    this.updateHealthBar(tank);
    
    this.enemyTanks.addChild(tank);
  }

  updateHealthBar(tank) {
    const maxHealth = tank.parent === this.friendlyTanks ? this.tankHealth : INITIAL_VALUES.ENEMY_HEALTH;
    const width = 50;
    const height = 5;
    
    tank.healthBar.clear();
    tank.healthBar.beginFill(0xff0000);
    tank.healthBar.drawRect(-width/2, 0, width, height);
    tank.healthBar.beginFill(0x00ff00);
    tank.healthBar.drawRect(-width/2, 0, (tank.health/maxHealth) * width, height);
  }

  createBullet(shooter, target) {
    const bullet = new PIXI.Graphics();
    bullet.beginFill(0xffff00);
    bullet.drawCircle(0, 0, 3);
    bullet.endFill();
    
    bullet.x = shooter.x;
    bullet.y = shooter.y;
    bullet.rotation = Math.atan2(target.y - shooter.y, target.x - shooter.x);
    bullet.speed = 300;
    bullet.damage = shooter.parent === this.friendlyTanks ? this.tankDamage : INITIAL_VALUES.ENEMY_DAMAGE;
    
    this.bullets.addChild(bullet);
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Spawn enemies
    this.enemySpawnTimer += elapsedSecs;
    if (this.enemySpawnTimer >= INITIAL_VALUES.ENEMY_SPAWN_RATE) {
      this.createEnemyTank();
      this.enemySpawnTimer = 0;
    }

    // Update friendly tanks
    this.friendlyTanks.children.forEach(tank => {
      tank.fireTimer += elapsedSecs;
      
      // Find nearest enemy
      let nearestEnemy = null;
      let nearestDistance = Infinity;
      
      this.enemyTanks.children.forEach(enemy => {
        const dx = enemy.x - tank.x;
        const dy = enemy.y - tank.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      });

      if (nearestEnemy) {
        // Rotate towards enemy
        const angle = Math.atan2(nearestEnemy.y - tank.y, nearestEnemy.x - tank.x);
        tank.rotation = angle;
        
        // Move if not in range
        if (nearestDistance > this.tankRange) {
          tank.x += Math.cos(angle) * this.tankSpeed * elapsedSecs;
          tank.y += Math.sin(angle) * this.tankSpeed * elapsedSecs;
        }
        
        // Fire if in range and timer expired
        if (nearestDistance <= this.tankRange && tank.fireTimer >= 1/this.tankFireRate) {
          this.createBullet(tank, nearestEnemy);
          tank.fireTimer = 0;
        }
      }
    });

    // Update enemy tanks
    this.enemyTanks.children.forEach(tank => {
      const angle = Math.atan2(SCREEN_SIZE.height/2 - tank.y, SCREEN_SIZE.width/2 - tank.x);
      tank.rotation = angle;
      tank.x += Math.cos(angle) * INITIAL_VALUES.ENEMY_SPEED * elapsedSecs;
      tank.y += Math.sin(angle) * INITIAL_VALUES.ENEMY_SPEED * elapsedSecs;
    });

    // Update bullets
    this.bullets.children.forEach(bullet => {
      bullet.x += Math.cos(bullet.rotation) * bullet.speed * elapsedSecs;
      bullet.y += Math.sin(bullet.rotation) * bullet.speed * elapsedSecs;
      
      // Remove if off screen
      if (bullet.x < -10 || bullet.x > SCREEN_SIZE.width + 10 ||
          bullet.y < -10 || bullet.y > SCREEN_SIZE.height + 10) {
        this.bullets.removeChild(bullet);
      }
    });

    // Check collisions
    this.checkCollisions();
  }

  checkCollisions() {
    this.bullets.children.forEach(bullet => {
      const targets = bullet.damage === this.tankDamage ? this.enemyTanks : this.friendlyTanks;
      
      targets.children.forEach(tank => {
        const dx = bullet.x - tank.x;
        const dy = bullet.y - tank.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 32) {
          tank.health -= bullet.damage;
          this.updateHealthBar(tank);
          this.bullets.removeChild(bullet);
          
          if (tank.health <= 0) {
            if (targets === this.enemyTanks) {
              this.credits += INITIAL_VALUES.CREDITS_PER_KILL;
            }
            targets.removeChild(tank);
          }
        }
      });
    });
  }

  upgradeTankSpeed() {
    if (this.credits >= this.tankSpeedCost) {
      this.credits -= this.tankSpeedCost;
      this.tankSpeed *= 1.1;
      this.tankSpeedCost *= 2;
    }
  }

  upgradeTankHealth() {
    if (this.credits >= this.tankHealthCost) {
      this.credits -= this.tankHealthCost;
      this.tankHealth *= 1.1;
      this.tankHealthCost *= 2;
      
      // Update existing tanks
      this.friendlyTanks.children.forEach(tank => {
        tank.health *= 1.1;
        this.updateHealthBar(tank);
      });
    }
  }

  upgradeTankDamage() {
    if (this.credits >= this.tankDamageCost) {
      this.credits -= this.tankDamageCost;
      this.tankDamage *= 1.1;
      this.tankDamageCost *= 2;
    }
  }

  upgradeTankFireRate() {
    if (this.credits >= this.tankFireRateCost) {
      this.credits -= this.tankFireRateCost;
      this.tankFireRate *= 1.1;
      this.tankFireRateCost *= 2;
    }
  }

  upgradeTankRange() {
    if (this.credits >= this.tankRangeCost) {
      this.credits -= this.tankRangeCost;
      this.tankRange *= 1.1;
      this.tankRangeCost *= 2;
    }
  }

  upgradeTankCount() {
    if (this.credits >= this.tankCountCost) {
      this.credits -= this.tankCountCost;
      this.tankCount++;
      this.createFriendlyTank();
      this.tankCountCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: 179d722a-9483-4fb5-a00f-81f861835d04
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
    position: 'relative',
  }}>
    {children} ({cost} credits)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Credits: {game.credits} | Tanks: {game.tankCount} | Speed: {game.tankSpeed.toFixed(1)} | Health: {game.tankHealth.toFixed(0)} | Damage: {game.tankDamage.toFixed(1)} | Fire Rate: {game.tankFireRate.toFixed(1)} | Range: {game.tankRange.toFixed(0)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeTankCount()} cost={game.tankCountCost}>Add Tank</Button>
        <Button onClick={() => game.upgradeTankSpeed()} cost={game.tankSpeedCost}>Upgrade Speed</Button>
        <Button onClick={() => game.upgradeTankHealth()} cost={game.tankHealthCost}>Upgrade Health</Button>
        <Button onClick={() => game.upgradeTankDamage()} cost={game.tankDamageCost}>Upgrade Damage</Button>
        <Button onClick={() => game.upgradeTankFireRate()} cost={game.tankFireRateCost}>Upgrade Fire Rate</Button>
        <Button onClick={() => game.upgradeTankRange()} cost={game.tankRangeCost}>Upgrade Range</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the requested features:
1. Auto-playing tanks that target nearest enemies
2. Enemy tanks spawning at edges and moving toward center
3. Health bars for all tanks
4. Credit system for destroying enemies
5. All six requested upgrades
6. Proper movement and rotation
7. Constant speed movement
8. Doubling upgrade costs
9. Range-based shooting
10. Full UI with current stats and upgrade buttons

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
