Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data Requirements:
- Initial values for baristas, machines, speeds, space, quality
- Base costs and multipliers for upgrades
- Movement speeds and positions
- Timer values for customer spawning and coffee preparation

2. Game Logic Implementation:
- Track money, entities and their states
- Create containers for customers, baristas, machines
- Implement movement system between fixed points
- Handle customer spawning, queueing, and serving
- Manage coffee preparation and sales
- Implement all upgrade systems

3. Sprite Requirements:
- Background with counter and entrance/exit areas
- Customer sprite
- Barista sprite
- Coffee machine sprite

Now I'll implement the files:

# Excerpt ID: 4a910350-1fb1-41f7-a3b6-b106ea4fd63a
```js src/game/gameData.js
export const INITIAL_VALUES = {
  BARISTA_COUNT: 1,
  MACHINE_COUNT: 1,
  BARISTA_SPEED: 100, // pixels per second
  MAX_CUSTOMERS: 5,
  COFFEE_QUALITY: 1,
  COFFEE_PREP_TIME: 3, // seconds
  CUSTOMER_SPAWN_TIME: 2, // seconds
  CUSTOMER_PATIENCE: 20, // seconds
  BASE_COFFEE_PRICE: 5,
};

export const UPGRADE_COSTS = {
  BARISTA: 100,
  MACHINE: 200,
  SPEED: 150,
  SPACE: 300,
  QUALITY: 250,
};

export const POSITIONS = {
  ENTRANCE: { x: 50, y: 500 },
  COUNTER: { x: 300, y: 300 },
  EXIT: { x: 750, y: 500 },
  MACHINE_START: { x: 500, y: 100 }, // First machine position
  MACHINE_SPACING: 100, // Horizontal space between machines
};
```

# Excerpt ID: 88f30d9a-1e54-4ed5-b4a8-1669a8b4f968
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/coffee_shop.png',
    width: 800,
    height: 600
  },
  customer: {
    path: 'assets/customer.png',
    width: 64,
    height: 64
  },
  barista: {
    path: 'assets/barista.png',
    width: 64,
    height: 64
  },
  machine: {
    path: 'assets/coffee_machine.png',
    width: 64,
    height: 64
  }
};
```

# Excerpt ID: e45d07cd-ff5a-4224-946f-3c31fe45e8df
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, POSITIONS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils';

const SCREEN_SIZE = {
  width: 800,
  height: 600
};

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.money = 0;
    this.baristaCount = INITIAL_VALUES.BARISTA_COUNT;
    this.machineCount = INITIAL_VALUES.MACHINE_COUNT;
    this.baristaSpeed = INITIAL_VALUES.BARISTA_SPEED;
    this.maxCustomers = INITIAL_VALUES.MAX_CUSTOMERS;
    this.coffeeQuality = INITIAL_VALUES.COFFEE_QUALITY;
    
    this.customerSpawnTimer = 0;
    this.lastTimestamp = performance.now();

    this.upgradeCosts = {
      barista: UPGRADE_COSTS.BARISTA,
      machine: UPGRADE_COSTS.MACHINE,
      speed: UPGRADE_COSTS.SPEED,
      space: UPGRADE_COSTS.SPACE,
      quality: UPGRADE_COSTS.QUALITY
    };

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.customers = new PIXI.Container();
    this.baristas = new PIXI.Container();
    this.machines = new PIXI.Container();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.customers);
    this.app.stage.addChild(this.baristas);
    this.app.stage.addChild(this.machines);

    // Create initial baristas and machines
    for (let i = 0; i < this.baristaCount; i++) {
      this.createBarista();
    }
    for (let i = 0; i < this.machineCount; i++) {
      this.createMachine(i);
    }
  }

  createCustomer() {
    const customer = this.getSprite(SPRITES.customer);
    customer.anchor.set(0.5);
    customer.x = POSITIONS.ENTRANCE.x;
    customer.y = POSITIONS.ENTRANCE.y;
    customer.state = 'moving_to_counter';
    customer.waitTime = 0;
    this.customers.addChild(customer);
  }

  createBarista() {
    const barista = this.getSprite(SPRITES.barista);
    barista.anchor.set(0.5);
    barista.x = POSITIONS.COUNTER.x;
    barista.y = POSITIONS.COUNTER.y;
    barista.state = 'idle';
    barista.targetMachine = null;
    barista.targetCustomer = null;
    this.baristas.addChild(barista);
  }

  createMachine(index) {
    const machine = this.getSprite(SPRITES.machine);
    machine.anchor.set(0.5);
    machine.x = POSITIONS.MACHINE_START.x + (index * POSITIONS.MACHINE_SPACING);
    machine.y = POSITIONS.MACHINE_START.y;
    machine.inUse = false;
    this.machines.addChild(machine);
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    this.customerSpawnTimer += elapsedSecs;
    if (this.customerSpawnTimer >= INITIAL_VALUES.CUSTOMER_SPAWN_TIME && 
        this.customers.children.length < this.maxCustomers) {
      this.createCustomer();
      this.customerSpawnTimer = 0;
    }

    this.updateCustomers(elapsedSecs);
    this.updateBaristas(elapsedSecs);
  }

  updateCustomers(elapsedSecs) {
    this.customers.children.forEach(customer => {
      if (customer.state === 'moving_to_counter') {
        const dx = POSITIONS.COUNTER.x - customer.x;
        const dy = POSITIONS.COUNTER.y - customer.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 5) {
          customer.x += (dx / distance) * INITIAL_VALUES.BARISTA_SPEED * elapsedSecs;
          customer.y += (dy / distance) * INITIAL_VALUES.BARISTA_SPEED * elapsedSecs;
        } else {
          customer.state = 'waiting';
        }
      } else if (customer.state === 'leaving') {
        const dx = POSITIONS.EXIT.x - customer.x;
        const dy = POSITIONS.EXIT.y - customer.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 5) {
          customer.x += (dx / distance) * INITIAL_VALUES.BARISTA_SPEED * elapsedSecs;
          customer.y += (dy / distance) * INITIAL_VALUES.BARISTA_SPEED * elapsedSecs;
        } else {
          this.customers.removeChild(customer);
        }
      } else if (customer.state === 'waiting') {
        customer.waitTime += elapsedSecs;
        if (customer.waitTime >= INITIAL_VALUES.CUSTOMER_PATIENCE) {
          customer.state = 'leaving';
        }
      }
    });
  }

  updateBaristas(elapsedSecs) {
    this.baristas.children.forEach(barista => {
      if (barista.state === 'idle') {
        const waitingCustomer = this.customers.children.find(c => c.state === 'waiting' && !c.beingServed);
        const freeMachine = this.machines.children.find(m => !m.inUse);
        
        if (waitingCustomer && freeMachine) {
          barista.state = 'moving_to_machine';
          barista.targetMachine = freeMachine;
          barista.targetCustomer = waitingCustomer;
          waitingCustomer.beingServed = true;
          freeMachine.inUse = true;
        }
      } else if (barista.state === 'moving_to_machine') {
        const dx = barista.targetMachine.x - barista.x;
        const dy = barista.targetMachine.y - barista.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 5) {
          barista.x += (dx / distance) * this.baristaSpeed * elapsedSecs;
          barista.y += (dy / distance) * this.baristaSpeed * elapsedSecs;
        } else {
          barista.state = 'preparing';
          barista.prepTime = 0;
        }
      } else if (barista.state === 'preparing') {
        barista.prepTime += elapsedSecs;
        if (barista.prepTime >= INITIAL_VALUES.COFFEE_PREP_TIME) {
          barista.state = 'serving';
        }
      } else if (barista.state === 'serving') {
        const dx = POSITIONS.COUNTER.x - barista.x;
        const dy = POSITIONS.COUNTER.y - barista.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 5) {
          barista.x += (dx / distance) * this.baristaSpeed * elapsedSecs;
          barista.y += (dy / distance) * this.baristaSpeed * elapsedSecs;
        } else {
          this.money += INITIAL_VALUES.BASE_COFFEE_PRICE * this.coffeeQuality;
          barista.targetMachine.inUse = false;
          barista.targetCustomer.state = 'leaving';
          barista.state = 'idle';
          barista.targetMachine = null;
          barista.targetCustomer = null;
        }
      }
    });
  }

  upgradeBaristas() {
    if (this.money >= this.upgradeCosts.barista) {
      this.money -= this.upgradeCosts.barista;
      this.createBarista();
      this.baristaCount++;
      this.upgradeCosts.barista *= 2;
    }
  }

  upgradeMachines() {
    if (this.money >= this.upgradeCosts.machine) {
      this.money -= this.upgradeCosts.machine;
      this.createMachine(this.machineCount);
      this.machineCount++;
      this.upgradeCosts.machine *= 2;
    }
  }

  upgradeSpeed() {
    if (this.money >= this.upgradeCosts.speed) {
      this.money -= this.upgradeCosts.speed;
      this.baristaSpeed *= 1.2;
      this.upgradeCosts.speed *= 2;
    }
  }

  upgradeSpace() {
    if (this.money >= this.upgradeCosts.space) {
      this.money -= this.upgradeCosts.space;
      this.maxCustomers += 2;
      this.upgradeCosts.space *= 2;
    }
  }

  upgradeQuality() {
    if (this.money >= this.upgradeCosts.quality) {
      this.money -= this.upgradeCosts.quality;
      this.coffeeQuality *= 1.2;
      this.upgradeCosts.quality *= 2;
    }
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: c0b92522-a432-4fd4-948f-a03be86e9812
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} (${cost})
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Money: ${Math.floor(game.money)} | Customers: {game.customers.children.length}/{game.maxCustomers} | 
       Baristas: {game.baristaCount} | Machines: {game.machineCount}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeBaristas()} cost={game.upgradeCosts.barista}>Hire Barista</Button>
        <Button onClick={() => game.upgradeMachines()} cost={game.upgradeCosts.machine}>Add Machine</Button>
        <Button onClick={() => game.upgradeSpeed()} cost={game.upgradeCosts.speed}>Faster Baristas</Button>
        <Button onClick={() => game.upgradeSpace()} cost={game.upgradeCosts.space}>Larger Shop</Button>
        <Button onClick={() => game.upgradeQuality()} cost={game.upgradeCosts.quality}>Better Coffee</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the required features:
- Automated coffee shop with customers, baristas, and machines
- Movement system between fixed points
- Customer spawning and queueing system
- Coffee preparation and serving mechanics
- Money earning system
- All five upgrades with doubling costs
- Complete UI with money display and upgrade buttons

The game will need appropriate sprite assets for the background, customers, baristas, and coffee machines to work properly.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
