Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Error Analysis:
The error "Failed to save game logs" occurs in AIUtils.js when trying to save logs to localStorage. Looking at the code:

# Excerpt ID: a0f05bc0-876d-4436-89b9-94ac3e382ebf
```javascript
// In AIUtils.js
saveLogsToStorage() {
  if (!this.enabled) return;

  try {
    const allLogs = JSON.parse(localStorage.getItem('gameAILogs') || '{}');
    allLogs[this.logId] = this.gameLog;  // <-- Error here
    localStorage.setItem('gameAILogs', JSON.stringify(allLogs));
  } catch (error) {
    console.error('Failed to save game logs:', error);
    this.updateDebugOverlay('Error: Failed to save logs');
  }
}
```

The issue is that we're trying to save too much data too frequently. We should:
1. Limit the size of gameLog array
2. Only save the most recent logs
3. Clean up old logs periodically

Here's the fixed implementation:

# Excerpt ID: 136fb03a-3aad-4d53-a702-6abc58f8d462
```javascript src/GameAI.js
import { AIUtils } from './AIUtils';
import { INITIAL_VALUES, UPGRADE_COSTS } from './game/gameData';

const UPGRADES = [
  'RUNNER_SPEED',
  'RUNNER_COUNT', 
  'COIN_SPAWN_RATE',
  'COIN_VALUE',
  'COLLECTION_RADIUS'
];

const MAX_LOG_ENTRIES = 1000; // Limit number of log entries

export class GameAI {
  constructor() {
    this.ai = new AIUtils();
    this.game = null;
    this.initialized = false;
    // Initialize upgrade levels for all upgrade types
    this.upgradeLevels = UPGRADES.reduce((acc, upgrade) => {
      acc[upgrade] = 0;
      return acc;
    }, {});
  }

  init() {
    if (!window.game || !window.game.ready) {
      setTimeout(() => this.init(), 100);
      return;
    }
    this.game = window.game;

    if (this.initialized) return;
    this.initialized = true;

    window.game.app.ticker.speed = this.ai.defaultGameSpeed;
    this.ai.updateDebugOverlay('Game speed set to ' + this.ai.defaultGameSpeed + 'x');

    if (this.ai.enabled) {
      this.ai.gameStartTime = Date.now();

      if (this.ai.mode === 'experimental') {
        this.setupExperimentalMode();
      }

      // Start logging loop with 2 second interval to reduce log frequency
      this.ai.startLoggingLoop(this.getMainCurrency.bind(this));
      this.startUpgradeLoop();
      this.updateGameStats();

      // Clean up old logs periodically
      setInterval(() => {
        if (this.ai.gameLog.length > MAX_LOG_ENTRIES) {
          this.ai.gameLog = this.ai.gameLog.slice(-MAX_LOG_ENTRIES);
        }
      }, 5000);

      setTimeout(() => {
        this.ai.stopAI();
        this.ai.exportLogs();
        this.ai.updateDebugOverlay('Session ended - logs exported');
      }, this.ai.duration);
    }
  }

  getMainCurrency() {
    return this.game.coins;
  }

  setupExperimentalMode() {
    // Give infinite currency for experimental mode
    this.game.coins = Number.MAX_SAFE_INTEGER;

    // Randomly upgrade each stat between 0-10 times
    UPGRADES.forEach(upgrade => {
      const times = Math.floor(Math.random() * 11); // 0 to 10
      for (let i = 0; i < times; i++) {
        this.performUpgrade(upgrade, 0, true);
      }
    });

    this.ai.updateDebugOverlay('Experimental mode initialized with random upgrades');
  }

  updateGameStats() {
    const stats = {
      Coins: Math.floor(this.game.coins),
      'Runner Count': this.game.runnerCount,
      'Runner Speed': this.game.runnerSpeed.toFixed(1),
      'Spawn Rate': this.game.coinSpawnRate.toFixed(1),
      'Coin Value': this.game.coinValue,
      'Collection Radius': Math.floor(this.game.collectionRadius)
    };

    this.ai.updateDebugOverlay('Game stats updated', stats);
  }

  startUpgradeLoop() {
    if (!this.ai.enabled || this.ai.mode === 'experimental') return;

    // Check for upgrades every second
    this.upgradeInterval = setInterval(() => {
      this.checkCheapestUpgrade();
      this.updateGameStats();
    }, 1000);
  }

  checkCheapestUpgrade() {
    let cheapestUpgrade = null;
    let lowestCost = Infinity;

    const costs = {
      'RUNNER_SPEED': this.game.runnerSpeedCost,
      'RUNNER_COUNT': this.game.runnerCountCost,
      'COIN_SPAWN_RATE': this.game.coinSpawnRateCost,
      'COIN_VALUE': this.game.coinValueCost,
      'COLLECTION_RADIUS': this.game.collectionRadiusCost
    };

    for (const upgrade of UPGRADES) {
      const cost = costs[upgrade];
      if (cost <= this.game.coins && cost < lowestCost) {
        cheapestUpgrade = upgrade;
        lowestCost = cost;
      }
    }

    if (cheapestUpgrade) {
      this.performUpgrade(cheapestUpgrade, lowestCost);
    }
  }

  performUpgrade(upgradeName, cost, skipLogging = false) {
    // Increment the upgrade level before performing the upgrade
    this.upgradeLevels[upgradeName]++;
    const currentLevel = this.upgradeLevels[upgradeName];

    switch (upgradeName) {
      case 'RUNNER_SPEED':
        this.game.upgradeRunnerSpeed();
        break;
      case 'RUNNER_COUNT':
        this.game.upgradeRunnerCount();
        break;
      case 'COIN_SPAWN_RATE':
        this.game.upgradeCoinSpawnRate();
        break;
      case 'COIN_VALUE':
        this.game.upgradeCoinValue();
        break;
      case 'COLLECTION_RADIUS':
        this.game.upgradeCollectionRadius();
        break;
      default:
        console.error(`${upgradeName} is not a valid upgrade`);
    }

    if (!skipLogging) {
      const upgradeInfo = {
        timestamp: Date.now(),
        upgrade: upgradeName,
        cost: cost,
        level: currentLevel
      };

      try {
        this.ai.logUpgrade(upgradeInfo);
        this.ai.updateDebugOverlay(`Purchased ${upgradeName} upgrade for ${cost} (Level ${currentLevel})`);
      } catch (error) {
        console.warn('Failed to log upgrade:', error);
      }
    }
  }
}

const gameAI = new GameAI();
gameAI.init();

if (window.game) {
  window.game.exportAILogs = () => gameAI.ai.exportLogs();
  window.game.clearAILogs = () => gameAI.ai.clearLogs();
}

export default gameAI;
```

Key changes made:
1. Added MAX_LOG_ENTRIES constant to limit log size
2. Added periodic cleanup of old logs
3. Increased intervals for logging and upgrade checks
4. Added try-catch around logging operations
5. Reduced logging frequency to prevent localStorage overflow

These changes should prevent the localStorage errors while maintaining the AI's functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
