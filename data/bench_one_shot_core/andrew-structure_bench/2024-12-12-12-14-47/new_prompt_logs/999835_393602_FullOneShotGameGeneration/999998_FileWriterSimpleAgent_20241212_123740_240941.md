Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Implementation Plan:
- The game is a coin collection game where runners move across the screen collecting coins
- There are 5 upgrades available:
  * RUNNER_SPEED: Makes runners move faster
  * RUNNER_COUNT: Adds more runners
  * COIN_SPAWN_RATE: Spawns coins more frequently
  * COIN_VALUE: Makes each coin worth more
  * COLLECTION_RADIUS: Makes it easier to collect coins

For the GameAI implementation:
1. Define UPGRADES array with all 5 upgrade types
2. getMainCurrency() will return game.coins
3. For experimental mode:
   - Set coins to max value
   - Randomly apply 0-10 upgrades of each type
4. updateGameStats() will show:
   - Current coins
   - Runner count and speed
   - Coin spawn rate and value
   - Collection radius
5. checkCheapestUpgrade() will:
   - Check cost of each upgrade
   - Buy the cheapest one if enough coins available
6. performUpgrade() will:
   - Call appropriate game upgrade method
   - Track upgrade level
   - Log the upgrade

Now, let's implement the code:

# Excerpt ID: 0695cf4c-5eb9-4656-93c7-6c76425db322
```javascript src/GameAI.js
import { AIUtils } from './AIUtils';
import { INITIAL_VALUES, UPGRADE_COSTS } from './game/gameData';

const UPGRADES = [
  'RUNNER_SPEED',
  'RUNNER_COUNT', 
  'COIN_SPAWN_RATE',
  'COIN_VALUE',
  'COLLECTION_RADIUS'
];

export class GameAI {
  constructor() {
    this.ai = new AIUtils();
    this.game = null;
    this.initialized = false;
    // Initialize upgrade levels for all upgrade types
    this.upgradeLevels = UPGRADES.reduce((acc, upgrade) => {
      acc[upgrade] = 0;
      return acc;
    }, {});
  }

  init() {
    if (!window.game || !window.game.ready) {
      setTimeout(() => this.init(), 100);
      return;
    }
    this.game = window.game;

    if (this.initialized) return;
    this.initialized = true;

    window.game.app.ticker.speed = this.ai.defaultGameSpeed;
    this.ai.updateDebugOverlay('Game speed set to ' + this.ai.defaultGameSpeed + 'x');

    if (this.ai.enabled) {
      this.ai.gameStartTime = Date.now();

      if (this.ai.mode === 'experimental') {
        this.setupExperimentalMode();
      }

      this.ai.startLoggingLoop(this.getMainCurrency.bind(this));
      this.startUpgradeLoop();
      this.updateGameStats();

      setTimeout(() => {
        this.ai.stopAI();
        this.ai.exportLogs();
        this.ai.updateDebugOverlay('Session ended - logs exported');
      }, this.ai.duration);
    }
  }

  getMainCurrency() {
    return this.game.coins;
  }

  setupExperimentalMode() {
    // Give infinite currency for experimental mode
    this.game.coins = Number.MAX_SAFE_INTEGER;

    // Randomly upgrade each stat between 0-10 times
    UPGRADES.forEach(upgrade => {
      const times = Math.floor(Math.random() * 11); // 0 to 10
      for (let i = 0; i < times; i++) {
        this.performUpgrade(upgrade, 0, true);
      }
    });

    this.ai.updateDebugOverlay('Experimental mode initialized with random upgrades');
  }

  updateGameStats() {
    const stats = {
      Coins: Math.floor(this.game.coins),
      'Runner Count': this.game.runnerCount,
      'Runner Speed': this.game.runnerSpeed.toFixed(1),
      'Spawn Rate': this.game.coinSpawnRate.toFixed(1),
      'Coin Value': this.game.coinValue,
      'Collection Radius': Math.floor(this.game.collectionRadius)
    };

    this.ai.updateDebugOverlay('Game stats updated', stats);
  }

  startUpgradeLoop() {
    if (!this.ai.enabled || this.ai.mode === 'experimental') return;

    this.upgradeInterval = setInterval(() => {
      this.checkCheapestUpgrade();
      this.updateGameStats();
    }, 100);
  }

  checkCheapestUpgrade() {
    let cheapestUpgrade = null;
    let lowestCost = Infinity;

    const costs = {
      'RUNNER_SPEED': this.game.runnerSpeedCost,
      'RUNNER_COUNT': this.game.runnerCountCost,
      'COIN_SPAWN_RATE': this.game.coinSpawnRateCost,
      'COIN_VALUE': this.game.coinValueCost,
      'COLLECTION_RADIUS': this.game.collectionRadiusCost
    };

    for (const upgrade of UPGRADES) {
      const cost = costs[upgrade];
      if (cost <= this.game.coins && cost < lowestCost) {
        cheapestUpgrade = upgrade;
        lowestCost = cost;
      }
    }

    if (cheapestUpgrade) {
      this.performUpgrade(cheapestUpgrade, lowestCost);
    }
  }

  performUpgrade(upgradeName, cost, skipLogging = false) {
    // Increment the upgrade level before performing the upgrade
    this.upgradeLevels[upgradeName]++;
    const currentLevel = this.upgradeLevels[upgradeName];

    switch (upgradeName) {
      case 'RUNNER_SPEED':
        this.game.upgradeRunnerSpeed();
        break;
      case 'RUNNER_COUNT':
        this.game.upgradeRunnerCount();
        break;
      case 'COIN_SPAWN_RATE':
        this.game.upgradeCoinSpawnRate();
        break;
      case 'COIN_VALUE':
        this.game.upgradeCoinValue();
        break;
      case 'COLLECTION_RADIUS':
        this.game.upgradeCollectionRadius();
        break;
      default:
        console.error(`${upgradeName} is not a valid upgrade`);
    }

    if (!skipLogging) {
      const upgradeInfo = {
        timestamp: Date.now(),
        upgrade: upgradeName,
        cost: cost,
        level: currentLevel
      };

      this.ai.logUpgrade(upgradeInfo);
      this.ai.updateDebugOverlay(`Purchased ${upgradeName} upgrade for ${cost} (Level ${currentLevel})`);
    }
  }
}

const gameAI = new GameAI();
gameAI.init();

if (window.game) {
  window.game.exportAILogs = () => gameAI.ai.exportLogs();
  window.game.clearAILogs = () => gameAI.ai.clearLogs();
}

export default gameAI;
```

This implementation:
1. Defines all 5 upgrade types
2. Tracks upgrade levels
3. In experimental mode, randomly applies upgrades
4. In normal mode, continuously buys the cheapest available upgrade
5. Logs all game stats and upgrades
6. Properly interfaces with the AIUtils class for logging and UI updates

The AI will automatically play the game by purchasing upgrades as soon as enough coins are available, prioritizing the cheapest upgrades first. In experimental mode, it will randomly apply upgrades to test different configurations.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
