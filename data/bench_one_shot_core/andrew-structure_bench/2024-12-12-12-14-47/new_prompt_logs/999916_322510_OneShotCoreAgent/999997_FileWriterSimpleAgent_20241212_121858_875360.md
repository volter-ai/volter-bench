Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me trace the error:

The error occurs in utils.js when trying to access resources.default.texture and ASSET_MANIFEST[key].path. This suggests:

1. The utils.js file is missing from our implementation
2. The loadAssets function is trying to use an ASSET_MANIFEST variable but we're passing SPRITES
3. The resource loader expects a different format than what we're providing

The fix is to implement utils.js properly and ensure it matches the format expected by PIXI's resource loader:

# Excerpt ID: 9d8be333-4080-43e8-9868-b4537cffdb42
```javascript src/game/utils.js
import * as PIXI from 'pixi.js';

export const loadAssets = (sprites, onComplete) => {
  const loader = PIXI.Loader.shared;
  
  // Add each sprite to the loader
  Object.entries(sprites).forEach(([key, sprite]) => {
    loader.add(key, sprite.path);
  });

  loader.load((loader, resources) => {
    onComplete();
  });
};
```

# Excerpt ID: 6927c41b-d2f3-425a-8d01-1dac2341242f
```javascript src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, LOCATIONS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils';

const SCREEN_SIZE = {
  width: 800,
  height: 600
};

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.money = 0;
    this.coffeePrice = INITIAL_VALUES.COFFEE_PRICE;
    this.coffeeMakeSpeed = INITIAL_VALUES.COFFEE_MAKE_SPEED;
    this.baristaCount = INITIAL_VALUES.BARISTA_COUNT;
    this.customerCapacity = INITIAL_VALUES.CUSTOMER_CAPACITY;
    this.baristaEfficiency = INITIAL_VALUES.BARISTA_EFFICIENCY;

    this.coffeePriceCost = UPGRADE_COSTS.COFFEE_PRICE;
    this.coffeeSpeedCost = UPGRADE_COSTS.COFFEE_SPEED;
    this.baristaCountCost = UPGRADE_COSTS.BARISTA_COUNT;
    this.customerCapacityCost = UPGRADE_COSTS.CUSTOMER_CAPACITY;
    this.baristaEfficiencyCost = UPGRADE_COSTS.BARISTA_EFFICIENCY;

    // Initialize PIXI Loader if not already initialized
    if (!PIXI.Loader.shared.resources) {
      PIXI.Loader.shared.destroy();
      PIXI.Loader.shared = new PIXI.Loader();
    }

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Loader.shared.resources[spriteConfig.path].texture;
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  // ... rest of the GameLogic class implementation remains exactly the same ...
  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.app.stage.addChild(this.background);

    // Create containers
    this.stations = new PIXI.Container();
    this.baristas = new PIXI.Container();
    this.customers = new PIXI.Container();
    
    // Create fixed objects
    LOCATIONS.COFFEE_STATIONS.forEach(pos => {
      const station = this.getSprite(SPRITES.coffee_station);
      station.x = pos.x;
      station.y = pos.y;
      station.anchor.set(0.5);
      this.stations.addChild(station);
    });

    const counter = this.getSprite(SPRITES.counter);
    counter.x = LOCATIONS.COUNTER.x;
    counter.y = LOCATIONS.COUNTER.y;
    counter.anchor.set(0.5);

    const register = this.getSprite(SPRITES.register);
    register.x = LOCATIONS.REGISTER.x;
    register.y = LOCATIONS.REGISTER.y;
    register.anchor.set(0.5);

    // Add initial baristas
    for (let i = 0; i < this.baristaCount; i++) {
      this.createBarista();
    }

    this.app.stage.addChild(this.stations);
    this.app.stage.addChild(counter);
    this.app.stage.addChild(register);
    this.app.stage.addChild(this.baristas);
    this.app.stage.addChild(this.customers);

    this.lastTimestamp = performance.now();
    this.customerSpawnTimer = 0;
  }

  createBarista() {
    const barista = this.getSprite(SPRITES.barista);
    barista.anchor.set(0.5);
    const station = LOCATIONS.COFFEE_STATIONS[this.baristas.children.length % LOCATIONS.COFFEE_STATIONS.length];
    barista.x = station.x;
    barista.y = station.y;
    barista.state = 'making';
    barista.coffeeTimer = 0;
    barista.coffees = 0;
    this.baristas.addChild(barista);
  }

  createCustomer() {
    if (this.customers.children.length >= this.customerCapacity) return;
    
    const customer = this.getSprite(SPRITES.customer);
    customer.anchor.set(0.5);
    customer.x = LOCATIONS.ENTRANCE.x;
    customer.y = LOCATIONS.ENTRANCE.y;
    customer.state = 'moving_to_counter';
    this.customers.addChild(customer);
  }

  moveTowards(entity, target, speed, elapsedSecs) {
    const dx = target.x - entity.x;
    const dy = target.y - entity.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < 5) return true;

    const moveDistance = speed * elapsedSecs;
    const ratio = moveDistance / distance;
    
    entity.x += dx * ratio;
    entity.y += dy * ratio;
    
    return false;
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Spawn customers
    this.customerSpawnTimer += elapsedSecs;
    if (this.customerSpawnTimer >= 1) {
      this.createCustomer();
      this.customerSpawnTimer = 0;
    }

    // Update baristas
    this.baristas.children.forEach(barista => {
      switch (barista.state) {
        case 'making':
          barista.coffeeTimer += elapsedSecs;
          if (barista.coffeeTimer >= this.coffeeMakeSpeed) {
            barista.coffeeTimer = 0;
            barista.coffees = this.baristaEfficiency;
            barista.state = 'delivering';
          }
          break;
        case 'delivering':
          if (this.moveTowards(barista, LOCATIONS.COUNTER, INITIAL_VALUES.BARISTA_SPEED, elapsedSecs)) {
            barista.coffees = 0;
            barista.state = 'returning';
          }
          break;
        case 'returning':
          const station = LOCATIONS.COFFEE_STATIONS[this.baristas.children.indexOf(barista) % LOCATIONS.COFFEE_STATIONS.length];
          if (this.moveTowards(barista, station, INITIAL_VALUES.BARISTA_SPEED, elapsedSecs)) {
            barista.state = 'making';
          }
          break;
      }
    });

    // Update customers
    this.customers.children.forEach(customer => {
      switch (customer.state) {
        case 'moving_to_counter':
          if (this.moveTowards(customer, LOCATIONS.COUNTER, INITIAL_VALUES.CUSTOMER_SPEED, elapsedSecs)) {
            customer.state = 'moving_to_register';
          }
          break;
        case 'moving_to_register':
          if (this.moveTowards(customer, LOCATIONS.REGISTER, INITIAL_VALUES.CUSTOMER_SPEED, elapsedSecs)) {
            this.money += this.coffeePrice;
            customer.state = 'leaving';
          }
          break;
        case 'leaving':
          if (this.moveTowards(customer, LOCATIONS.EXIT, INITIAL_VALUES.CUSTOMER_SPEED, elapsedSecs)) {
            this.customers.removeChild(customer);
          }
          break;
      }
    });
  }

  upgradeCoffeePrice() {
    if (this.money >= this.coffeePriceCost) {
      this.money -= this.coffeePriceCost;
      this.coffeePrice *= 1.5;
      this.coffeePriceCost *= 2;
    }
  }

  upgradeCoffeeSpeed() {
    if (this.money >= this.coffeeSpeedCost) {
      this.money -= this.coffeeSpeedCost;
      this.coffeeMakeSpeed *= 0.8;
      this.coffeeSpeedCost *= 2;
    }
  }

  upgradeBaristaCount() {
    if (this.money >= this.baristaCountCost) {
      this.money -= this.baristaCountCost;
      this.baristaCount++;
      this.createBarista();
      this.baristaCountCost *= 2;
    }
  }

  upgradeCustomerCapacity() {
    if (this.money >= this.customerCapacityCost) {
      this.money -= this.customerCapacityCost;
      this.customerCapacity++;
      this.customerCapacityCost *= 2;
    }
  }

  upgradeBaristaEfficiency() {
    if (this.money >= this.baristaEfficiencyCost) {
      this.money -= this.baristaEfficiencyCost;
      this.baristaEfficiency++;
      this.baristaEfficiencyCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

The key changes are:
1. Added utils.js with proper PIXI loader implementation
2. Modified getSprite() to use PIXI.Loader.shared.resources correctly
3. Added loader initialization check in constructor

These changes should resolve the texture loading errors while maintaining all the game functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
