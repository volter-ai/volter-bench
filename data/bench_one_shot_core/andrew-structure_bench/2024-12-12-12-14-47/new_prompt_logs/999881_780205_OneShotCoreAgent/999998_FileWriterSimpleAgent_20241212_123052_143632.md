Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Design Implementation Plan:
- In gameData.js:
  - Define initial values for runner speed, coin spawn rate, etc
  - Define base costs and multipliers for upgrades

- In assetManifest.js:
  - Add sprites for runner character and coin

- In gameLogic.js:
  - Track state: coins collected, current values for all upgradeable attributes
  - Create containers for runners and coins
  - Implement runner movement system with wraparound
  - Implement coin spawning system with timer
  - Implement collision detection between runners and coins
  - Add upgrade methods that double costs after purchase
  - Track width will be implemented by adjusting the spawn area for coins

- In GameUI.js:
  - Display current coins and stats
  - Add upgrade buttons with costs
  - Update UI frequently to show new values

Now let's implement the files:

# Excerpt ID: 23ebe970-b969-4d36-9621-b7c58a92ab2a
```js src/game/gameData.js
export const INITIAL_VALUES = {
  RUNNER_SPEED: 100, // pixels per second
  COIN_SPAWN_RATE: 1, // coins per second
  COIN_VALUE: 1,
  RUNNER_COUNT: 1,
  TRACK_WIDTH: 600
};

export const UPGRADE_COSTS = {
  RUNNER_SPEED: 10,
  COIN_SPAWN_RATE: 15,
  COIN_VALUE: 20,
  RUNNER_COUNT: 25,
  TRACK_WIDTH: 50
};
```

# Excerpt ID: 26a5ff0d-2e49-42e8-9843-a06aab039fb5
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  runner: {
    path: 'assets/runner.png',
    width: 64,
    height: 64
  },
  coin: {
    path: 'assets/coin.png',
    width: 32,
    height: 32
  }
};
```

# Excerpt ID: 32566100-9c0f-4cb2-a24d-a25c4a900aac
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.coins = 0;
    this.runnerSpeed = INITIAL_VALUES.RUNNER_SPEED;
    this.coinSpawnRate = INITIAL_VALUES.COIN_SPAWN_RATE;
    this.coinValue = INITIAL_VALUES.COIN_VALUE;
    this.runnerCount = INITIAL_VALUES.RUNNER_COUNT;
    this.trackWidth = INITIAL_VALUES.TRACK_WIDTH;
    
    this.runnerSpeedCost = UPGRADE_COSTS.RUNNER_SPEED;
    this.coinSpawnRateCost = UPGRADE_COSTS.COIN_SPAWN_RATE;
    this.coinValueCost = UPGRADE_COSTS.COIN_VALUE;
    this.runnerCountCost = UPGRADE_COSTS.RUNNER_COUNT;
    this.trackWidthCost = UPGRADE_COSTS.TRACK_WIDTH;

    this.coinSpawnTimer = 0;
    this.lastTimestamp = performance.now();

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.runners = new PIXI.Container();
    this.coins = new PIXI.Container();

    // Create initial runner
    this.createRunner();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.runners);
    this.app.stage.addChild(this.coins);
  }

  createRunner() {
    const runner = this.getSprite(SPRITES.runner);
    runner.anchor.set(0.5);
    runner.x = 0;
    runner.y = SCREEN_SIZE.height/2 + (Math.random() - 0.5) * 200;
    this.runners.addChild(runner);
  }

  createCoin() {
    const coin = this.getSprite(SPRITES.coin);
    coin.anchor.set(0.5);
    coin.x = Math.random() * this.trackWidth;
    coin.y = SCREEN_SIZE.height/2 + (Math.random() - 0.5) * 200;
    this.coins.addChild(coin);
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Move runners
    this.runners.children.forEach(runner => {
      runner.x += this.runnerSpeed * elapsedSecs;
      if (runner.x > SCREEN_SIZE.width) {
        runner.x = 0;
      }
    });

    // Spawn coins
    this.coinSpawnTimer += elapsedSecs;
    if (this.coinSpawnTimer >= 1/this.coinSpawnRate) {
      this.createCoin();
      this.coinSpawnTimer = 0;
    }

    // Check collisions
    this.runners.children.forEach(runner => {
      this.coins.children.forEach(coin => {
        if (this.checkCollision(runner, coin)) {
          this.coins.removeChild(coin);
          this.coins += this.coinValue;
        }
      });
    });
  }

  checkCollision(obj1, obj2) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (obj1.width/2 + obj2.width/2);
  }

  upgradeRunnerSpeed() {
    if (this.coins >= this.runnerSpeedCost) {
      this.coins -= this.runnerSpeedCost;
      this.runnerSpeed *= 1.2;
      this.runnerSpeedCost *= 2;
    }
  }

  upgradeCoinSpawnRate() {
    if (this.coins >= this.coinSpawnRateCost) {
      this.coins -= this.coinSpawnRateCost;
      this.coinSpawnRate *= 1.2;
      this.coinSpawnRateCost *= 2;
    }
  }

  upgradeCoinValue() {
    if (this.coins >= this.coinValueCost) {
      this.coins -= this.coinValueCost;
      this.coinValue *= 1.5;
      this.coinValueCost *= 2;
    }
  }

  upgradeRunnerCount() {
    if (this.coins >= this.runnerCountCost) {
      this.coins -= this.runnerCountCost;
      this.runnerCount++;
      this.createRunner();
      this.runnerCountCost *= 2;
    }
  }

  upgradeTrackWidth() {
    if (this.coins >= this.trackWidthCost) {
      this.coins -= this.trackWidthCost;
      this.trackWidth *= 1.2;
      this.trackWidthCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: 98a73b15-a8d5-401f-9575-0bdc883f3e8a
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    backgroundColor: '#4CAF50',
    border: 'none',
    color: 'white',
    cursor: 'pointer'
  }}>
    {children} ({cost} coins)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: 'white' }}>
    <p>Coins: {Math.floor(game.coins)} | Runners: {game.runnerCount} | Speed: {game.runnerSpeed.toFixed(1)} | Coin Value: {game.coinValue.toFixed(1)} | Spawn Rate: {game.coinSpawnRate.toFixed(1)}/s | Track Width: {Math.floor(game.trackWidth)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%'}}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeRunnerSpeed()} cost={game.runnerSpeedCost}>Upgrade Runner Speed</Button>
        <Button onClick={() => game.upgradeCoinSpawnRate()} cost={game.coinSpawnRateCost}>Upgrade Spawn Rate</Button>
        <Button onClick={() => game.upgradeCoinValue()} cost={game.coinValueCost}>Upgrade Coin Value</Button>
        <Button onClick={() => game.upgradeRunnerCount()} cost={game.runnerCountCost}>Add Runner</Button>
        <Button onClick={() => game.upgradeTrackWidth()} cost={game.trackWidthCost}>Expand Track</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation:
1. Creates an auto-running game with runners collecting coins
2. Implements all 5 upgrades with doubling costs
3. Uses proper timing for movement and spawning
4. Handles collisions between runners and coins
5. Shows all relevant stats in the HUD
6. Provides upgrade buttons with costs
7. Follows the original game design exactly as specified

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
