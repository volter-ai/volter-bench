Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me trace the error:

The error occurs in utils.js when trying to access resources.default.texture and ASSET_MANIFEST[key].path. This suggests that the loadAssets function is not properly implemented in the codebase. Looking at the error stack trace, we need to implement the utils.js file which wasn't included in the original files.

Let's implement utils.js and fix the asset loading:

# Excerpt ID: 239ec3de-e84a-40d2-983f-802172f6a69d
```js src/game/utils.js
import * as PIXI from 'pixi.js';

export function loadAssets(sprites, onComplete) {
  const loader = PIXI.Loader.shared;
  
  // Add all sprites to loader
  Object.entries(sprites).forEach(([key, sprite]) => {
    loader.add(key, sprite.path);
  });

  // Start loading
  loader.load((loader, resources) => {
    onComplete();
  });
}
```

# Excerpt ID: 0576d0fe-c1d9-4ac4-81b2-bd1a2d6d8420
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.coins = 0;
    this.runnerSpeed = INITIAL_VALUES.RUNNER_SPEED;
    this.coinSpawnRate = INITIAL_VALUES.COIN_SPAWN_RATE;
    this.coinValue = INITIAL_VALUES.COIN_VALUE;
    this.runnerCount = INITIAL_VALUES.RUNNER_COUNT;
    this.trackWidth = INITIAL_VALUES.TRACK_WIDTH;
    
    this.runnerSpeedCost = UPGRADE_COSTS.RUNNER_SPEED;
    this.coinSpawnRateCost = UPGRADE_COSTS.COIN_SPAWN_RATE;
    this.coinValueCost = UPGRADE_COSTS.COIN_VALUE;
    this.runnerCountCost = UPGRADE_COSTS.RUNNER_COUNT;
    this.trackWidthCost = UPGRADE_COSTS.TRACK_WIDTH;

    this.coinSpawnTimer = 0;
    this.lastTimestamp = performance.now();

    // Load textures first
    PIXI.Loader.shared.add('runner', SPRITES.runner.path);
    PIXI.Loader.shared.add('coin', SPRITES.coin.path);
    PIXI.Loader.shared.add('background', SPRITES.background.path);
    
    PIXI.Loader.shared.load(() => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Loader.shared.resources[spriteConfig.path].texture;
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.runners = new PIXI.Container();
    this.coins = new PIXI.Container();

    // Create initial runner
    this.createRunner();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.runners);
    this.app.stage.addChild(this.coins);
  }

  createRunner() {
    const runner = this.getSprite(SPRITES.runner);
    runner.anchor.set(0.5);
    runner.x = 0;
    runner.y = SCREEN_SIZE.height/2 + (Math.random() - 0.5) * 200;
    this.runners.addChild(runner);
  }

  createCoin() {
    const coin = this.getSprite(SPRITES.coin);
    coin.anchor.set(0.5);
    coin.x = Math.random() * this.trackWidth;
    coin.y = SCREEN_SIZE.height/2 + (Math.random() - 0.5) * 200;
    this.coins.addChild(coin);
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Move runners
    this.runners.children.forEach(runner => {
      runner.x += this.runnerSpeed * elapsedSecs;
      if (runner.x > SCREEN_SIZE.width) {
        runner.x = 0;
      }
    });

    // Spawn coins
    this.coinSpawnTimer += elapsedSecs;
    if (this.coinSpawnTimer >= 1/this.coinSpawnRate) {
      this.createCoin();
      this.coinSpawnTimer = 0;
    }

    // Check collisions
    this.runners.children.forEach(runner => {
      this.coins.children.forEach(coin => {
        if (this.checkCollision(runner, coin)) {
          this.coins.removeChild(coin);
          this.coins += this.coinValue;
        }
      });
    });
  }

  checkCollision(obj1, obj2) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (obj1.width/2 + obj2.width/2);
  }

  upgradeRunnerSpeed() {
    if (this.coins >= this.runnerSpeedCost) {
      this.coins -= this.runnerSpeedCost;
      this.runnerSpeed *= 1.2;
      this.runnerSpeedCost *= 2;
    }
  }

  upgradeCoinSpawnRate() {
    if (this.coins >= this.coinSpawnRateCost) {
      this.coins -= this.coinSpawnRateCost;
      this.coinSpawnRate *= 1.2;
      this.coinSpawnRateCost *= 2;
    }
  }

  upgradeCoinValue() {
    if (this.coins >= this.coinValueCost) {
      this.coins -= this.coinValueCost;
      this.coinValue *= 1.5;
      this.coinValueCost *= 2;
    }
  }

  upgradeRunnerCount() {
    if (this.coins >= this.runnerCountCost) {
      this.coins -= this.runnerCountCost;
      this.runnerCount++;
      this.createRunner();
      this.runnerCountCost *= 2;
    }
  }

  upgradeTrackWidth() {
    if (this.coins >= this.trackWidthCost) {
      this.coins -= this.trackWidthCost;
      this.trackWidth *= 1.2;
      this.trackWidthCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

The key changes are:
1. Added utils.js with proper PIXI loader implementation
2. Modified gameLogic.js to use PIXI.Loader.shared directly instead of the utils function
3. Changed getSprite to use the loader resources correctly

This should resolve the texture loading errors while maintaining all the game functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
