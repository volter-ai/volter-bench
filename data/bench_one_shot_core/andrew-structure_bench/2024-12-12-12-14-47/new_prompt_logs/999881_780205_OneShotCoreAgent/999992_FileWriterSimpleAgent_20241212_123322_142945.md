Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let's trace the error:

1. Error Analysis:
The error "Cannot read properties of undefined (reading 'forEach')" typically occurs when trying to call forEach on an undefined object. Looking at the code, we're using forEach in two places:

# Excerpt ID: 963d5014-5a14-4b4d-9394-35728ebce511
```js
// In constructor:
Object.entries(SPRITES).forEach(([key, sprite]) => {
  loader.add(key, sprite.path);
});

// In loader callback:
Object.keys(SPRITES).forEach(key => {
  this.textures[key] = resources[key].texture;
});
```

The issue is that we're not properly handling the case where the loader resources might be undefined. We need to ensure the resources exist before trying to access them.

Let's fix the files:

# Excerpt ID: 104be31c-38f1-49dd-ba3e-eb356dc6df35
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.coins = 0;
    this.runnerSpeed = INITIAL_VALUES.RUNNER_SPEED;
    this.coinSpawnRate = INITIAL_VALUES.COIN_SPAWN_RATE;
    this.coinValue = INITIAL_VALUES.COIN_VALUE;
    this.runnerCount = INITIAL_VALUES.RUNNER_COUNT;
    this.trackWidth = INITIAL_VALUES.TRACK_WIDTH;
    
    this.runnerSpeedCost = UPGRADE_COSTS.RUNNER_SPEED;
    this.coinSpawnRateCost = UPGRADE_COSTS.COIN_SPAWN_RATE;
    this.coinValueCost = UPGRADE_COSTS.COIN_VALUE;
    this.runnerCountCost = UPGRADE_COSTS.RUNNER_COUNT;
    this.trackWidthCost = UPGRADE_COSTS.TRACK_WIDTH;

    this.coinSpawnTimer = 0;
    this.lastTimestamp = performance.now();

    // Initialize textures
    this.textures = {};

    // Load all textures first
    const loader = PIXI.Loader.shared;
    
    // Add each sprite to the loader
    if (SPRITES) {
      for (const key in SPRITES) {
        loader.add(key, SPRITES[key].path);
      }
    }

    loader.load((loader, resources) => {
      if (!resources) return;
      
      // Store all textures
      for (const key in SPRITES) {
        if (resources[key] && resources[key].texture) {
          this.textures[key] = resources[key].texture;
        }
      }

      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteKey) {
    if (!this.textures[spriteKey]) {
      console.error(`Texture not found for key: ${spriteKey}`);
      return new PIXI.Sprite();
    }
    const sprite = new PIXI.Sprite(this.textures[spriteKey]);
    sprite.width = SPRITES[spriteKey].width;
    sprite.height = SPRITES[spriteKey].height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite('background');
    this.runners = new PIXI.Container();
    this.coins = new PIXI.Container();

    // Create initial runner
    this.createRunner();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.runners);
    this.app.stage.addChild(this.coins);
  }

  createRunner() {
    const runner = this.getSprite('runner');
    runner.anchor.set(0.5);
    runner.x = 0;
    runner.y = SCREEN_SIZE.height/2 + (Math.random() - 0.5) * 200;
    this.runners.addChild(runner);
  }

  createCoin() {
    const coin = this.getSprite('coin');
    coin.anchor.set(0.5);
    coin.x = Math.random() * this.trackWidth;
    coin.y = SCREEN_SIZE.height/2 + (Math.random() - 0.5) * 200;
    this.coins.addChild(coin);
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Move runners
    if (this.runners && this.runners.children) {
      this.runners.children.forEach(runner => {
        runner.x += this.runnerSpeed * elapsedSecs;
        if (runner.x > SCREEN_SIZE.width) {
          runner.x = 0;
        }
      });
    }

    // Spawn coins
    this.coinSpawnTimer += elapsedSecs;
    if (this.coinSpawnTimer >= 1/this.coinSpawnRate) {
      this.createCoin();
      this.coinSpawnTimer = 0;
    }

    // Check collisions
    if (this.runners && this.runners.children && this.coins && this.coins.children) {
      this.runners.children.forEach(runner => {
        this.coins.children.forEach(coin => {
          if (this.checkCollision(runner, coin)) {
            this.coins.removeChild(coin);
            this.coins += this.coinValue;
          }
        });
      });
    }
  }

  checkCollision(obj1, obj2) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (obj1.width/2 + obj2.width/2);
  }

  upgradeRunnerSpeed() {
    if (this.coins >= this.runnerSpeedCost) {
      this.coins -= this.runnerSpeedCost;
      this.runnerSpeed *= 1.2;
      this.runnerSpeedCost *= 2;
    }
  }

  upgradeCoinSpawnRate() {
    if (this.coins >= this.coinSpawnRateCost) {
      this.coins -= this.coinSpawnRateCost;
      this.coinSpawnRate *= 1.2;
      this.coinSpawnRateCost *= 2;
    }
  }

  upgradeCoinValue() {
    if (this.coins >= this.coinValueCost) {
      this.coins -= this.coinValueCost;
      this.coinValue *= 1.5;
      this.coinValueCost *= 2;
    }
  }

  upgradeRunnerCount() {
    if (this.coins >= this.runnerCountCost) {
      this.coins -= this.runnerCountCost;
      this.runnerCount++;
      this.createRunner();
      this.runnerCountCost *= 2;
    }
  }

  upgradeTrackWidth() {
    if (this.coins >= this.trackWidthCost) {
      this.coins -= this.trackWidthCost;
      this.trackWidth *= 1.2;
      this.trackWidthCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

Key changes:
1. Replaced forEach loops with for...in loops for safer iteration
2. Added null checks before accessing children arrays
3. Added error handling in getSprite
4. Added checks for resources existence in loader callback
5. Added safety checks in gameLoop for containers and their children

These changes should prevent the "Cannot read properties of undefined" errors by ensuring we check for existence before accessing properties or calling methods.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
