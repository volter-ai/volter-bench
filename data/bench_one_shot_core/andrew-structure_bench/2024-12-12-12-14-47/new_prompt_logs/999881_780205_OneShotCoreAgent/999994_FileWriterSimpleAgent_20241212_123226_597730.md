Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let's trace the error:

1. Error Analysis:
The error occurs in getSprite():
# Excerpt ID: ca282f07-3428-483b-8aee-7a313af7de20
```js
const texture = PIXI.Loader.shared.resources[spriteConfig.path].texture;
```
The issue is that we're using the sprite path as the key in resources, but when loading we need to use a consistent key. The loader resources are indexed by the key we use when adding them, not by the path.

The fix is to:
1. Use consistent keys when loading and retrieving textures
2. Wait for textures to load before creating sprites
3. Use proper PIXI v6+ asset loading syntax

Here are the fixed files:

# Excerpt ID: 66256526-802a-4021-bd5a-704cb3b2a7bf
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.coins = 0;
    this.runnerSpeed = INITIAL_VALUES.RUNNER_SPEED;
    this.coinSpawnRate = INITIAL_VALUES.COIN_SPAWN_RATE;
    this.coinValue = INITIAL_VALUES.COIN_VALUE;
    this.runnerCount = INITIAL_VALUES.RUNNER_COUNT;
    this.trackWidth = INITIAL_VALUES.TRACK_WIDTH;
    
    this.runnerSpeedCost = UPGRADE_COSTS.RUNNER_SPEED;
    this.coinSpawnRateCost = UPGRADE_COSTS.COIN_SPAWN_RATE;
    this.coinValueCost = UPGRADE_COSTS.COIN_VALUE;
    this.runnerCountCost = UPGRADE_COSTS.RUNNER_COUNT;
    this.trackWidthCost = UPGRADE_COSTS.TRACK_WIDTH;

    this.coinSpawnTimer = 0;
    this.lastTimestamp = performance.now();

    // Initialize textures
    this.textures = {};

    // Load all textures first
    const loader = PIXI.Loader.shared;
    Object.entries(SPRITES).forEach(([key, sprite]) => {
      loader.add(key, sprite.path);
    });

    loader.load((loader, resources) => {
      // Store all textures
      Object.keys(SPRITES).forEach(key => {
        this.textures[key] = resources[key].texture;
      });

      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteKey) {
    const sprite = new PIXI.Sprite(this.textures[spriteKey]);
    sprite.width = SPRITES[spriteKey].width;
    sprite.height = SPRITES[spriteKey].height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite('background');
    this.runners = new PIXI.Container();
    this.coins = new PIXI.Container();

    // Create initial runner
    this.createRunner();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.runners);
    this.app.stage.addChild(this.coins);
  }

  createRunner() {
    const runner = this.getSprite('runner');
    runner.anchor.set(0.5);
    runner.x = 0;
    runner.y = SCREEN_SIZE.height/2 + (Math.random() - 0.5) * 200;
    this.runners.addChild(runner);
  }

  createCoin() {
    const coin = this.getSprite('coin');
    coin.anchor.set(0.5);
    coin.x = Math.random() * this.trackWidth;
    coin.y = SCREEN_SIZE.height/2 + (Math.random() - 0.5) * 200;
    this.coins.addChild(coin);
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Move runners
    this.runners.children.forEach(runner => {
      runner.x += this.runnerSpeed * elapsedSecs;
      if (runner.x > SCREEN_SIZE.width) {
        runner.x = 0;
      }
    });

    // Spawn coins
    this.coinSpawnTimer += elapsedSecs;
    if (this.coinSpawnTimer >= 1/this.coinSpawnRate) {
      this.createCoin();
      this.coinSpawnTimer = 0;
    }

    // Check collisions
    this.runners.children.forEach(runner => {
      this.coins.children.forEach(coin => {
        if (this.checkCollision(runner, coin)) {
          this.coins.removeChild(coin);
          this.coins += this.coinValue;
        }
      });
    });
  }

  checkCollision(obj1, obj2) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (obj1.width/2 + obj2.width/2);
  }

  upgradeRunnerSpeed() {
    if (this.coins >= this.runnerSpeedCost) {
      this.coins -= this.runnerSpeedCost;
      this.runnerSpeed *= 1.2;
      this.runnerSpeedCost *= 2;
    }
  }

  upgradeCoinSpawnRate() {
    if (this.coins >= this.coinSpawnRateCost) {
      this.coins -= this.coinSpawnRateCost;
      this.coinSpawnRate *= 1.2;
      this.coinSpawnRateCost *= 2;
    }
  }

  upgradeCoinValue() {
    if (this.coins >= this.coinValueCost) {
      this.coins -= this.coinValueCost;
      this.coinValue *= 1.5;
      this.coinValueCost *= 2;
    }
  }

  upgradeRunnerCount() {
    if (this.coins >= this.runnerCountCost) {
      this.coins -= this.runnerCountCost;
      this.runnerCount++;
      this.createRunner();
      this.runnerCountCost *= 2;
    }
  }

  upgradeTrackWidth() {
    if (this.coins >= this.trackWidthCost) {
      this.coins -= this.trackWidthCost;
      this.trackWidth *= 1.2;
      this.trackWidthCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

The key changes are:
1. Added a textures object to store loaded textures
2. Changed getSprite to use sprite keys instead of configs
3. Modified the loader to store textures by key
4. Simplified the asset loading process

This should resolve the texture loading errors while maintaining all functionality. The error was occurring because we were trying to access textures before they were loaded and using incorrect keys to retrieve them.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
