Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data (gameData.js):
- Define initial values for all upgradeable attributes
- Define base costs and multipliers for upgrades
- Define constants like customer payment, station positions

2. Asset Manifest (assetManifest.js):
- Add sprites for barista, customer, counter, coffee machine
- Keep background and adjust other asset sizes to 64x64 minimum

3. Game Logic (gameLogic.js):
Core systems:
- Barista management: movement, state tracking (idle/moving/making coffee)
- Customer spawning at counters with timer
- Coffee making process timer
- Money accumulation when orders complete
- Upgrade functions for each attribute
- Position tracking and distance calculations
- Collision detection for interactions

4. UI (GameUI.js):
- Display current money
- Show upgrade buttons with costs
- Display stats (baristas, efficiency, etc.)

Now, let's implement each file:

# Excerpt ID: d6afb4f1-8353-4438-8e4e-377034c6417e
```javascript src/game/gameData.js
export const INITIAL_VALUES = {
  BARISTA_COUNT: 1,
  BARISTA_SPEED: 100, // pixels per second
  COFFEE_MACHINE_TIME: 3, // seconds to make coffee
  COUNTER_COUNT: 1,
  COFFEE_PRICE: 5,
  CUSTOMER_SPAWN_TIME: 5, // seconds between customers
};

export const UPGRADE_COSTS = {
  BARISTA_COUNT: 100,
  BARISTA_SPEED: 50,
  COFFEE_MACHINE: 75,
  COUNTER_COUNT: 150,
  COFFEE_PRICE: 80,
  CUSTOMER_ATTRACTION: 60,
};

export const STATION_POSITIONS = {
  COUNTER_START_X: 100,
  COUNTER_Y: 500,
  COUNTER_SPACING: 150,
  MACHINE_START_X: 100,
  MACHINE_Y: 200,
  MACHINE_SPACING: 150,
};
```

# Excerpt ID: 85ac3354-2559-4c4c-92d9-693e78578532
```javascript src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  barista: {
    path: 'assets/barista.png',
    width: 64,
    height: 64
  },
  customer: {
    path: 'assets/customer.png',
    width: 64,
    height: 64
  },
  counter: {
    path: 'assets/counter.png',
    width: 128,
    height: 64
  },
  coffeeMachine: {
    path: 'assets/coffee_machine.png',
    width: 64,
    height: 64
  }
};
```

# Excerpt ID: 01b32b95-7cae-404d-b775-9ad2991212bf
```javascript src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, STATION_POSITIONS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.money = 0;
    this.lastTimestamp = performance.now();

    // Game state
    this.baristaCount = INITIAL_VALUES.BARISTA_COUNT;
    this.baristaSpeed = INITIAL_VALUES.BARISTA_SPEED;
    this.coffeeMachineTime = INITIAL_VALUES.COFFEE_MACHINE_TIME;
    this.counterCount = INITIAL_VALUES.COUNTER_COUNT;
    this.coffeePrice = INITIAL_VALUES.COFFEE_PRICE;
    this.customerSpawnTime = INITIAL_VALUES.CUSTOMER_SPAWN_TIME;

    // Upgrade costs
    this.baristaCountCost = UPGRADE_COSTS.BARISTA_COUNT;
    this.baristaSpeedCost = UPGRADE_COSTS.BARISTA_SPEED;
    this.coffeeMachineCost = UPGRADE_COSTS.COFFEE_MACHINE;
    this.counterCountCost = UPGRADE_COSTS.COUNTER_COUNT;
    this.coffeePriceCost = UPGRADE_COSTS.COFFEE_PRICE;
    this.customerAttractionCost = UPGRADE_COSTS.CUSTOMER_ATTRACTION;

    // Timers
    this.customerSpawnTimer = 0;

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.app.stage.addChild(this.background);

    // Create containers
    this.counters = new PIXI.Container();
    this.coffeeMachines = new PIXI.Container();
    this.baristas = new PIXI.Container();
    this.customers = new PIXI.Container();

    this.app.stage.addChild(this.counters);
    this.app.stage.addChild(this.coffeeMachines);
    this.app.stage.addChild(this.baristas);
    this.app.stage.addChild(this.customers);

    // Initialize stations
    this.createInitialStations();
    this.createInitialBaristas();
  }

  createInitialStations() {
    // Create counters
    for (let i = 0; i < this.counterCount; i++) {
      const counter = this.getSprite(SPRITES.counter);
      counter.x = STATION_POSITIONS.COUNTER_START_X + (i * STATION_POSITIONS.COUNTER_SPACING);
      counter.y = STATION_POSITIONS.COUNTER_Y;
      counter.customer = null;
      this.counters.addChild(counter);

      // Create matching coffee machine
      const machine = this.getSprite(SPRITES.coffeeMachine);
      machine.x = STATION_POSITIONS.MACHINE_START_X + (i * STATION_POSITIONS.MACHINE_SPACING);
      machine.y = STATION_POSITIONS.MACHINE_Y;
      machine.inUse = false;
      this.coffeeMachines.addChild(machine);
    }
  }

  createInitialBaristas() {
    for (let i = 0; i < this.baristaCount; i++) {
      this.createBarista();
    }
  }

  createBarista() {
    const barista = this.getSprite(SPRITES.barista);
    barista.x = Math.random() * this.app.screen.width;
    barista.y = Math.random() * this.app.screen.height;
    barista.state = 'idle';
    barista.targetX = barista.x;
    barista.targetY = barista.y;
    barista.assignedCustomer = null;
    barista.assignedMachine = null;
    this.baristas.addChild(barista);
  }

  spawnCustomer() {
    const availableCounter = this.counters.children.find(counter => !counter.customer);
    if (availableCounter) {
      const customer = this.getSprite(SPRITES.customer);
      customer.x = availableCounter.x;
      customer.y = availableCounter.y;
      customer.counter = availableCounter;
      availableCounter.customer = customer;
      this.customers.addChild(customer);
    }
  }

  moveBarista(barista, targetX, targetY, elapsedSecs) {
    const dx = targetX - barista.x;
    const dy = targetY - barista.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > 1) {
      const moveDistance = this.baristaSpeed * elapsedSecs;
      const ratio = moveDistance / distance;
      barista.x += dx * ratio;
      barista.y += dy * ratio;
      return false;
    }
    return true;
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Spawn customers
    this.customerSpawnTimer += elapsedSecs;
    if (this.customerSpawnTimer >= this.customerSpawnTime) {
      this.spawnCustomer();
      this.customerSpawnTimer = 0;
    }

    // Update baristas
    this.baristas.children.forEach(barista => {
      switch (barista.state) {
        case 'idle':
          const customer = this.customers.children.find(c => !c.beingServed);
          if (customer) {
            barista.state = 'moving_to_customer';
            barista.assignedCustomer = customer;
            customer.beingServed = true;
          }
          break;

        case 'moving_to_customer':
          if (this.moveBarista(barista, barista.assignedCustomer.x, barista.assignedCustomer.y, elapsedSecs)) {
            barista.state = 'moving_to_machine';
            const machine = this.coffeeMachines.children.find(m => !m.inUse);
            barista.assignedMachine = machine;
            machine.inUse = true;
          }
          break;

        case 'moving_to_machine':
          if (this.moveBarista(barista, barista.assignedMachine.x, barista.assignedMachine.y, elapsedSecs)) {
            barista.state = 'making_coffee';
            barista.coffeeTimer = 0;
          }
          break;

        case 'making_coffee':
          barista.coffeeTimer += elapsedSecs;
          if (barista.coffeeTimer >= this.coffeeMachineTime) {
            barista.state = 'serving_customer';
          }
          break;

        case 'serving_customer':
          if (this.moveBarista(barista, barista.assignedCustomer.x, barista.assignedCustomer.y, elapsedSecs)) {
            // Complete order
            this.money += this.coffeePrice;
            this.customers.removeChild(barista.assignedCustomer);
            barista.assignedCustomer.counter.customer = null;
            barista.assignedMachine.inUse = false;
            barista.state = 'idle';
            barista.assignedCustomer = null;
            barista.assignedMachine = null;
          }
          break;
      }
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  // Upgrade functions
  upgradeBaristaCount() {
    if (this.money >= this.baristaCountCost) {
      this.money -= this.baristaCountCost;
      this.baristaCount++;
      this.createBarista();
      this.baristaCountCost *= 2;
    }
  }

  upgradeBaristaSpeed() {
    if (this.money >= this.baristaSpeedCost) {
      this.money -= this.baristaSpeedCost;
      this.baristaSpeed *= 1.2;
      this.baristaSpeedCost *= 2;
    }
  }

  upgradeCoffeeMachine() {
    if (this.money >= this.coffeeMachineCost) {
      this.money -= this.coffeeMachineCost;
      this.coffeeMachineTime *= 0.8;
      this.coffeeMachineCost *= 2;
    }
  }

  upgradeCounterCount() {
    if (this.money >= this.counterCountCost) {
      this.money -= this.counterCountCost;
      this.counterCount++;
      const i = this.counterCount - 1;
      
      const counter = this.getSprite(SPRITES.counter);
      counter.x = STATION_POSITIONS.COUNTER_START_X + (i * STATION_POSITIONS.COUNTER_SPACING);
      counter.y = STATION_POSITIONS.COUNTER_Y;
      counter.customer = null;
      this.counters.addChild(counter);

      const machine = this.getSprite(SPRITES.coffeeMachine);
      machine.x = STATION_POSITIONS.MACHINE_START_X + (i * STATION_POSITIONS.MACHINE_SPACING);
      machine.y = STATION_POSITIONS.MACHINE_Y;
      machine.inUse = false;
      this.coffeeMachines.addChild(machine);

      this.counterCountCost *= 2;
    }
  }

  upgradeCoffeePrice() {
    if (this.money >= this.coffeePriceCost) {
      this.money -= this.coffeePriceCost;
      this.coffeePrice *= 1.2;
      this.coffeePriceCost *= 2;
    }
  }

  upgradeCustomerAttraction() {
    if (this.money >= this.customerAttractionCost) {
      this.money -= this.customerAttractionCost;
      this.customerSpawnTime *= 0.8;
      this.customerAttractionCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: c9f0bbc2-e505-4699-9776-2afe4030c6d5
```javascript src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
    position: 'relative',
  }}>
    {children} (${cost})
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Money: ${Math.floor(game.money)} | Baristas: {game.baristaCount} | Coffee Price: ${game.coffeePrice.toFixed(2)} | Customer Spawn Time: {game.customerSpawnTime.toFixed(1)}s</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeBaristaCount()} cost={game.baristaCountCost}>Hire Barista</Button>
        <Button onClick={() => game.upgradeBaristaSpeed()} cost={game.baristaSpeedCost}>Upgrade Barista Speed</Button>
        <Button onClick={() => game.upgradeCoffeeMachine()} cost={game.coffeeMachineCost}>Upgrade Coffee Machines</Button>
        <Button onClick={() => game.upgradeCounterCount()} cost={game.counterCountCost}>Add Counter</Button>
        <Button onClick={() => game.upgradeCoffeePrice()} cost={game.coffeePriceCost}>Increase Coffee Price</Button>
        <Button onClick={() => game.upgradeCustomerAttraction()} cost={game.customerAttractionCost}>Improve Customer Attraction</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the required features:
1. Automated baristas moving between counters and machines
2. Customer spawning system
3. Coffee preparation mechanics
4. Money earning system
5. All six specified upgrades
6. Proper movement system with straight-line paths
7. Complete UI with all upgrades and current stats
8. All timers use elapsed seconds
9. All sprites are 64x64 or larger

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
