Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Error Analysis:
The error "Cannot read properties of undefined (reading 'path')" occurs in getSprite. Let's trace:

# Excerpt ID: 1d428b8d-f3db-44af-b001-70de60f32db6
```javascript
getSprite(spriteConfig) {
  const texture = PIXI.Texture.from(SPRITES[spriteConfig].path);
  // spriteConfig is a string like 'background', but SPRITES[spriteConfig] is undefined
}
```

The issue is in assetManifest.js - we're missing the required sprite definitions. The error occurs because we're trying to use sprites that aren't defined in the SPRITES object.

2. Here's the corrected implementation:

# Excerpt ID: 03f5d5a9-4910-431e-9138-077d91602b7b
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  miner: {
    path: 'assets/miner.png',
    width: 64,
    height: 64
  },
  mine: {
    path: 'assets/mine.png',
    width: 64,
    height: 64
  },
  depot: {
    path: 'assets/depot.png',
    width: 64,
    height: 64
  }
};
```

# Excerpt ID: acfb7976-2ca3-448b-95c6-19d811389323
```js src/game/gameData.js
export const INITIAL_VALUES = {
  MINER_COUNT: 1,
  MINING_SPEED: 100, // pixels per second
  CARRYING_CAPACITY: 10,
  MAX_MINES: 3,
  MINE_SIZE: 50,
};

export const UPGRADE_COSTS = {
  MINER_COUNT: 100,
  MINING_SPEED: 50,
  CARRYING_CAPACITY: 75,
  MAX_MINES: 150,
  MINE_SIZE: 125,
};
```

# Excerpt ID: 4f4314c3-9bd0-4f04-84f5-a4d35aed7d27
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.gold = 0;
    this.lastTimestamp = performance.now();
    
    // Game attributes
    this.minerCount = INITIAL_VALUES.MINER_COUNT;
    this.miningSpeed = INITIAL_VALUES.MINING_SPEED;
    this.carryingCapacity = INITIAL_VALUES.CARRYING_CAPACITY;
    this.maxMines = INITIAL_VALUES.MAX_MINES;
    this.mineSize = INITIAL_VALUES.MINE_SIZE;

    // Upgrade costs
    this.minerCost = UPGRADE_COSTS.MINER_COUNT;
    this.speedCost = UPGRADE_COSTS.MINING_SPEED;
    this.capacityCost = UPGRADE_COSTS.CARRYING_CAPACITY;
    this.maxMinesCost = UPGRADE_COSTS.MAX_MINES;
    this.mineSizeCost = UPGRADE_COSTS.MINE_SIZE;

    // Load assets and initialize game
    const loader = PIXI.Loader.shared;
    Object.values(SPRITES).forEach(sprite => {
      loader.add(sprite.path);
    });
    
    loader.load(() => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const sprite = new PIXI.Sprite(PIXI.Texture.from(SPRITES[spriteConfig].path));
    sprite.width = SPRITES[spriteConfig].width;
    sprite.height = SPRITES[spriteConfig].height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite('background');
    
    // Create depot
    this.depot = this.getSprite('depot');
    this.depot.anchor.set(0.5);
    this.depot.x = SCREEN_SIZE.width / 2;
    this.depot.y = SCREEN_SIZE.height / 2;

    // Containers for miners and mines
    this.miners = new PIXI.Container();
    this.mines = new PIXI.Container();

    // Create initial miners and mines
    for (let i = 0; i < this.minerCount; i++) {
      this.createMiner();
    }
    
    for (let i = 0; i < this.maxMines; i++) {
      this.createMine();
    }

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.depot);
    this.app.stage.addChild(this.mines);
    this.app.stage.addChild(this.miners);
  }

  createMiner() {
    const miner = this.getSprite('miner');
    miner.anchor.set(0.5);
    miner.x = this.depot.x;
    miner.y = this.depot.y;
    miner.carrying = 0;
    miner.targetMine = null;
    miner.state = 'seeking';
    this.miners.addChild(miner);
  }

  createMine() {
    const mine = this.getSprite('mine');
    mine.anchor.set(0.5);
    
    let validPosition = false;
    while (!validPosition) {
      const x = Math.random() * (SCREEN_SIZE.width - 100) + 50;
      const y = Math.random() * (SCREEN_SIZE.height - 100) + 50;
      
      const distToDepot = Math.hypot(x - this.depot.x, y - this.depot.y);
      if (distToDepot < 100) continue;
      
      validPosition = true;
      mine.x = x;
      mine.y = y;
    }
    
    mine.goldAmount = this.mineSize;
    this.mines.addChild(mine);
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    this.updateMiners(elapsedSecs);
    this.manageMines();
  }

  updateMiners(elapsedSecs) {
    this.miners.children.forEach(miner => {
      if (miner.state === 'seeking') {
        if (!miner.targetMine || miner.targetMine.goldAmount <= 0) {
          miner.targetMine = this.findNearestMine(miner);
        }
        
        if (miner.targetMine) {
          const arrived = this.moveTo(miner, miner.targetMine, elapsedSecs);
          if (arrived) {
            const mined = Math.min(this.carryingCapacity, miner.targetMine.goldAmount);
            miner.carrying = mined;
            miner.targetMine.goldAmount -= mined;
            miner.state = 'returning';
          }
        }
      } else if (miner.state === 'returning') {
        const arrived = this.moveTo(miner, this.depot, elapsedSecs);
        if (arrived) {
          this.gold += miner.carrying;
          miner.carrying = 0;
          miner.state = 'seeking';
        }
      }
    });
  }

  moveTo(mover, target, elapsedSecs) {
    const dx = target.x - mover.x;
    const dy = target.y - mover.y;
    const distance = Math.hypot(dx, dy);
    
    if (distance < 5) return true;
    
    const moveDistance = this.miningSpeed * elapsedSecs;
    const ratio = Math.min(moveDistance / distance, 1);
    
    mover.x += dx * ratio;
    mover.y += dy * ratio;
    
    return false;
  }

  findNearestMine(miner) {
    let nearest = null;
    let minDistance = Infinity;
    
    this.mines.children.forEach(mine => {
      if (mine.goldAmount <= 0) return;
      const distance = Math.hypot(mine.x - miner.x, mine.y - miner.y);
      if (distance < minDistance) {
        minDistance = distance;
        nearest = mine;
      }
    });
    
    return nearest;
  }

  manageMines() {
    for (let i = this.mines.children.length - 1; i >= 0; i--) {
      if (this.mines.children[i].goldAmount <= 0) {
        this.mines.removeChildAt(i);
      }
    }
    
    while (this.mines.children.length < this.maxMines) {
      this.createMine();
    }
  }

  upgradeMinerCount() {
    if (this.gold >= this.minerCost) {
      this.gold -= this.minerCost;
      this.minerCount++;
      this.createMiner();
      this.minerCost *= 2;
    }
  }

  upgradeMiningSpeed() {
    if (this.gold >= this.speedCost) {
      this.gold -= this.speedCost;
      this.miningSpeed *= 1.2;
      this.speedCost *= 2;
    }
  }

  upgradeCarryingCapacity() {
    if (this.gold >= this.capacityCost) {
      this.gold -= this.capacityCost;
      this.carryingCapacity = Math.floor(this.carryingCapacity * 1.5);
      this.capacityCost *= 2;
    }
  }

  upgradeMaxMines() {
    if (this.gold >= this.maxMinesCost) {
      this.gold -= this.maxMinesCost;
      this.maxMines++;
      this.createMine();
      this.maxMinesCost *= 2;
    }
  }

  upgradeMineSize() {
    if (this.gold >= this.mineSizeCost) {
      this.gold -= this.mineSizeCost;
      this.mineSize = Math.floor(this.mineSize * 1.5);
      this.mineSizeCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

Key changes:
1. Added all required sprite definitions to assetManifest.js
2. Replaced loadAssets utility with direct PIXI.Loader usage
3. Simplified asset loading process
4. Ensured all sprite references match the defined sprites

This should resolve the sprite loading issues while maintaining all game functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
