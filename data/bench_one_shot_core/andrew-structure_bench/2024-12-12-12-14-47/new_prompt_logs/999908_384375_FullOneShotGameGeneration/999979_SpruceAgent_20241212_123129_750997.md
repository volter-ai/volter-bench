Role: system
Content: You are an expert software developer. Your job is to make an existing simple UI look like the UI from an advanced video game
__________________
Role: user
Content: The existing codebase of the project is as follows:
```js src/Game.js
import React, { useRef, useState, useEffect } from 'react';
import { Settings } from 'lucide-react';
import { GameLogic } from './game/gameLogic';
import GameUI from './ui/GameUI';
import DebugUI from './ui/DebugUI';

const FRAME_RATE = 30;
const FRAME_INTERVAL = 1000 / FRAME_RATE;

const Game = () => {
  const containerRef = useRef(null);
  const gameRef = useRef(null);
  const [showDebugUI, setShowDebugUI] = useState(false);
  const [, setFrame] = useState(0);

  useEffect(() => {
    if (!containerRef.current) return;

    const game = new GameLogic(containerRef.current);
    window.game = game;
    gameRef.current = game;

    let lastTime = Date.now();
    let intervalId;
    const update = (currentTime) => {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // Force a re-render by updating the frame state
      setFrame(prevFrame => prevFrame + 1);
    };

    intervalId = setInterval(() => {
      update(Date.now());
    }, FRAME_INTERVAL);

    return () => {
      clearInterval(intervalId);
      if (gameRef.current) {
        gameRef.current.destroy();
        gameRef.current = null;
      }
      gameRef.current = null;
    };
  }, []);

  return (
    <div style={{
      position: 'relative',
      width: '800px',
      height: '600px',
      overflow: 'hidden'
    }}>
      <div ref={containerRef} style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%'
      }} />
      {gameRef.current && (
        <>
          <GameUI gameRef={gameRef} />
          {showDebugUI && <DebugUI gameRef={gameRef} />}
        </>
      )}
      <Settings
        onClick={() => setShowDebugUI(!showDebugUI)}
        style={{
          position: 'absolute',
          bottom: '10px',
          right: '10px',
          width: '24px',
          height: '24px',
          cursor: 'pointer',
          color: 'white'
        }}
      />
    </div>
  );
};

export default Game;
```
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, STATION_POSITIONS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils';

const SCREEN_SIZE = {
  width: 800,
  height: 600
};

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.money = 100; // Give initial money to actually buy upgrades
    this.baristaSpeed = INITIAL_VALUES.BARISTA_SPEED;
    this.baristaCount = INITIAL_VALUES.BARISTA_COUNT;
    this.coffeeTime = INITIAL_VALUES.COFFEE_PREP_TIME;
    this.serviceTime = INITIAL_VALUES.SERVICE_TIME;
    this.counterCount = INITIAL_VALUES.COUNTER_COUNT;
    this.paymentAmount = INITIAL_VALUES.PAYMENT_AMOUNT;

    this.upgradeCosts = {...UPGRADE_COSTS};
    this.lastTimestamp = performance.now();
    this.counterStates = new Array(3).fill(false); // Track counter occupancy

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteKey) {
    const texture = PIXI.Loader.shared.resources[spriteKey].texture;
    const sprite = new PIXI.Sprite(texture);
    sprite.width = SPRITES[spriteKey].width;
    sprite.height = SPRITES[spriteKey].height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite('background');
    this.baristas = new PIXI.Container();
    this.customers = new PIXI.Container();
    this.stations = new PIXI.Container();

    this.createBarista();
    this.createStations();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.stations);
    this.app.stage.addChild(this.customers);
    this.app.stage.addChild(this.baristas);
  }

  createBarista() {
    const barista = this.getSprite('barista');
    barista.anchor.set(0.5);
    barista.x = STATION_POSITIONS.IDLE_POSITION.x;
    barista.y = STATION_POSITIONS.IDLE_POSITION.y;
    barista.state = 'idle';
    barista.targetX = barista.x;
    barista.targetY = barista.y;
    this.baristas.addChild(barista);
  }

  createStations() {
    for (let i = 0; i < 3; i++) {
      const counter = this.getSprite('counter');
      counter.anchor.set(0.5);
      counter.x = STATION_POSITIONS.ORDER_COUNTERS[i].x;
      counter.y = STATION_POSITIONS.ORDER_COUNTERS[i].y;
      counter.occupied = false;
      this.stations.addChild(counter);
    }

    for (let i = 0; i < 3; i++) {
      const machine = this.getSprite('coffee_machine');
      machine.anchor.set(0.5);
      machine.x = STATION_POSITIONS.COFFEE_MACHINES[i].x;
      machine.y = STATION_POSITIONS.COFFEE_MACHINES[i].y;
      machine.occupied = false;
      this.stations.addChild(machine);
    }
  }

  spawnCustomer() {
    // Only spawn if we have less active customers than allowed counters
    if (this.customers.children.length >= this.counterCount) {
      return;
    }

    // Find first empty counter position
    for (let i = 0; i < this.counterCount; i++) {
      if (!this.counterStates[i]) {
        const counterPos = STATION_POSITIONS.ORDER_COUNTERS[i];
        const customer = this.getSprite('customer');
        customer.anchor.set(0.5);
        customer.x = counterPos.x;
        customer.y = counterPos.y;
        customer.state = 'waiting';
        customer.counterId = i;
        this.customers.addChild(customer);
        this.counterStates[i] = true;
        break;
      }
    }
  }

  moveEntity(entity, targetX, targetY, speed, elapsedSecs) {
    const dx = targetX - entity.x;
    const dy = targetY - entity.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > 1) {
      const moveDistance = speed * elapsedSecs;
      const ratio = moveDistance / distance;
      entity.x += dx * ratio;
      entity.y += dy * ratio;
      return false;
    }
    
    entity.x = targetX;
    entity.y = targetY;
    return true;
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Try to spawn a customer if there's space
    this.spawnCustomer();

    this.baristas.children.forEach(barista => {
      if (barista.state === 'idle') {
        const waitingCustomer = this.customers.children.find(c => c.state === 'waiting');
        if (waitingCustomer) {
          barista.state = 'moving_to_customer';
          barista.targetX = waitingCustomer.x;
          barista.targetY = waitingCustomer.y;
          barista.servingCustomerId = waitingCustomer.counterId;
          waitingCustomer.state = 'being_served';
        }
      }
      
      if (barista.state === 'moving_to_customer' || barista.state === 'moving_to_machine' || 
          barista.state === 'moving_to_service' || barista.state === 'returning') {
        const arrived = this.moveEntity(barista, barista.targetX, barista.targetY, this.baristaSpeed, elapsedSecs);
        if (arrived) {
          if (barista.state === 'moving_to_customer') {
            barista.state = 'moving_to_machine';
            const machine = STATION_POSITIONS.COFFEE_MACHINES[0];
            barista.targetX = machine.x;
            barista.targetY = machine.y;
          } else if (barista.state === 'moving_to_machine') {
            barista.state = 'preparing';
            barista.timer = this.coffeeTime;
          } else if (barista.state === 'moving_to_service') {
            barista.state = 'serving';
            barista.timer = this.serviceTime;
          } else if (barista.state === 'returning') {
            barista.state = 'idle';
          }
        }
      }

      if (barista.state === 'preparing' || barista.state === 'serving') {
        barista.timer -= elapsedSecs;
        if (barista.timer <= 0) {
          if (barista.state === 'preparing') {
            barista.state = 'moving_to_service';
            const service = STATION_POSITIONS.SERVICE_COUNTERS[0];
            barista.targetX = service.x;
            barista.targetY = service.y;
          } else if (barista.state === 'serving') {
            this.money += this.paymentAmount;
            barista.state = 'returning';
            barista.targetX = STATION_POSITIONS.IDLE_POSITION.x;
            barista.targetY = STATION_POSITIONS.IDLE_POSITION.y;
            
            const servedCustomer = this.customers.children.find(c => c.state === 'being_served');
            if (servedCustomer) {
              this.counterStates[servedCustomer.counterId] = false;
              this.customers.removeChild(servedCustomer);
            }
          }
        }
      }
    });
  }

  upgradeBaristas() {
    if (this.money >= this.upgradeCosts.BARISTA) {
      this.money -= this.upgradeCosts.BARISTA;
      this.createBarista();
      this.baristaCount++;
      this.upgradeCosts.BARISTA *= 2;
    }
  }

  upgradeBaristaSpeed() {
    if (this.money >= this.upgradeCosts.BARISTA_SPEED) {
      this.money -= this.upgradeCosts.BARISTA_SPEED;
      this.baristaSpeed *= 1.2;
      this.upgradeCosts.BARISTA_SPEED *= 2;
    }
  }

  upgradeCoffeeMachine() {
    if (this.money >= this.upgradeCosts.COFFEE_MACHINE) {
      this.money -= this.upgradeCosts.COFFEE_MACHINE;
      this.coffeeTime *= 0.8;
      this.upgradeCosts.COFFEE_MACHINE *= 2;
    }
  }

  upgradeCounter() {
    if (this.money >= this.upgradeCosts.COUNTER) {
      this.money -= this.upgradeCosts.COUNTER;
      this.counterCount++;
      this.upgradeCosts.COUNTER *= 2;
    }
  }

  upgradePrices() {
    if (this.money >= this.upgradeCosts.PREMIUM_PRICES) {
      this.money -= this.upgradeCosts.PREMIUM_PRICES;
      this.paymentAmount *= 1.5;
      this.upgradeCosts.PREMIUM_PRICES *= 2;
    }
  }

  upgradeTraining() {
    if (this.money >= this.upgradeCosts.TRAINING) {
      this.money -= this.upgradeCosts.TRAINING;
      this.serviceTime *= 0.8;
      this.upgradeCosts.TRAINING *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}

```
```js src/game/gameData.js
export const INITIAL_VALUES = {
  BARISTA_SPEED: 200, // pixels per second
  BARISTA_COUNT: 1,
  COFFEE_PREP_TIME: 3, // seconds
  SERVICE_TIME: 2, // seconds
  COUNTER_COUNT: 1,
  PAYMENT_AMOUNT: 20, // Changed from 10 to 20
};

export const UPGRADE_COSTS = {
  BARISTA: 25, // Changed from 50
  BARISTA_SPEED: 15, // Changed from 30
  COFFEE_MACHINE: 20, // Changed from 40
  COUNTER: 30, // Changed from 60
  PREMIUM_PRICES: 35, // Changed from 75
  TRAINING: 20, // Changed from 45
};

export const STATION_POSITIONS = {
  IDLE_POSITION: { x: 400, y: 500 },
  COFFEE_MACHINES: [
    { x: 200, y: 300 },
    { x: 300, y: 300 },
    { x: 400, y: 300 }
  ],
  ORDER_COUNTERS: [
    { x: 200, y: 100 },
    { x: 300, y: 100 },
    { x: 400, y: 100 }
  ],
  SERVICE_COUNTERS: [
    { x: 600, y: 100 },
    { x: 600, y: 200 },
    { x: 600, y: 300 }
  ]
};

```
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  barista: {
    path: 'assets/barista.png',
    width: 64,
    height: 64
  },
  customer: {
    path: 'assets/customer.png',
    width: 64,
    height: 64
  },
  counter: {
    path: 'assets/counter.png',
    width: 80,
    height: 64
  },
  coffee_machine: {
    path: 'assets/coffee_machine.png',
    width: 64,
    height: 64
  }
};

```
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
    position: 'relative',
  }}>
    {children} (${cost})
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Money: ${Math.floor(game.money)} | Baristas: {game.baristaCount} | Counters: {game.counterCount}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeBaristas()} cost={game.upgradeCosts.BARISTA}>Hire Barista</Button>
        <Button onClick={() => game.upgradeBaristaSpeed()} cost={game.upgradeCosts.BARISTA_SPEED}>Faster Baristas</Button>
        <Button onClick={() => game.upgradeCoffeeMachine()} cost={game.upgradeCosts.COFFEE_MACHINE}>Better Machines</Button>
        <Button onClick={() => game.upgradeCounter()} cost={game.upgradeCosts.COUNTER}>Add Counter</Button>
        <Button onClick={() => game.upgradePrices()} cost={game.upgradeCosts.PREMIUM_PRICES}>Premium Prices</Button>
        <Button onClick={() => game.upgradeTraining()} cost={game.upgradeCosts.TRAINING}>Efficient Training</Button>
      </div>
    </div>
  );
};

export default GameUI;

```
```js src/game/fontManifest.js
export const FONTS = [
  'Press Start 2P',
  'Roboto:400,700',
  'Orbitron:400,700',
]
```

Only make changes to the GameUI or fontManifest file. Don't change anything about the logic or functionality but make the UI look much better and make it feel like a very well implemented game. You can add multilayered menu interactions.


Make sure that only the essential data (such as currency) is shown in the hud and the other stats are hidden in a stats modal

Upgrades should be in modals and submenus instead of being directly on the screen


Make sure that the theme of your UI matches with the theme of the game

Make sure all modals can be opened and closed

General Implementation Guidelines:
1. Write out all the code of the files you intend to edit. I will be copy-pasting them
2. Do not create new files, add to the existing files in the appropriate locations
3. Do not do any refactoring outside of what you are requested to do

Directions:
In your response, do both steps, one after the other
1. First think carefully and describe in detail how you will implement the game design. Make sure to follow all the guidelines
2. Then write each file, according to the plan

Write out all the files in the format:
```filetype filepath
content
```

MOST IMPORTANT: Do not write "existing code here" or similar placeholders. If a file has been edited in anyway,
EVERY original unchanged line must be rewritten in your output
__________________
Role: assistant
Content: Let me plan out the UI improvements first:

1. **Theme and Style**
- Cyberpunk/Futuristic coffee shop theme with neon accents
- Dark background with glowing elements
- Modern, clean typography using Orbitron font
- Animated transitions for modals and menus

2. **HUD Design**
- Minimal HUD showing only money
- Small icons for quick access to different menus
- Animated currency changes

3. **Menu Structure**
Main menus:
- Stats Menu (shows all game statistics)
- Upgrades Menu with sub-categories:
  - Staff Management (Barista hiring, training)
  - Equipment (Machines, counters)
  - Business (Prices, efficiency)
- Settings Menu (already exists with gear icon)

4. **Modal System**
- Backdrop blur effect
- Smooth animations
- Clear hierarchy
- Easy close buttons
- Consistent styling

Now, I'll implement these changes:

```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';
import { ChevronLeft, X, Users, Coffee, DollarSign, BarChart2, Store } from 'lucide-react';

const Modal = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) return null;
  
  return (
    <div style={{
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.8)',
      backdropFilter: 'blur(4px)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 100,
      animation: 'fadeIn 0.2s ease-out'
    }}>
      <div style={{
        backgroundColor: '#1a1a2e',
        border: '1px solid #7C45CB',
        borderRadius: '8px',
        padding: '20px',
        width: '80%',
        maxWidth: '600px',
        maxHeight: '80%',
        overflow: 'auto',
        position: 'relative',
        boxShadow: '0 0 20px rgba(124, 69, 203, 0.3)',
      }}>
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '20px',
          borderBottom: '1px solid #7C45CB',
          paddingBottom: '10px'
        }}>
          <h2 style={{ 
            margin: 0, 
            fontFamily: 'Orbitron',
            color: '#fff',
            fontSize: '1.5em'
          }}>{title}</h2>
          <X
            onClick={onClose}
            style={{
              cursor: 'pointer',
              color: '#7C45CB',
              transition: 'color 0.2s',
            }}
            onMouseOver={e => e.target.style.color = '#9b6ae0'}
            onMouseOut={e => e.target.style.color = '#7C45CB'}
          />
        </div>
        {children}
      </div>
    </div>
  );
};

const Button = ({ onClick, children, cost, disabled }) => (
  <button
    onClick={onClick}
    disabled={disabled}
    style={{
      margin: '10px',
      padding: '12px 20px',
      fontSize: '14px',
      color: '#fff',
      border: '1px solid #7C45CB',
      borderRadius: '4px',
      cursor: disabled ? 'not-allowed' : 'pointer',
      backgroundColor: disabled ? '#2a2a3e' : '#1a1a2e',
      fontFamily: 'Orbitron',
      transition: 'all 0.2s',
      opacity: disabled ? 0.6 : 1,
      width: '100%',
      textAlign: 'left',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
    }}
  >
    <span>{children}</span>
    <span style={{
      backgroundColor: '#7C45CB',
      padding: '4px 8px',
      borderRadius: '4px',
      fontSize: '0.9em'
    }}>${cost}</span>
  </button>
);

const HUD = ({ game, onOpenStats, onOpenUpgrades }) => (
  <div style={{
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    padding: '15px',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    background: 'linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%)',
  }}>
    <div style={{
      display: 'flex',
      alignItems: 'center',
      gap: '10px',
      color: '#fff',
      fontFamily: 'Orbitron',
    }}>
      <DollarSign size={20} color="#7C45CB" />
      <span style={{ fontSize: '1.2em' }}>{Math.floor(game.money)}</span>
    </div>
    <div style={{ display: 'flex', gap: '15px' }}>
      <BarChart2
        size={24}
        color="#7C45CB"
        style={{ cursor: 'pointer' }}
        onClick={onOpenStats}
      />
      <Store
        size={24}
        color="#7C45CB"
        style={{ cursor: 'pointer' }}
        onClick={onOpenUpgrades}
      />
    </div>
  </div>
);

const StatsModal = ({ game, isOpen, onClose }) => (
  <Modal isOpen={isOpen} onClose={onClose} title="Statistics">
    <div style={{
      display: 'grid',
      gap: '15px',
      color: '#fff',
      fontFamily: 'Orbitron',
    }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', padding: '10px', backgroundColor: '#2a2a3e', borderRadius: '4px' }}>
        <span>Baristas</span>
        <span>{game.baristaCount}</span>
      </div>
      <div style={{ display: 'flex', justifyContent: 'space-between', padding: '10px', backgroundColor: '#2a2a3e', borderRadius: '4px' }}>
        <span>Counters</span>
        <span>{game.counterCount}</span>
      </div>
      <div style={{ display: 'flex', justifyContent: 'space-between', padding: '10px', backgroundColor: '#2a2a3e', borderRadius: '4px' }}>
        <span>Coffee Price</span>
        <span>${game.paymentAmount}</span>
      </div>
    </div>
  </Modal>
);

const UpgradesModal = ({ game, isOpen, onClose }) => {
  const [category, setCategory] = useState(null);

  const renderCategoryContent = () => {
    switch(category) {
      case 'staff':
        return (
          <div>
            <Button onClick={() => game.upgradeBaristas()} cost={game.upgradeCosts.BARISTA}>
              Hire Barista
            </Button>
            <Button onClick={() => game.upgradeBaristaSpeed()} cost={game.upgradeCosts.BARISTA_SPEED}>
              Faster Baristas
            </Button>
            <Button onClick={() => game.upgradeTraining()} cost={game.upgradeCosts.TRAINING}>
              Efficient Training
            </Button>
          </div>
        );
      case 'equipment':
        return (
          <div>
            <Button onClick={() => game.upgradeCoffeeMachine()} cost={game.upgradeCosts.COFFEE_MACHINE}>
              Better Machines
            </Button>
            <Button onClick={() => game.upgradeCounter()} cost={game.upgradeCosts.COUNTER}>
              Add Counter
            </Button>
          </div>
        );
      case 'business':
        return (
          <div>
            <Button onClick={() => game.upgradePrices()} cost={game.upgradeCosts.PREMIUM_PRICES}>
              Premium Prices
            </Button>
          </div>
        );
      default:
        return (
          <div style={{
            display: 'grid',
            gap: '15px',
            gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))',
          }}>
            {['staff', 'equipment', 'business'].map(cat => (
              <div
                key={cat}
                onClick={() => setCategory(cat)}
                style={{
                  padding: '20px',
                  backgroundColor: '#2a2a3e',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  textAlign: 'center',
                  color: '#fff',
                  fontFamily: 'Orbitron',
                  border: '1px solid #7C45CB',
                  transition: 'all 0.2s',
                }}
                onMouseOver={e => e.currentTarget.style.transform = 'scale(1.05)'}
                onMouseOut={e => e.currentTarget.style.transform = 'scale(1)'}
              >
                {cat.charAt(0).toUpperCase() + cat.slice(1)}
              </div>
            ))}
          </div>
        );
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={category ? `Upgrades - ${category.charAt(0).toUpperCase() + category.slice(1)}` : 'Upgrades'}>
      {category && (
        <div
          onClick={() => setCategory(null)}
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: '5px',
            color: '#7C45CB',
            cursor: 'pointer',
            marginBottom: '20px',
          }}
        >
          <ChevronLeft size={20} />
          <span>Back</span>
        </div>
      )}
      {renderCategoryContent()}
    </Modal>
  );
};

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  const [showStats, setShowStats] = useState(false);
  const [showUpgrades, setShowUpgrades] = useState(false);

  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%' }}>
      <HUD
        game={game}
        onOpenStats={() => setShowStats(true)}
        onOpenUpgrades={() => setShowUpgrades(true)}
      />
      <StatsModal
        game={game}
        isOpen={showStats}
        onClose={() => setShowStats(false)}
      />
      <UpgradesModal
        game={game}
        isOpen={showUpgrades}
        onClose={() => setShowUpgrades(false)}
      />
    </div>
  );
};

export default GameUI;
```

```js src/game/fontManifest.js
export const FONTS = [
  'Orbitron:400,700',
  'Roboto:400,700',
]
```

These changes create a much more polished and game-like UI with:
- Clean, cyberpunk-themed design
- Modal-based menus
- Organized upgrade categories
- Minimal HUD
- Consistent styling
- Smooth animations and transitions
- Better typography
- Interactive elements with hover states
- Clear hierarchy of information

The UI now feels more like a proper game interface while maintaining all the original functionality.
__________________
