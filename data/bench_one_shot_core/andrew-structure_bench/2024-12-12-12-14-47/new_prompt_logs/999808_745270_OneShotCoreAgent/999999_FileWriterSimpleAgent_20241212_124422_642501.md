Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data (gameData.js):
- Define initial values for tank attributes (health, damage, speed)
- Define base values for enemy bases (health, damage)
- Define upgrade costs and their multipliers
- Define spawn positions for tanks and bases

2. Asset Manifest (assetManifest.js):
- Add sprites for tank, enemy base, health bar
- Keep existing background

3. Game Logic (gameLogic.js):
- Track credits and upgrade levels
- Manage tank spawning and respawning
- Handle tank movement toward nearest base
- Implement combat system (tanks attacking bases, bases damaging tanks)
- Add upgrade functions
- Add collision detection
- Manage health bars

4. Game UI (GameUI.js):
- Display credits
- Show upgrade buttons with costs
- Display current stats

Now, let's implement each file:

# Excerpt ID: c6f552fc-0cf7-4963-ac06-827d121ed13d
```javascript src/game/gameData.js
export const INITIAL_VALUES = {
  TANK_HEALTH: 100,
  TANK_DAMAGE: 10,
  TANK_SPEED: 100,
  TANK_COUNT: 1,
  BASE_REWARD: 10,
  BASE_HEALTH: 200,
  BASE_DAMAGE: 20,
  TANK_SPAWN_TIME: 3,
  BASE_SPAWN_TIME: 5
};

export const UPGRADE_COSTS = {
  TANK_HEALTH: 10,
  TANK_DAMAGE: 15,
  TANK_SPEED: 20,
  TANK_COUNT: 50,
  BASE_REWARD: 25
};

export const SPAWN_POSITIONS = {
  TANKS: [
    {x: 50, y: 100},
    {x: 50, y: 300},
    {x: 50, y: 500}
  ],
  BASES: [
    {x: 700, y: 150},
    {x: 700, y: 300},
    {x: 700, y: 450}
  ]
};
```

# Excerpt ID: 020e34d9-1af9-47b0-b537-b2a55b121a77
```javascript src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  tank: {
    path: 'assets/tank.png',
    width: 64,
    height: 64
  },
  base: {
    path: 'assets/base.png',
    width: 64,
    height: 64
  }
};
```

# Excerpt ID: 5e6650a0-02ac-4b68-a723-27e490571e13
```javascript src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, SPAWN_POSITIONS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.credits = 0;
    this.tankHealth = INITIAL_VALUES.TANK_HEALTH;
    this.tankDamage = INITIAL_VALUES.TANK_DAMAGE;
    this.tankSpeed = INITIAL_VALUES.TANK_SPEED;
    this.tankCount = INITIAL_VALUES.TANK_COUNT;
    this.baseReward = INITIAL_VALUES.BASE_REWARD;
    
    this.tankHealthCost = UPGRADE_COSTS.TANK_HEALTH;
    this.tankDamageCost = UPGRADE_COSTS.TANK_DAMAGE;
    this.tankSpeedCost = UPGRADE_COSTS.TANK_SPEED;
    this.tankCountCost = UPGRADE_COSTS.TANK_COUNT;
    this.baseRewardCost = UPGRADE_COSTS.BASE_REWARD;

    this.tankSpawnTimer = 0;
    this.baseSpawnTimer = 0;

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.tanks = new PIXI.Container();
    this.bases = new PIXI.Container();
    
    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.tanks);
    this.app.stage.addChild(this.bases);

    // Create initial tanks and bases
    this.spawnTank();
    SPAWN_POSITIONS.BASES.forEach(pos => this.spawnBase(pos.x, pos.y));
  }

  spawnTank() {
    if (this.tanks.children.length >= this.tankCount) return;
    
    const pos = SPAWN_POSITIONS.TANKS[this.tanks.children.length % SPAWN_POSITIONS.TANKS.length];
    const tank = this.getSprite(SPRITES.tank);
    tank.anchor.set(0.5);
    tank.x = pos.x;
    tank.y = pos.y;
    tank.health = this.tankHealth;
    tank.maxHealth = this.tankHealth;
    this.tanks.addChild(tank);
  }

  spawnBase(x, y) {
    const base = this.getSprite(SPRITES.base);
    base.anchor.set(0.5);
    base.x = x;
    base.y = y;
    base.health = INITIAL_VALUES.BASE_HEALTH;
    base.maxHealth = INITIAL_VALUES.BASE_HEALTH;
    this.bases.addChild(base);
  }

  gameLoop(delta) {
    const elapsedSecs = delta / 60;

    // Spawn timers
    this.tankSpawnTimer += elapsedSecs;
    if (this.tankSpawnTimer >= INITIAL_VALUES.TANK_SPAWN_TIME) {
      this.spawnTank();
      this.tankSpawnTimer = 0;
    }

    this.baseSpawnTimer += elapsedSecs;
    if (this.baseSpawnTimer >= INITIAL_VALUES.BASE_SPAWN_TIME && this.bases.children.length < SPAWN_POSITIONS.BASES.length) {
      const pos = SPAWN_POSITIONS.BASES[this.bases.children.length];
      this.spawnBase(pos.x, pos.y);
      this.baseSpawnTimer = 0;
    }

    // Tank movement and combat
    this.tanks.children.forEach(tank => {
      if (this.bases.children.length === 0) return;

      // Find nearest base
      let nearestBase = this.bases.children[0];
      let nearestDist = this.getDistance(tank, nearestBase);

      this.bases.children.forEach(base => {
        const dist = this.getDistance(tank, base);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestBase = base;
        }
      });

      // Move toward nearest base
      if (nearestDist > 50) {
        const angle = Math.atan2(nearestBase.y - tank.y, nearestBase.x - tank.x);
        tank.x += Math.cos(angle) * this.tankSpeed * elapsedSecs;
        tank.y += Math.sin(angle) * this.tankSpeed * elapsedSecs;
      } else {
        // Attack base
        nearestBase.health -= this.tankDamage * elapsedSecs;
        tank.health -= INITIAL_VALUES.BASE_DAMAGE * elapsedSecs;

        // Check tank death
        if (tank.health <= 0) {
          this.tanks.removeChild(tank);
        }

        // Check base destruction
        if (nearestBase.health <= 0) {
          this.credits += this.baseReward;
          this.bases.removeChild(nearestBase);
        }
      }
    });
  }

  getDistance(obj1, obj2) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  upgradeTankHealth() {
    if (this.credits >= this.tankHealthCost) {
      this.credits -= this.tankHealthCost;
      this.tankHealth *= 1.2;
      this.tankHealthCost *= 2;
    }
  }

  upgradeTankDamage() {
    if (this.credits >= this.tankDamageCost) {
      this.credits -= this.tankDamageCost;
      this.tankDamage *= 1.2;
      this.tankDamageCost *= 2;
    }
  }

  upgradeTankSpeed() {
    if (this.credits >= this.tankSpeedCost) {
      this.credits -= this.tankSpeedCost;
      this.tankSpeed *= 1.2;
      this.tankSpeedCost *= 2;
    }
  }

  upgradeTankCount() {
    if (this.credits >= this.tankCountCost) {
      this.credits -= this.tankCountCost;
      this.tankCount += 1;
      this.tankCountCost *= 2;
      this.spawnTank();
    }
  }

  upgradeBaseReward() {
    if (this.credits >= this.baseRewardCost) {
      this.credits -= this.baseRewardCost;
      this.baseReward *= 1.2;
      this.baseRewardCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: e39b39c9-8233-4c0d-9c09-f6af98c7c9f2
```javascript src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} credits)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Credits: {Math.floor(game.credits)} | Tanks: {game.tankCount} | Tank Health: {Math.floor(game.tankHealth)} | Tank Damage: {Math.floor(game.tankDamage)} | Tank Speed: {Math.floor(game.tankSpeed)} | Base Reward: {Math.floor(game.baseReward)}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeTankHealth()} cost={game.tankHealthCost}>Upgrade Tank Health</Button>
        <Button onClick={() => game.upgradeTankDamage()} cost={game.tankDamageCost}>Upgrade Tank Damage</Button>
        <Button onClick={() => game.upgradeTankSpeed()} cost={game.tankSpeedCost}>Upgrade Tank Speed</Button>
        <Button onClick={() => game.upgradeTankCount()} cost={game.tankCountCost}>Increase Tank Count</Button>
        <Button onClick={() => game.upgradeBaseReward()} cost={game.baseRewardCost}>Increase Base Reward</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the requested features:
- Auto-playing gameplay with tanks attacking bases
- Credit accumulation from destroying bases
- Tank spawning and movement system
- Base spawning and respawning
- Health system for tanks and bases
- All five requested upgrades
- Proper timing system using elapsed seconds
- Appropriate sprite sizes (64x64)
- Complete UI with credits display and upgrade buttons

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
