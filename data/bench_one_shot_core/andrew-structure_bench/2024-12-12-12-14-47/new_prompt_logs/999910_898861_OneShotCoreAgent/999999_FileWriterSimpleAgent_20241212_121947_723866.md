Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data (gameData.js):
- Define initial values for drone count, speed, cargo capacity, etc
- Define base upgrade costs and multipliers
- Define asteroid parameters

2. Asset Manifest (assetManifest.js):
- Add sprites for space station, drone, asteroid, crystal

3. Game Logic (gameLogic.js):
- Track crystal count as score
- Manage drone container and asteroid container
- Handle drone movement between station and asteroids
- Implement mining and depositing mechanics
- Create/remove asteroids as needed
- Add upgrade functions

4. Game UI (GameUI.js):
- Display crystal count
- Show current stats (drones, speeds, capacities)
- Add upgrade buttons with costs

Now, let's implement each file:

# Excerpt ID: 2ac5b2eb-6a37-4b10-beb1-8f7e0b214159
```js src/game/gameData.js
export const INITIAL_VALUES = {
  DRONE_COUNT: 1,
  DRONE_SPEED: 100, // pixels per second
  DRONE_CAPACITY: 10,
  MAX_ASTEROIDS: 3,
  ASTEROID_CAPACITY: 50,
  MINING_TIME: 1, // seconds to mine
};

export const UPGRADE_COSTS = {
  DRONE_COUNT: 100,
  DRONE_SPEED: 50,
  DRONE_CAPACITY: 75,
  MAX_ASTEROIDS: 150,
  ASTEROID_CAPACITY: 125,
};
```

# Excerpt ID: c1ce88d9-1d6c-439b-8d9a-8f961c9cfb94
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  station: {
    path: 'assets/station.png',
    width: 128,
    height: 128
  },
  drone: {
    path: 'assets/drone.png',
    width: 64,
    height: 64
  },
  asteroid: {
    path: 'assets/asteroid.png',
    width: 96,
    height: 96
  }
};
```

# Excerpt ID: ad4e6678-c551-4712-bc92-d3d4d6fcde9e
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x000000,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.crystals = 0;
    this.droneCount = INITIAL_VALUES.DRONE_COUNT;
    this.droneSpeed = INITIAL_VALUES.DRONE_SPEED;
    this.droneCapacity = INITIAL_VALUES.DRONE_CAPACITY;
    this.maxAsteroids = INITIAL_VALUES.MAX_ASTEROIDS;
    this.asteroidCapacity = INITIAL_VALUES.ASTEROID_CAPACITY;
    
    this.droneCost = UPGRADE_COSTS.DRONE_COUNT;
    this.speedCost = UPGRADE_COSTS.DRONE_SPEED;
    this.capacityCost = UPGRADE_COSTS.DRONE_CAPACITY;
    this.asteroidCountCost = UPGRADE_COSTS.MAX_ASTEROIDS;
    this.asteroidCapacityCost = UPGRADE_COSTS.ASTEROID_CAPACITY;

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.app.stage.addChild(this.background);

    // Create station
    this.station = this.getSprite(SPRITES.station);
    this.station.anchor.set(0.5);
    this.station.x = SCREEN_SIZE.width / 2;
    this.station.y = SCREEN_SIZE.height / 2;
    
    // Create containers
    this.drones = new PIXI.Container();
    this.asteroids = new PIXI.Container();

    this.app.stage.addChild(this.station);
    this.app.stage.addChild(this.asteroids);
    this.app.stage.addChild(this.drones);

    // Create initial drones and asteroids
    this.createDrone();
    this.createAsteroid();
  }

  createDrone() {
    const drone = this.getSprite(SPRITES.drone);
    drone.anchor.set(0.5);
    drone.x = this.station.x;
    drone.y = this.station.y;
    drone.cargo = 0;
    drone.state = 'idle'; // idle, moving_to_asteroid, mining, returning
    drone.target = null;
    drone.miningTimer = 0;
    this.drones.addChild(drone);
  }

  createAsteroid() {
    if (this.asteroids.children.length >= this.maxAsteroids) return;

    const asteroid = this.getSprite(SPRITES.asteroid);
    asteroid.anchor.set(0.5);
    asteroid.x = Math.random() * SCREEN_SIZE.width;
    asteroid.y = Math.random() * SCREEN_SIZE.height;
    asteroid.crystals = this.asteroidCapacity;
    asteroid.claimed = false;
    this.asteroids.addChild(asteroid);
  }

  gameLoop(delta) {
    const elapsedSecs = delta / 60;

    this.drones.children.forEach(drone => {
      switch(drone.state) {
        case 'idle':
          const freeAsteroid = this.asteroids.children.find(a => !a.claimed && a.crystals > 0);
          if (freeAsteroid) {
            drone.target = freeAsteroid;
            freeAsteroid.claimed = true;
            drone.state = 'moving_to_asteroid';
          }
          break;

        case 'moving_to_asteroid':
          const toAsteroid = this.moveTo(drone, drone.target.x, drone.target.y, elapsedSecs);
          if (toAsteroid) {
            drone.state = 'mining';
            drone.miningTimer = 0;
          }
          break;

        case 'mining':
          drone.miningTimer += elapsedSecs;
          if (drone.miningTimer >= INITIAL_VALUES.MINING_TIME) {
            const mineAmount = Math.min(
              this.droneCapacity - drone.cargo,
              drone.target.crystals
            );
            drone.cargo += mineAmount;
            drone.target.crystals -= mineAmount;

            if (drone.target.crystals <= 0) {
              this.asteroids.removeChild(drone.target);
              this.createAsteroid();
            }
            drone.state = 'returning';
          }
          break;

        case 'returning':
          const toStation = this.moveTo(drone, this.station.x, this.station.y, elapsedSecs);
          if (toStation) {
            this.crystals += drone.cargo;
            drone.cargo = 0;
            drone.target = null;
            drone.state = 'idle';
          }
          break;
      }
    });

    // Spawn new asteroids if needed
    if (this.asteroids.children.length < this.maxAsteroids) {
      this.createAsteroid();
    }
  }

  moveTo(drone, targetX, targetY, elapsedSecs) {
    const dx = targetX - drone.x;
    const dy = targetY - drone.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < 5) return true;

    const moveDistance = this.droneSpeed * elapsedSecs;
    const ratio = moveDistance / distance;
    
    drone.x += dx * ratio;
    drone.y += dy * ratio;
    drone.rotation = Math.atan2(dy, dx);
    
    return false;
  }

  upgradeDroneCount() {
    if (this.crystals >= this.droneCost) {
      this.crystals -= this.droneCost;
      this.droneCount++;
      this.createDrone();
      this.droneCost *= 2;
    }
  }

  upgradeDroneSpeed() {
    if (this.crystals >= this.speedCost) {
      this.crystals -= this.speedCost;
      this.droneSpeed *= 1.2;
      this.speedCost *= 2;
    }
  }

  upgradeDroneCapacity() {
    if (this.crystals >= this.capacityCost) {
      this.crystals -= this.capacityCost;
      this.droneCapacity = Math.floor(this.droneCapacity * 1.5);
      this.capacityCost *= 2;
    }
  }

  upgradeMaxAsteroids() {
    if (this.crystals >= this.asteroidCountCost) {
      this.crystals -= this.asteroidCountCost;
      this.maxAsteroids++;
      this.createAsteroid();
      this.asteroidCountCost *= 2;
    }
  }

  upgradeAsteroidCapacity() {
    if (this.crystals >= this.asteroidCapacityCost) {
      this.crystals -= this.asteroidCapacityCost;
      this.asteroidCapacity = Math.floor(this.asteroidCapacity * 1.5);
      this.asteroidCapacityCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: bfc8f774-8189-4602-8f69-368356703586
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} crystals)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Crystals: {Math.floor(game.crystals)} | Drones: {game.droneCount} | Speed: {game.droneSpeed.toFixed(1)} | Capacity: {game.droneCapacity} | Max Asteroids: {game.maxAsteroids} | Asteroid Capacity: {game.asteroidCapacity}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeDroneCount()} cost={game.droneCost}>Add Drone</Button>
        <Button onClick={() => game.upgradeDroneSpeed()} cost={game.speedCost}>Upgrade Speed</Button>
        <Button onClick={() => game.upgradeDroneCapacity()} cost={game.capacityCost}>Upgrade Capacity</Button>
        <Button onClick={() => game.upgradeMaxAsteroids()} cost={game.asteroidCountCost}>More Asteroids</Button>
        <Button onClick={() => game.upgradeAsteroidCapacity()} cost={game.asteroidCapacityCost}>Bigger Asteroids</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation follows all the requirements from the overview document and includes:
- Automated drone movement
- Crystal mining and depositing
- Upgrade system with doubling costs
- Simple point-to-point movement
- All necessary UI elements
- Proper timing using elapsedSecs
- Sprite sizes following guidelines

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
