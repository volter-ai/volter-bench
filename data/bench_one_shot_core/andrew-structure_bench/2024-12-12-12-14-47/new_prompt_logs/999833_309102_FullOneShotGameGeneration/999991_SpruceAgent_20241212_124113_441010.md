Role: system
Content: You are an expert software developer. Your job is to make an existing simple UI look like the UI from an advanced video game
__________________
Role: user
Content: The existing codebase of the project is as follows:
```js src/Game.js
import React, { useRef, useState, useEffect } from 'react';
import { Settings } from 'lucide-react';
import { GameLogic } from './game/gameLogic';
import GameUI from './ui/GameUI';
import DebugUI from './ui/DebugUI';

const FRAME_RATE = 30;
const FRAME_INTERVAL = 1000 / FRAME_RATE;

const Game = () => {
  const containerRef = useRef(null);
  const gameRef = useRef(null);
  const [showDebugUI, setShowDebugUI] = useState(false);
  const [, setFrame] = useState(0);

  useEffect(() => {
    if (!containerRef.current) return;

    const game = new GameLogic(containerRef.current);
    window.game = game;
    gameRef.current = game;

    let lastTime = Date.now();
    let intervalId;
    const update = (currentTime) => {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // Force a re-render by updating the frame state
      setFrame(prevFrame => prevFrame + 1);
    };

    intervalId = setInterval(() => {
      update(Date.now());
    }, FRAME_INTERVAL);

    return () => {
      clearInterval(intervalId);
      if (gameRef.current) {
        gameRef.current.destroy();
        gameRef.current = null;
      }
      gameRef.current = null;
    };
  }, []);

  return (
    <div style={{
      position: 'relative',
      width: '800px',
      height: '600px',
      overflow: 'hidden'
    }}>
      <div ref={containerRef} style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%'
      }} />
      {gameRef.current && (
        <>
          <GameUI gameRef={gameRef} />
          {showDebugUI && <DebugUI gameRef={gameRef} />}
        </>
      )}
      <Settings
        onClick={() => setShowDebugUI(!showDebugUI)}
        style={{
          position: 'absolute',
          bottom: '10px',
          right: '10px',
          width: '24px',
          height: '24px',
          cursor: 'pointer',
          color: 'white'
        }}
      />
    </div>
  );
};

export default Game;
```
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAME_CONFIG } from './gameData';

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;
    this.lastTimestamp = performance.now();
    
    // Game values
    this.paddleHeight = INITIAL_VALUES.PADDLE_HEIGHT;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.pointMultiplier = INITIAL_VALUES.POINT_MULTIPLIER;
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.currentBallSpeed = INITIAL_VALUES.BALL_SPEED;
    this.speedScaling = INITIAL_VALUES.SPEED_SCALING;

    // Upgrade costs
    this.paddleHeightCost = UPGRADE_COSTS.PADDLE_HEIGHT;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;
    this.pointMultiplierCost = UPGRADE_COSTS.POINT_MULTIPLIER;
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.speedScalingCost = UPGRADE_COSTS.SPEED_SCALING;

    this.createGameObjects();
    this.app.ticker.add(this.gameLoop.bind(this));
    this.ready = true;
  }

  createGameObjects() {
    // Create paddles
    this.leftPaddle = new PIXI.Graphics();
    this.leftPaddle.beginFill(0xFFFFFF);
    this.leftPaddle.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
    this.leftPaddle.endFill();
    this.leftPaddle.x = GAME_CONFIG.PADDLE_EDGE_MARGIN;
    this.leftPaddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;

    this.rightPaddle = new PIXI.Graphics();
    this.rightPaddle.beginFill(0xFFFFFF);
    this.rightPaddle.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
    this.rightPaddle.endFill();
    this.rightPaddle.x = SCREEN_SIZE.width - GAME_CONFIG.PADDLE_EDGE_MARGIN - GAME_CONFIG.PADDLE_WIDTH;
    this.rightPaddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;

    // Create ball
    this.ball = new PIXI.Graphics();
    this.ball.beginFill(0xFFFFFF);
    this.ball.drawCircle(0, 0, GAME_CONFIG.BALL_SIZE / 2);
    this.ball.endFill();
    this.resetBall();

    this.app.stage.addChild(this.leftPaddle);
    this.app.stage.addChild(this.rightPaddle);
    this.app.stage.addChild(this.ball);
  }

  resetBall() {
    this.ball.x = SCREEN_SIZE.width / 2;
    this.ball.y = SCREEN_SIZE.height / 2;
    this.currentBallSpeed = this.ballSpeed;
    const angle = (Math.random() - 0.5) * Math.PI / 2;
    this.ball.vx = Math.cos(angle) * this.currentBallSpeed * (Math.random() < 0.5 ? 1 : -1);
    this.ball.vy = Math.sin(angle) * this.currentBallSpeed;
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Move paddles towards ball
    this.movePaddle(this.leftPaddle, elapsedSecs);
    this.movePaddle(this.rightPaddle, elapsedSecs);

    // Move ball
    this.ball.x += this.ball.vx * elapsedSecs;
    this.ball.y += this.ball.vy * elapsedSecs;

    // Ball collision with top/bottom
    if (this.ball.y < 0 || this.ball.y > SCREEN_SIZE.height) {
      this.ball.vy *= -1;
    }

    // Ball collision with paddles
    if (this.checkPaddleCollision(this.leftPaddle) || this.checkPaddleCollision(this.rightPaddle)) {
      this.ball.vx *= -1;
      this.currentBallSpeed *= this.speedScaling;
      const speed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
      this.ball.vx = (this.ball.vx / speed) * this.currentBallSpeed;
      this.ball.vy = (this.ball.vy / speed) * this.currentBallSpeed;
      
      // Add score based on current ball speed
      const points = Math.floor(this.currentBallSpeed / 100) * this.pointMultiplier;
      this.score += points;
    }

    // Reset if ball goes past paddle
    if (this.ball.x < 0 || this.ball.x > SCREEN_SIZE.width) {
      this.resetBall();
    }
  }

  movePaddle(paddle, elapsedSecs) {
    const paddleCenter = paddle.y + this.paddleHeight / 2;
    if (Math.abs(paddleCenter - this.ball.y) > 5) {
      const direction = this.ball.y > paddleCenter ? 1 : -1;
      paddle.y += direction * this.paddleSpeed * elapsedSecs;
    }
    paddle.y = Math.max(0, Math.min(SCREEN_SIZE.height - this.paddleHeight, paddle.y));
  }

  checkPaddleCollision(paddle) {
    return this.ball.x >= paddle.x && 
           this.ball.x <= paddle.x + GAME_CONFIG.PADDLE_WIDTH &&
           this.ball.y >= paddle.y && 
           this.ball.y <= paddle.y + this.paddleHeight;
  }

  upgradePaddleHeight() {
    if (this.score >= this.paddleHeightCost) {
      this.score -= this.paddleHeightCost;
      this.paddleHeight += 10;
      this.paddleHeightCost *= 2;
      this.leftPaddle.clear();
      this.rightPaddle.clear();
      this.leftPaddle.beginFill(0xFFFFFF);
      this.rightPaddle.beginFill(0xFFFFFF);
      this.leftPaddle.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
      this.rightPaddle.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
      this.leftPaddle.endFill();
      this.rightPaddle.endFill();
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed += 50;
      this.paddleSpeedCost *= 2;
    }
  }

  upgradePointMultiplier() {
    if (this.score >= this.pointMultiplierCost) {
      this.score -= this.pointMultiplierCost;
      this.pointMultiplier += 1;
      this.pointMultiplierCost *= 2;
    }
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed += 50;
      this.ballSpeedCost *= 2;
    }
  }

  upgradeSpeedScaling() {
    if (this.score >= this.speedScalingCost) {
      this.score -= this.speedScalingCost;
      this.speedScaling += 0.1;
      this.speedScalingCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}

```
```js src/game/gameData.js
export const INITIAL_VALUES = {
  PADDLE_HEIGHT: 100,
  PADDLE_SPEED: 300,
  POINT_MULTIPLIER: 1,
  BALL_SPEED: 200,
  SPEED_SCALING: 1.1
};

export const UPGRADE_COSTS = {
  PADDLE_HEIGHT: 10,
  PADDLE_SPEED: 15,
  POINT_MULTIPLIER: 25,
  BALL_SPEED: 20,
  SPEED_SCALING: 30
};

export const GAME_CONFIG = {
  PADDLE_WIDTH: 20,
  BALL_SIZE: 16,
  PADDLE_EDGE_MARGIN: 50
};

```
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  paddle: {
    path: 'assets/paddle.png',
    width: 20,
    height: 100
  },
  ball: {
    path: 'assets/ball.png',
    width: 16,
    height: 16
  }
};

```
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} points)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Score: {game.score} | Ball Speed: {Math.floor(game.currentBallSpeed)} | Point Multiplier: {game.pointMultiplier}x</p>
    <p>Paddle Height: {game.paddleHeight} | Paddle Speed: {game.paddleSpeed} | Speed Scaling: {game.speedScaling.toFixed(2)}x</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradePaddleHeight()} cost={game.paddleHeightCost}>Upgrade Paddle Height</Button>
        <Button onClick={() => game.upgradePaddleSpeed()} cost={game.paddleSpeedCost}>Upgrade Paddle Speed</Button>
        <Button onClick={() => game.upgradePointMultiplier()} cost={game.pointMultiplierCost}>Upgrade Point Multiplier</Button>
        <Button onClick={() => game.upgradeBallSpeed()} cost={game.ballSpeedCost}>Upgrade Starting Ball Speed</Button>
        <Button onClick={() => game.upgradeSpeedScaling()} cost={game.speedScalingCost}>Upgrade Speed Scaling</Button>
      </div>
    </div>
  );
};

export default GameUI;

```
```js src/game/fontManifest.js
export const FONTS = [
  'Press Start 2P',
  'Roboto:400,700',
  'Orbitron:400,700',
]
```

Only make changes to the GameUI or fontManifest file. Don't change anything about the logic or functionality but make the UI look much better and make it feel like a very well implemented game. You can add multilayered menu interactions.


Make sure that only the essential data (such as currency) is shown in the hud and the other stats are hidden in a stats modal

Upgrades should be in modals and submenus instead of being directly on the screen


Make sure that the theme of your UI matches with the theme of the game

Make sure all modals can be opened and closed

General Implementation Guidelines:
1. Write out all the code of the files you intend to edit. I will be copy-pasting them
2. Do not create new files, add to the existing files in the appropriate locations
3. Do not do any refactoring outside of what you are requested to do

Directions:
In your response, do both steps, one after the other
1. First think carefully and describe in detail how you will implement the game design. Make sure to follow all the guidelines
2. Then write each file, according to the plan

Write out all the files in the format:
```filetype filepath
content
```

MOST IMPORTANT: Do not write "existing code here" or similar placeholders. If a file has been edited in anyway,
EVERY original unchanged line must be rewritten in your output
__________________
Role: assistant
Content: Let me plan out the UI design first:

1. Theme Analysis:
- The game appears to be a futuristic/cyber-themed Pong variant
- The background color (0x222C37) suggests a dark, tech aesthetic
- Will use a neon/cyberpunk color scheme with blues and purples

2. UI Structure:
- Main HUD: Minimal, showing only score and current ball speed
- Modal System:
  * Stats Modal: Detailed game statistics
  * Upgrades Modal: Categories for different upgrade types
  * Settings Modal: Game settings and controls

3. Visual Elements:
- Glowing neon borders
- Semi-transparent dark backgrounds
- Cyber-styled buttons with hover effects
- Animated transitions for modals
- Tech-themed icons for different sections

4. Layout:
- HUD: Top-right corner, minimal
- Modal triggers: Small icons at bottom-right
- Modals: Center screen with blur overlay
- Upgrade categories: Grid layout in upgrade modal

Now, I'll implement these changes in the files:

```js src/game/fontManifest.js
export const FONTS = [
  'Share Tech Mono',
  'Orbitron:400,700',
  'Rajdhani:400,500,700',
]
```

```jsx src/ui/GameUI.js
import React, { useState, useEffect } from 'react';
import { Settings, Activity, ArrowUpCircle, X, BarChart2 } from 'lucide-react';

const Modal = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) return null;
  
  return (
    <div className="modal-overlay" style={{
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.85)',
      backdropFilter: 'blur(4px)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 1000
    }}>
      <div className="modal-content" style={{
        backgroundColor: 'rgba(16, 24, 39, 0.95)',
        border: '1px solid #2563eb',
        borderRadius: '8px',
        padding: '20px',
        width: '80%',
        maxWidth: '600px',
        maxHeight: '80vh',
        overflow: 'auto',
        boxShadow: '0 0 20px rgba(37, 99, 235, 0.2)',
        position: 'relative'
      }}>
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '20px',
          borderBottom: '1px solid rgba(37, 99, 235, 0.3)',
          paddingBottom: '10px'
        }}>
          <h2 style={{
            margin: 0,
            fontFamily: 'Orbitron',
            color: '#60a5fa',
            fontSize: '1.5rem'
          }}>{title}</h2>
          <X
            onClick={onClose}
            style={{
              cursor: 'pointer',
              color: '#60a5fa',
              transition: 'color 0.2s',
            }}
            onMouseOver={(e) => e.currentTarget.style.color = '#93c5fd'}
            onMouseOut={(e) => e.currentTarget.style.color = '#60a5fa'}
          />
        </div>
        {children}
      </div>
    </div>
  );
};

const Button = ({ onClick, children, cost, disabled }) => (
  <button
    onClick={onClick}
    disabled={disabled}
    style={{
      margin: '5px',
      padding: '10px 15px',
      fontSize: '14px',
      color: disabled ? '#4b5563' : '#e5e7eb',
      border: '1px solid',
      borderColor: disabled ? '#374151' : '#2563eb',
      borderRadius: '4px',
      cursor: disabled ? 'not-allowed' : 'pointer',
      backgroundColor: disabled ? '#1f2937' : 'rgba(37, 99, 235, 0.2)',
      fontFamily: 'Rajdhani',
      transition: 'all 0.2s',
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      width: '100%'
    }}
  >
    <span>{children}</span>
    <span style={{ fontSize: '12px', opacity: 0.8 }}>Cost: {cost} points</span>
  </button>
);

const HUD = ({ game }) => (
  <div style={{
    position: 'absolute',
    top: '20px',
    right: '20px',
    padding: '15px',
    backgroundColor: 'rgba(17, 24, 39, 0.8)',
    borderRadius: '8px',
    border: '1px solid #2563eb',
    color: '#60a5fa',
    fontFamily: 'Share Tech Mono',
    fontSize: '1.1rem',
    backdropFilter: 'blur(4px)'
  }}>
    <div>SCORE: {game.score}</div>
    <div>SPEED: {Math.floor(game.currentBallSpeed)}</div>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  const [showStats, setShowStats] = useState(false);
  const [showUpgrades, setShowUpgrades] = useState(false);

  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#e5e7eb' }}>
      <HUD game={game} />
      
      <div style={{
        position: 'absolute',
        bottom: '20px',
        right: '20px',
        display: 'flex',
        gap: '10px'
      }}>
        <BarChart2
          onClick={() => setShowStats(true)}
          style={{
            cursor: 'pointer',
            color: '#60a5fa',
            width: '28px',
            height: '28px'
          }}
        />
        <ArrowUpCircle
          onClick={() => setShowUpgrades(true)}
          style={{
            cursor: 'pointer',
            color: '#60a5fa',
            width: '28px',
            height: '28px'
          }}
        />
      </div>

      <Modal isOpen={showStats} onClose={() => setShowStats(false)} title="Game Statistics">
        <div style={{ display: 'grid', gap: '15px', fontFamily: 'Rajdhani' }}>
          <div>Point Multiplier: {game.pointMultiplier}x</div>
          <div>Paddle Height: {game.paddleHeight}</div>
          <div>Paddle Speed: {game.paddleSpeed}</div>
          <div>Speed Scaling: {game.speedScaling.toFixed(2)}x</div>
          <div>Base Ball Speed: {game.ballSpeed}</div>
        </div>
      </Modal>

      <Modal isOpen={showUpgrades} onClose={() => setShowUpgrades(false)} title="Upgrades">
        <div style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(2, 1fr)',
          gap: '15px',
          padding: '10px'
        }}>
          <Button
            onClick={() => game.upgradePaddleHeight()}
            cost={game.paddleHeightCost}
            disabled={game.score < game.paddleHeightCost}
          >
            Paddle Height
          </Button>
          <Button
            onClick={() => game.upgradePaddleSpeed()}
            cost={game.paddleSpeedCost}
            disabled={game.score < game.paddleSpeedCost}
          >
            Paddle Speed
          </Button>
          <Button
            onClick={() => game.upgradePointMultiplier()}
            cost={game.pointMultiplierCost}
            disabled={game.score < game.pointMultiplierCost}
          >
            Point Multiplier
          </Button>
          <Button
            onClick={() => game.upgradeBallSpeed()}
            cost={game.ballSpeedCost}
            disabled={game.score < game.ballSpeedCost}
          >
            Ball Speed
          </Button>
          <Button
            onClick={() => game.upgradeSpeedScaling()}
            cost={game.speedScalingCost}
            disabled={game.score < game.speedScalingCost}
          >
            Speed Scaling
          </Button>
        </div>
      </Modal>
    </div>
  );
};

export default GameUI;
```

These changes create a sleek, cyberpunk-themed UI with modal-based interactions and minimal HUD elements. The fonts have been updated to match the tech theme, and the UI components now feature neon-like glowing effects and cyber-styled elements.
__________________
