Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Implementation Plan:
- The game is a Pong-like game where paddles hit a ball back and forth
- Main currency is "score" which increases based on ball speed and point multiplier
- There are 5 upgrades available:
  * PADDLE_HEIGHT - Makes paddles taller
  * PADDLE_SPEED - Makes paddles move faster
  * POINT_MULTIPLIER - Increases points gained per hit
  * BALL_SPEED - Increases starting ball speed
  * SPEED_SCALING - Increases how much ball speeds up after each hit

- For the GameAI implementation:
  1. Import all upgrade types and costs from gameData
  2. Track upgrade levels for each upgrade type
  3. getMainCurrency will return game.score
  4. For experimental mode, set score to max and randomly upgrade 0-10 times
  5. Update game stats to show all current values
  6. For upgrade loop, find cheapest available upgrade and buy it
  7. Implement performUpgrade to handle all 5 upgrade types

Now I'll write out the complete GameAI.js file:

# Excerpt ID: a5fb69fe-2971-42e1-b6b7-cf3c46c02174
```javascript src/GameAI.js
import { AIUtils } from './AIUtils';
import { UPGRADE_COSTS } from './game/gameData';

const UPGRADES = [
  'PADDLE_HEIGHT',
  'PADDLE_SPEED', 
  'POINT_MULTIPLIER',
  'BALL_SPEED',
  'SPEED_SCALING'
];

export class GameAI {
  constructor() {
    this.ai = new AIUtils();
    this.game = null;
    this.initialized = false;
    // Initialize upgrade levels for all upgrade types
    this.upgradeLevels = UPGRADES.reduce((acc, upgrade) => {
      acc[upgrade] = 0;
      return acc;
    }, {});
  }

  init() {
    if (!window.game || !window.game.ready) {
      setTimeout(() => this.init(), 100);
      return;
    }
    this.game = window.game;

    if (this.initialized) return;
    this.initialized = true;

    window.game.app.ticker.speed = this.ai.defaultGameSpeed;
    this.ai.updateDebugOverlay('Game speed set to ' + this.ai.defaultGameSpeed + 'x');

    if (this.ai.enabled) {
      this.ai.gameStartTime = Date.now();

      if (this.ai.mode === 'experimental') {
        this.setupExperimentalMode();
      }

      this.ai.startLoggingLoop(this.getMainCurrency.bind(this));
      this.startUpgradeLoop();
      this.updateGameStats();

      setTimeout(() => {
        this.ai.stopAI();
        this.ai.exportLogs();
        this.ai.updateDebugOverlay('Session ended - logs exported');
      }, this.ai.duration);
    }
  }

  getMainCurrency() {
    return this.game.score;
  }

  setupExperimentalMode() {
    // Give infinite currency for experimental mode
    this.game.score = Number.MAX_SAFE_INTEGER;

    // Randomly upgrade each stat between 0-10 times
    UPGRADES.forEach(upgrade => {
      const times = Math.floor(Math.random() * 11); // 0 to 10
      for (let i = 0; i < times; i++) {
        this.performUpgrade(upgrade, 0, true);
      }
    });

    this.ai.updateDebugOverlay('Experimental mode initialized with random upgrades');
  }

  updateGameStats() {
    const stats = {
      Score: this.game.score,
      'Current Ball Speed': Math.floor(this.game.currentBallSpeed),
      'Starting Ball Speed': this.game.ballSpeed,
      'Point Multiplier': this.game.pointMultiplier,
      'Paddle Height': this.game.paddleHeight,
      'Paddle Speed': this.game.paddleSpeed,
      'Speed Scaling': this.game.speedScaling.toFixed(2)
    };

    this.ai.updateDebugOverlay('Game stats updated', stats);
  }

  startUpgradeLoop() {
    if (!this.ai.enabled || this.ai.mode === 'experimental') return;

    this.upgradeInterval = setInterval(() => {
      this.checkCheapestUpgrade();
      this.updateGameStats();
    }, 100);
  }

  checkCheapestUpgrade() {
    let cheapestUpgrade = null;
    let lowestCost = Infinity;

    const costs = {
      'PADDLE_HEIGHT': this.game.paddleHeightCost,
      'PADDLE_SPEED': this.game.paddleSpeedCost,
      'POINT_MULTIPLIER': this.game.pointMultiplierCost,
      'BALL_SPEED': this.game.ballSpeedCost,
      'SPEED_SCALING': this.game.speedScalingCost
    };

    for (const upgrade of UPGRADES) {
      const cost = costs[upgrade];
      if (cost <= this.game.score && cost < lowestCost) {
        cheapestUpgrade = upgrade;
        lowestCost = cost;
      }
    }

    if (cheapestUpgrade) {
      this.performUpgrade(cheapestUpgrade, lowestCost);
    }
  }

  performUpgrade(upgradeName, cost, skipLogging = false) {
    // Increment the upgrade level before performing the upgrade
    this.upgradeLevels[upgradeName]++;
    const currentLevel = this.upgradeLevels[upgradeName];

    switch (upgradeName) {
      case 'PADDLE_HEIGHT':
        this.game.upgradePaddleHeight();
        break;
      case 'PADDLE_SPEED':
        this.game.upgradePaddleSpeed();
        break;
      case 'POINT_MULTIPLIER':
        this.game.upgradePointMultiplier();
        break;
      case 'BALL_SPEED':
        this.game.upgradeBallSpeed();
        break;
      case 'SPEED_SCALING':
        this.game.upgradeSpeedScaling();
        break;
      default:
        console.error(`${upgradeName} is not a valid upgrade`);
    }

    if (!skipLogging) {
      const upgradeInfo = {
        timestamp: Date.now(),
        upgrade: upgradeName,
        cost: cost,
        level: currentLevel
      };

      this.ai.logUpgrade(upgradeInfo);
      this.ai.updateDebugOverlay(`Purchased ${upgradeName} upgrade for ${cost} (Level ${currentLevel})`);
    }
  }
}

const gameAI = new GameAI();
gameAI.init();

if (window.game) {
  window.game.exportAILogs = () => gameAI.ai.exportLogs();
  window.game.clearAILogs = () => gameAI.ai.clearLogs();
}

export default gameAI;
```

This implementation:
1. Imports necessary upgrade costs and defines all upgrade types
2. Tracks levels for each upgrade
3. Uses game.score as main currency
4. Implements experimental mode with infinite score and random upgrades
5. Shows comprehensive game stats in debug overlay
6. Finds and performs cheapest available upgrade in upgrade loop
7. Handles all 5 upgrade types in performUpgrade
8. Properly logs all upgrades and maintains stats

The AI will continuously buy the cheapest available upgrade to optimize score gain, while experimental mode allows testing different upgrade combinations.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
