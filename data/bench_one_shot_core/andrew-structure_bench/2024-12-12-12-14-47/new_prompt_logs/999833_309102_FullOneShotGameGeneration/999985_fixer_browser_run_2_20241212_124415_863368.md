Role: system
Content: You are an expert software developer. Your job is to make an existing simple UI look like the UI from an advanced video game

Here is the effects library you should be using
```js src/lib/effectsLib.js
import {
    Container,
    Graphics,
    Texture,
    Sprite,
    Text,
    RenderTexture
} from 'pixi.js';
import { gsap } from 'gsap';

class ParticleSystem {
    constructor(options = {}) {
        const {
            maxParticles = 30,
            spawnInterval = 2,
            radius = 50,
            ellipticalFactor = 0.4,
            particleTexture
        } = options;

        this.container = new Container();
        this.particles = [];
        this.maxParticles = maxParticles;
        this.spawnTimer = 0;
        this.radius = radius;
        this.ellipticalFactor = ellipticalFactor;
        this.spawnInterval = spawnInterval;
        this.particleTexture = particleTexture;
    }

    createParticle() {
        if (this.particles.length >= this.maxParticles) return;

        const angle = Math.random() * Math.PI * 2;
        const distance = this.radius;

        const particle = new Sprite(this.particleTexture);
        particle.anchor.set(0.5);
        particle.x = Math.cos(angle) * distance;
        particle.y = Math.sin(angle) * distance * this.ellipticalFactor;
        particle.alpha = 0.6;
        particle.scale.set(0.5 + Math.random() * 0.5);

        // Animation properties
        particle.vx = (Math.random() - 0.5) * 0.2;
        particle.vy = -0.5 - Math.random() * 0.5;
        particle.life = 1.0;
        particle.decay = 0.01 + Math.random() * 0.02;

        this.container.addChild(particle);
        this.particles.push(particle);
    }

    update(delta) {
        // Spawn new particles
        this.spawnTimer += delta;
        if (this.spawnTimer >= this.spawnInterval) {
            this.createParticle();
            this.spawnTimer = 0;
        }

        // Update existing particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const particle = this.particles[i];

            particle.x += particle.vx * delta;
            particle.y += particle.vy * delta;
            particle.life -= particle.decay * delta;
            particle.alpha = particle.life * 0.6;

            if (particle.life <= 0) {
                this.container.removeChild(particle);
                this.particles.splice(i, 1);
                particle.destroy();
            }
        }
    }

    destroy() {
        this.particles.forEach(particle => particle.destroy());
        this.container.destroy();
    }
}

export class EffectsLibrary {
    constructor(app) {
        this.app = app;
        this.effects = new Map(); // Store active effects
        this.particleTexture = this.createParticleTexture();
    }

    createParticleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 4;
        canvas.height = 4;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, 8, 8);
        return Texture.from(canvas);
    }

    // Particle System
    createParticleSystem(container, options = {}) {
        const particleSystem = new ParticleSystem({
            ...options,
            particleTexture: this.particleTexture
        });

        container.addChild(particleSystem.container);
        this.effects.set(particleSystem.container, particleSystem);

        return particleSystem;
    }

    createGradientTexture(options = {}) {
        const {
            quality = 256,
            startColor = 'rgba(232, 213, 246, 0.3)',
            middleColor = 'rgba(232, 213, 246, 0.8)',
            endColor = 'rgba(232, 213, 246, 0.3)',
            width = quality,
            height = 1
        } = options;

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;

        const ctx = canvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, width, 0);

        gradient.addColorStop(0, startColor);
        gradient.addColorStop(0.5, middleColor);
        gradient.addColorStop(1, endColor);

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);

        return Texture.from(canvas);
    }

    // Animation Effects
    spawnAnimation(container, options = {}, onComplete) {
        container.scale.set(0);
        container.alpha = 0;

        const {
            initialScale = { x: 1.5, y: 0.5 },
            finalScale = { x: 1, y: 1 },
            duration = 0.4
        } = options;

        gsap.timeline({
            onComplete: () => onComplete?.()
        })
            .to(container, {
                alpha: 1,
                duration: 0.1
            })
            .to(container.scale, {
                x: initialScale.x,
                y: initialScale.y,
                duration: 0.2,
                ease: 'back.out(2)'
            }, '<')
            .to(container.scale, {
                x: finalScale.x,
                y: finalScale.y,
                duration: duration,
                ease: 'elastic.out(1, 0.3)'
            });
    }

    plopAnimation(container, sprite, options = {}, onComplete) {
        const {
            targetX,
            targetY,
            standardHeight,
            initialScale = { x: 1.2, y: 0.8 },
            finalScale = { x: 1, y: 1 },
            bounceHeight = 15,
            duration = 0.2
        } = options;

        gsap.timeline({
            onComplete: () => onComplete?.()
        })
            .to(container, {
                x: targetX,
                y: targetY - bounceHeight - standardHeight / 2,
                rotation: 0,
                duration: duration,
                ease: 'power2.out'
            })
            .to(sprite.scale, {
                x: initialScale.x,
                y: initialScale.y,
                duration: 0.1,
                ease: 'power1.out'
            }, '>')
            .to(container, {
                y: targetY - standardHeight / 2,
                duration: 0.2,
                ease: 'bounce.out'
            }, '<')
            .to(sprite.scale, {
                x: finalScale.x,
                y: finalScale.y,
                duration: 0.5,
                ease: 'elastic.out(1, 0.3)'
            }, '<0.1');
    }

    lungeAnimation(container, targetPosition, options = {}) {
        const {
            lungeDistance = 20,
            duration = 0.15,
            returnDuration = 0.25,
            anticipationDuration = 0.1,    // Pull back duration
            squashAmount = 1.3,            // How much to squash horizontally
            stretchAmount = 0.8,           // How much to stretch vertically
            elasticity = 0.5               // Bounce elasticity
        } = options;

        const originalX = container.x;
        const originalY = container.y;
        const originalScaleX = container.scale.x;
        const originalScaleY = container.scale.y;

        const angle = Math.atan2(targetPosition.y - originalY, targetPosition.x - originalX);

        // Create animation timeline
        const tl = gsap.timeline();

        // 1. Anticipation - Pull back and squish
        tl.to(container, {
            x: originalX - Math.cos(angle) * (lungeDistance * 0.3),
            y: originalY - Math.sin(angle) * (lungeDistance * 0.3),
            scaleX: 0.85,
            scaleY: 1.15,
            duration: anticipationDuration,
            ease: "power1.in"
        })

        // 2. Lunge forward with stretch
        .to(container, {
            x: originalX + Math.cos(angle) * lungeDistance,
            y: originalY + Math.sin(angle) * lungeDistance,
            scaleX: stretchAmount,
            scaleY: squashAmount,
            duration: duration,
            ease: "power2.out"
        })

        // 3. Impact squash
        .to(container, {
            scaleX: squashAmount,
            scaleY: stretchAmount,
            duration: duration * 0.5,
            ease: "power1.out"
        })

        // 4. Return to original position with bounce
        .to(container, {
            x: originalX,
            y: originalY,
            scaleX: originalScaleX,
            scaleY: originalScaleY,
            duration: returnDuration,
            ease: `elastic.out(${elasticity})`,
        });

        return tl; // Return timeline for chaining
    }

    shakeAnimation(container, options = {}) {
        const {
            intensity = 5,
            duration = 0.1
        } = options;

        const originalX = container.x;

        gsap.timeline()
            .to(container, {
                x: originalX - intensity,
                duration: duration
            })
            .to(container, {
                x: originalX + intensity,
                duration: duration
            })
            .to(container, {
                x: originalX - intensity/2,
                duration: duration
            })
            .to(container, {
                x: originalX,
                duration: duration
            });
    }

    showFloatingText(container, text, options = {}) {
        const {
            fontFamily = 'Arial',  // make sure to use an appropriate font for this game's style
            fontSize = 24,
            color = 0xFFFFFF,
            strokeColor = 0x000000,
            strokeThickness = 4,
            floatDistance = 50,
            duration = 1
        } = options;

        const textSprite = new Text(text, {
            fontFamily: fontFamily,
            fontSize: fontSize,
            fill: color,
            stroke: strokeColor,
            strokeThickness: strokeThickness
        });
        textSprite.anchor.set(0.5);
        textSprite.x = 0;
        textSprite.y = -container.height / 2;
        container.addChild(textSprite);

        // Split the animation into two parts
        const halfDuration = duration / 2;

        // First half: only move up, no fade
        gsap.to(textSprite, {
            y: textSprite.y - floatDistance/2,
            duration: halfDuration,
            ease: "power1.out",
            onComplete: () => {
                // Second half: continue moving up and fade out
                gsap.to(textSprite, {
                    y: textSprite.y - floatDistance/2,
                    alpha: 0,
                    duration: halfDuration,
                    ease: "power1.out",
                    onComplete: () => {
                        container.removeChild(textSprite);
                    }
                });
            }
        });
    }

    createShadow(container, sprite, options = {}) {
        const {
            widthRatio = 0.8,
            heightRatio = 0.25,
            alpha = 0.3,
            color = 0x000000,
            offsetY = 0
        } = options;

        const width = sprite.width * widthRatio;
        const height = width * heightRatio;

        const shadow = new Graphics();
        shadow.beginFill(color);
        shadow.drawEllipse(0, 0, width / 2, height / 2);
        shadow.endFill();

        shadow.alpha = alpha;

        // Now we can just position it directly under the sprite's center
        shadow.x = 0 //sprite.width / 2;
        shadow.y = sprite.height / 2 - offsetY;

        container.addChildAt(shadow, 0);
        return shadow;
    }

    idleAnimation(shadow, options = {}) {
        const {
            duration = 2
        } = options;

        gsap.to(shadow.scale, {
            x: 1.1,
            y: 1.05,
            duration: duration / 2,
            ease: 'power1.inOut',
            yoyo: true,
            repeat: -1
        });
    }

    createImpactEffect(container, options = {}) {
        const {
            x = 0,
            y = 0,
            radius = 35,
            color = 0xFFFFFF,
            duration = 0.2,
            alpha = 0.5,
            scaleMultiplier = 3
        } = options;

        const impact = new Graphics();
        impact.beginFill(color);
        impact.drawCircle(0, 0, radius);
        impact.endFill();
        impact.x = x;
        impact.y = y;
        impact.scale.set(1);
        impact.alpha = alpha;
        container.addChild(impact);

        gsap.to(impact.scale, {
            x: scaleMultiplier,
            y: scaleMultiplier,
            duration: duration,
            ease: "power2.out"
        });

        gsap.to(impact, {
            alpha: 0,
            duration: duration,
            ease: "power2.out",
            onComplete: () => {
                container.removeChild(impact);
            }
        });
    }

    createExplosionParticles(stageContainer, options = {}) {
        const {
            x = 0,
            y = 0,
            count = 50,
            color = 0xFFFFFF,
            maxSpeed = 10,
            size = 2,
            duration = 0.5,
            rotationSpeed = 0.1 // New option for rotation speed
        } = options;

        const particles = [];

        for (let i = 0; i < count; i++) {
            const particle = new Graphics();
            particle.beginFill(color);
            // Draw a square instead of a circle, centered at 0,0
            particle.drawRect(-size, -size, size * 2, size * 2);
            particle.endFill();
            particle.x = x;
            particle.y = y;
            particle.vx = (Math.random() - 0.5) * maxSpeed;
            particle.vy = (Math.random() - 0.5) * maxSpeed;
            particle.rotation = Math.random() * Math.PI * 2; // Random initial rotation
            particle.rotationVelocity = (Math.random() - 0.5) * rotationSpeed; // Random rotation direction and speed
            particle.alpha = 1;
            stageContainer.addChild(particle);
            particles.push(particle);
        }

        const cleanupParticles = () => {
            particles.forEach(particle => {
                if (particle.parent) {
                    stageContainer.removeChild(particle);
                }
                particle.destroy();
            });
            particles.length = 0;
        };

        let active = true;
        const updateParticles = (delta) => {
            if (!active) return;

            let allDead = true;
            particles.forEach(particle => {
                if (particle.alpha > 0) {
                    allDead = false;
                    particle.x += particle.vx * delta;
                    particle.y += particle.vy * delta;
                    particle.rotation += particle.rotationVelocity * delta; // Update rotation
                    particle.alpha -= delta / duration / 60;
                }
            });

            if (allDead) {
                active = false;
                cleanupParticles();
            }
        };

        // Add to game loop
        this.app.ticker.add(updateParticles);
    }

    createSpiralParticles(stageContainer, options = {}) {
        const {
            x = 0,
            y = 0,
            count = 20,
            color = 0x7FFFD4, // Default to aquamarine color
            size = 3,
            duration = 1.2,
            amplitude = 30, // Controls how wide the S-curve is
            frequency = 2, // Controls how many S-curves appear
            baseSpeed = 2, // Base upward speed
            sparkleRate = 0.1 // How often particles change size for sparkle effect
        } = options;

        const particles = [];

        // Initialize particles in a circular pattern at the base
        for (let i = 0; i < count; i++) {
            const particle = new Graphics();
            particle.beginFill(color);

            // Create a diamond shape
            particle.moveTo(0, -size);
            particle.lineTo(size, 0);
            particle.lineTo(0, size);
            particle.lineTo(-size, 0);
            particle.lineTo(0, -size);

            particle.endFill();

            // Starting position: circular pattern at the base
            const angle = (i / count) * Math.PI * 2;
            const radius = Math.random() * 15;
            particle.x = x + Math.cos(angle) * radius;
            particle.y = y + Math.sin(angle) * radius;

            // Properties for S-curve movement
            particle.startX = particle.x;
            particle.time = Math.random() * Math.PI * 2; // Random starting phase
            particle.speed = baseSpeed * (0.8 + Math.random() * 0.4); // Slight speed variation
            particle.alpha = 1;
            particle.scale.set(0.8 + Math.random() * 0.4);

            // Sparkle properties
            particle.sparkleTime = 0;
            particle.originalScale = particle.scale.x;

            stageContainer.addChild(particle);
            particles.push(particle);
        }

        const cleanupParticles = () => {
            particles.forEach(particle => {
                if (particle.parent) {
                    stageContainer.removeChild(particle);
                }
                particle.destroy();
            });
            particles.length = 0;
        };

        let active = true;
        const updateParticles = (delta) => {
            if (!active) return;

            let allDead = true;
            particles.forEach(particle => {
                if (particle.alpha > 0) {
                    allDead = false;

                    // Update particle position
                    particle.time += delta * 0.05;
                    particle.y -= particle.speed * delta;

                    // Create S-curve movement
                    const xOffset = Math.sin(particle.time * frequency) * amplitude;
                    particle.x = particle.startX + xOffset;

                    // Fade out as particles rise
                    particle.alpha -= delta / duration / 60;

                    // Sparkle effect
                    particle.sparkleTime += delta;
                    if (particle.sparkleTime >= sparkleRate) {
                        particle.sparkleTime = 0;
                        // Randomly adjust scale for sparkle effect
                        const scaleFactor = 0.8 + Math.random() * 0.4;
                        particle.scale.set(particle.originalScale * scaleFactor);
                    }

                    // Add slight rotation
                    particle.rotation += delta * 0.02;
                }
            });

            if (allDead) {
                active = false;
                cleanupParticles();
            }
        };

        // Add to game loop
        this.app.ticker.add(updateParticles);
    }

    flashColor(target, options = {}) {
        const {
            color = 0xFFFFFF,
            flashDuration = 0.2,
        } = options;

        // Prevent multiple animations from running simultaneously
        if (target.isAnimatingHit) return;
        target.isAnimatingHit = true;

        const originalTexture = target.texture;

        const whiteTexture = this.createWhiteTexture(originalTexture);
        target.texture = whiteTexture;
        const originalColor = target.tint;
        target.tint = color;

        gsap.to({}, {
            duration: flashDuration,
            onComplete: () => {
                target.isAnimatingHit = false;
                target.texture = originalTexture;
                target.tint = originalColor;
                if (whiteTexture) {
                    whiteTexture.destroy(true);
                }
            }
        });
    }

    screenShake(stageContainer, options = {}) {
        const {
            intensity = 10,
            duration = 0.5,
            frequency = 0.05
        } = options;

        const originalX = stageContainer.x;
        const originalY = stageContainer.y;

        gsap.to(stageContainer, {
            x: `+=${Math.random() * intensity - intensity / 2}`,
            y: `+=${Math.random() * intensity - intensity / 2}`,
            duration: frequency,
            repeat: Math.floor(duration / frequency),
            yoyo: true,
            ease: "none",
            onComplete: () => {
                stageContainer.x = originalX;
                stageContainer.y = originalY;
            }
        });
    }

    // Helper method to create white texture
    createWhiteTexture(originalTexture) {
        // Create a temporary canvas
        const canvas = document.createElement('canvas');
        canvas.width = originalTexture.width;
        canvas.height = originalTexture.height;
        const ctx = canvas.getContext('2d');

        // Create a sprite from the original texture
        const sprite = new Sprite(originalTexture);

        // Create a render texture
        const renderTexture = RenderTexture.create({
            width: originalTexture.width,
            height: originalTexture.height,
            scaleMode: originalTexture.baseTexture.scaleMode
        });

        // Render the sprite to the render texture
        console.log(sprite, renderTexture)
        this.app.renderer.render(sprite,
            renderTexture,
        );

        // Extract the canvas
        const extractedCanvas = this.app.renderer.extract.canvas(renderTexture);
        ctx.drawImage(extractedCanvas, 0, 0);

        // Get the image data
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        // Convert to white while preserving alpha
        for (let i = 0; i < data.length; i += 4) {
            if (data[i + 3] > 0) {
                data[i] = 255;     // Red
                data[i + 1] = 255; // Green
                data[i + 2] = 255; // Blue
                // Keep original alpha
            }
        }

        // Put the modified image data back
        ctx.putImageData(imageData, 0, 0);

        // Create new texture
        const whiteTexture = Texture.from(canvas);

        // Clean up
        renderTexture.destroy(true);

        return whiteTexture;
    }

    createSpriteBorder(texture, options = {}) {
        const {
            borderProportion = 0.05,
            color = 0xFFFFFF
        } = options;
        const container = new Container();

        // Create the border sprite (slightly larger and colored)
        const whiteTexture = this.createWhiteTexture(texture);
        const borderSprite = new Sprite(whiteTexture);
        borderSprite.tint = color;
        borderSprite.scale.set(1 + borderProportion); // Make it slightly larger
        borderSprite.anchor.set(0.5);

        // Create the main sprite
        const mainSprite = new Sprite(texture);
        mainSprite.anchor.set(0.5);

        // Add both sprites to the container, border first
        container.addChild(borderSprite);
        container.addChild(mainSprite);

        return container;
    }


    highlightCharacter(sprite, options = {}) {
        const originalTint = sprite.tint;
        const {
            color = 0xFFFF00,
            duration = 0.3
        } = options;
        gsap.to(sprite, {
            tint: color,
            duration: duration,
            yoyo: true,
            repeat: 1,
            onComplete: () => {
                sprite.tint = originalTint; // Reset tint
            }
        });
    }

    // Cleanup
    destroyParticleSystem(system) {
        system.destroy();
        this.effects.delete(system.container);
    }

    destroyAll() {
        for (const [container, system] of this.effects) {
            this.destroyParticleSystem(system);
        }
        this.effects.clear();
    }
}

```
__________________
Role: user
Content: The existing boilerplate codebase of the project is as follows:
```js src/Game.js
import React, { useRef, useState, useEffect } from 'react';
import { Settings } from 'lucide-react';
import { GameLogic } from './game/gameLogic';
import GameUI from './ui/GameUI';
import DebugUI from './ui/DebugUI';

const FRAME_RATE = 30;
const FRAME_INTERVAL = 1000 / FRAME_RATE;

const Game = () => {
  const containerRef = useRef(null);
  const gameRef = useRef(null);
  const [showDebugUI, setShowDebugUI] = useState(false);
  const [, setFrame] = useState(0);

  useEffect(() => {
    if (!containerRef.current) return;

    const game = new GameLogic(containerRef.current);
    window.game = game;
    gameRef.current = game;

    let lastTime = Date.now();
    let intervalId;
    const update = (currentTime) => {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // Force a re-render by updating the frame state
      setFrame(prevFrame => prevFrame + 1);
    };

    intervalId = setInterval(() => {
      update(Date.now());
    }, FRAME_INTERVAL);

    return () => {
      clearInterval(intervalId);
      if (gameRef.current) {
        gameRef.current.destroy();
        gameRef.current = null;
      }
      gameRef.current = null;
    };
  }, []);

  return (
    <div style={{
      position: 'relative',
      width: '800px',
      height: '600px',
      overflow: 'hidden'
    }}>
      <div ref={containerRef} style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%'
      }} />
      {gameRef.current && (
        <>
          <GameUI gameRef={gameRef} />
          {showDebugUI && <DebugUI gameRef={gameRef} />}
        </>
      )}
      <Settings
        onClick={() => setShowDebugUI(!showDebugUI)}
        style={{
          position: 'absolute',
          bottom: '10px',
          right: '10px',
          width: '24px',
          height: '24px',
          cursor: 'pointer',
          color: 'white'
        }}
      />
    </div>
  );
};

export default Game;
```
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAME_CONFIG } from './gameData';

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;
    this.lastTimestamp = performance.now();
    
    // Game values
    this.paddleHeight = INITIAL_VALUES.PADDLE_HEIGHT;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.pointMultiplier = INITIAL_VALUES.POINT_MULTIPLIER;
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.currentBallSpeed = INITIAL_VALUES.BALL_SPEED;
    this.speedScaling = INITIAL_VALUES.SPEED_SCALING;

    // Upgrade costs
    this.paddleHeightCost = UPGRADE_COSTS.PADDLE_HEIGHT;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;
    this.pointMultiplierCost = UPGRADE_COSTS.POINT_MULTIPLIER;
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.speedScalingCost = UPGRADE_COSTS.SPEED_SCALING;

    this.createGameObjects();
    this.app.ticker.add(this.gameLoop.bind(this));
    this.ready = true;
  }

  createGameObjects() {
    // Create paddles
    this.leftPaddle = new PIXI.Graphics();
    this.leftPaddle.beginFill(0xFFFFFF);
    this.leftPaddle.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
    this.leftPaddle.endFill();
    this.leftPaddle.x = GAME_CONFIG.PADDLE_EDGE_MARGIN;
    this.leftPaddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;

    this.rightPaddle = new PIXI.Graphics();
    this.rightPaddle.beginFill(0xFFFFFF);
    this.rightPaddle.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
    this.rightPaddle.endFill();
    this.rightPaddle.x = SCREEN_SIZE.width - GAME_CONFIG.PADDLE_EDGE_MARGIN - GAME_CONFIG.PADDLE_WIDTH;
    this.rightPaddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;

    // Create ball
    this.ball = new PIXI.Graphics();
    this.ball.beginFill(0xFFFFFF);
    this.ball.drawCircle(0, 0, GAME_CONFIG.BALL_SIZE / 2);
    this.ball.endFill();
    this.resetBall();

    this.app.stage.addChild(this.leftPaddle);
    this.app.stage.addChild(this.rightPaddle);
    this.app.stage.addChild(this.ball);
  }

  resetBall() {
    this.ball.x = SCREEN_SIZE.width / 2;
    this.ball.y = SCREEN_SIZE.height / 2;
    this.currentBallSpeed = this.ballSpeed;
    const angle = (Math.random() - 0.5) * Math.PI / 2;
    this.ball.vx = Math.cos(angle) * this.currentBallSpeed * (Math.random() < 0.5 ? 1 : -1);
    this.ball.vy = Math.sin(angle) * this.currentBallSpeed;
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Move paddles towards ball
    this.movePaddle(this.leftPaddle, elapsedSecs);
    this.movePaddle(this.rightPaddle, elapsedSecs);

    // Move ball
    this.ball.x += this.ball.vx * elapsedSecs;
    this.ball.y += this.ball.vy * elapsedSecs;

    // Ball collision with top/bottom
    if (this.ball.y < 0 || this.ball.y > SCREEN_SIZE.height) {
      this.ball.vy *= -1;
    }

    // Ball collision with paddles
    if (this.checkPaddleCollision(this.leftPaddle) || this.checkPaddleCollision(this.rightPaddle)) {
      this.ball.vx *= -1;
      this.currentBallSpeed *= this.speedScaling;
      const speed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
      this.ball.vx = (this.ball.vx / speed) * this.currentBallSpeed;
      this.ball.vy = (this.ball.vy / speed) * this.currentBallSpeed;
      
      // Add score based on current ball speed
      const points = Math.floor(this.currentBallSpeed / 100) * this.pointMultiplier;
      this.score += points;
    }

    // Reset if ball goes past paddle
    if (this.ball.x < 0 || this.ball.x > SCREEN_SIZE.width) {
      this.resetBall();
    }
  }

  movePaddle(paddle, elapsedSecs) {
    const paddleCenter = paddle.y + this.paddleHeight / 2;
    if (Math.abs(paddleCenter - this.ball.y) > 5) {
      const direction = this.ball.y > paddleCenter ? 1 : -1;
      paddle.y += direction * this.paddleSpeed * elapsedSecs;
    }
    paddle.y = Math.max(0, Math.min(SCREEN_SIZE.height - this.paddleHeight, paddle.y));
  }

  checkPaddleCollision(paddle) {
    return this.ball.x >= paddle.x && 
           this.ball.x <= paddle.x + GAME_CONFIG.PADDLE_WIDTH &&
           this.ball.y >= paddle.y && 
           this.ball.y <= paddle.y + this.paddleHeight;
  }

  upgradePaddleHeight() {
    if (this.score >= this.paddleHeightCost) {
      this.score -= this.paddleHeightCost;
      this.paddleHeight += 10;
      this.paddleHeightCost *= 2;
      this.leftPaddle.clear();
      this.rightPaddle.clear();
      this.leftPaddle.beginFill(0xFFFFFF);
      this.rightPaddle.beginFill(0xFFFFFF);
      this.leftPaddle.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
      this.rightPaddle.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
      this.leftPaddle.endFill();
      this.rightPaddle.endFill();
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed += 50;
      this.paddleSpeedCost *= 2;
    }
  }

  upgradePointMultiplier() {
    if (this.score >= this.pointMultiplierCost) {
      this.score -= this.pointMultiplierCost;
      this.pointMultiplier += 1;
      this.pointMultiplierCost *= 2;
    }
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed += 50;
      this.ballSpeedCost *= 2;
    }
  }

  upgradeSpeedScaling() {
    if (this.score >= this.speedScalingCost) {
      this.score -= this.speedScalingCost;
      this.speedScaling += 0.1;
      this.speedScalingCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}

```
```js src/game/gameData.js
export const INITIAL_VALUES = {
  PADDLE_HEIGHT: 100,
  PADDLE_SPEED: 300,
  POINT_MULTIPLIER: 1,
  BALL_SPEED: 200,
  SPEED_SCALING: 1.1
};

export const UPGRADE_COSTS = {
  PADDLE_HEIGHT: 10,
  PADDLE_SPEED: 15,
  POINT_MULTIPLIER: 25,
  BALL_SPEED: 20,
  SPEED_SCALING: 30
};

export const GAME_CONFIG = {
  PADDLE_WIDTH: 20,
  BALL_SIZE: 16,
  PADDLE_EDGE_MARGIN: 50
};

```
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  paddle: {
    path: 'assets/paddle.png',
    width: 20,
    height: 100
  },
  ball: {
    path: 'assets/ball.png',
    width: 16,
    height: 16
  }
};

```
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';
import { Settings, Activity, ArrowUpCircle, X, BarChart2 } from 'lucide-react';

const Modal = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) return null;
  
  return (
    <div className="modal-overlay" style={{
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.85)',
      backdropFilter: 'blur(4px)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 1000
    }}>
      <div className="modal-content" style={{
        backgroundColor: 'rgba(16, 24, 39, 0.95)',
        border: '1px solid #2563eb',
        borderRadius: '8px',
        padding: '20px',
        width: '80%',
        maxWidth: '600px',
        maxHeight: '80vh',
        overflow: 'auto',
        boxShadow: '0 0 20px rgba(37, 99, 235, 0.2)',
        position: 'relative'
      }}>
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '20px',
          borderBottom: '1px solid rgba(37, 99, 235, 0.3)',
          paddingBottom: '10px'
        }}>
          <h2 style={{
            margin: 0,
            fontFamily: 'Orbitron',
            color: '#60a5fa',
            fontSize: '1.5rem'
          }}>{title}</h2>
          <X
            onClick={onClose}
            style={{
              cursor: 'pointer',
              color: '#60a5fa',
              transition: 'color 0.2s',
            }}
            onMouseOver={(e) => e.currentTarget.style.color = '#93c5fd'}
            onMouseOut={(e) => e.currentTarget.style.color = '#60a5fa'}
          />
        </div>
        {children}
      </div>
    </div>
  );
};

const Button = ({ onClick, children, cost, disabled }) => (
  <button
    onClick={onClick}
    disabled={disabled}
    style={{
      margin: '5px',
      padding: '10px 15px',
      fontSize: '14px',
      color: disabled ? '#4b5563' : '#e5e7eb',
      border: '1px solid',
      borderColor: disabled ? '#374151' : '#2563eb',
      borderRadius: '4px',
      cursor: disabled ? 'not-allowed' : 'pointer',
      backgroundColor: disabled ? '#1f2937' : 'rgba(37, 99, 235, 0.2)',
      fontFamily: 'Rajdhani',
      transition: 'all 0.2s',
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      width: '100%'
    }}
  >
    <span>{children}</span>
    <span style={{ fontSize: '12px', opacity: 0.8 }}>Cost: {cost} points</span>
  </button>
);

const HUD = ({ game }) => (
  <div style={{
    position: 'absolute',
    top: '20px',
    right: '20px',
    padding: '15px',
    backgroundColor: 'rgba(17, 24, 39, 0.8)',
    borderRadius: '8px',
    border: '1px solid #2563eb',
    color: '#60a5fa',
    fontFamily: 'Share Tech Mono',
    fontSize: '1.1rem',
    backdropFilter: 'blur(4px)'
  }}>
    <div>SCORE: {game.score}</div>
    <div>SPEED: {Math.floor(game.currentBallSpeed)}</div>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  const [showStats, setShowStats] = useState(false);
  const [showUpgrades, setShowUpgrades] = useState(false);

  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#e5e7eb' }}>
      <HUD game={game} />
      
      <div style={{
        position: 'absolute',
        bottom: '20px',
        right: '20px',
        display: 'flex',
        gap: '10px'
      }}>
        <BarChart2
          onClick={() => setShowStats(true)}
          style={{
            cursor: 'pointer',
            color: '#60a5fa',
            width: '28px',
            height: '28px'
          }}
        />
        <ArrowUpCircle
          onClick={() => setShowUpgrades(true)}
          style={{
            cursor: 'pointer',
            color: '#60a5fa',
            width: '28px',
            height: '28px'
          }}
        />
      </div>

      <Modal isOpen={showStats} onClose={() => setShowStats(false)} title="Game Statistics">
        <div style={{ display: 'grid', gap: '15px', fontFamily: 'Rajdhani' }}>
          <div>Point Multiplier: {game.pointMultiplier}x</div>
          <div>Paddle Height: {game.paddleHeight}</div>
          <div>Paddle Speed: {game.paddleSpeed}</div>
          <div>Speed Scaling: {game.speedScaling.toFixed(2)}x</div>
          <div>Base Ball Speed: {game.ballSpeed}</div>
        </div>
      </Modal>

      <Modal isOpen={showUpgrades} onClose={() => setShowUpgrades(false)} title="Upgrades">
        <div style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(2, 1fr)',
          gap: '15px',
          padding: '10px'
        }}>
          <Button
            onClick={() => game.upgradePaddleHeight()}
            cost={game.paddleHeightCost}
            disabled={game.score < game.paddleHeightCost}
          >
            Paddle Height
          </Button>
          <Button
            onClick={() => game.upgradePaddleSpeed()}
            cost={game.paddleSpeedCost}
            disabled={game.score < game.paddleSpeedCost}
          >
            Paddle Speed
          </Button>
          <Button
            onClick={() => game.upgradePointMultiplier()}
            cost={game.pointMultiplierCost}
            disabled={game.score < game.pointMultiplierCost}
          >
            Point Multiplier
          </Button>
          <Button
            onClick={() => game.upgradeBallSpeed()}
            cost={game.ballSpeedCost}
            disabled={game.score < game.ballSpeedCost}
          >
            Ball Speed
          </Button>
          <Button
            onClick={() => game.upgradeSpeedScaling()}
            cost={game.speedScalingCost}
            disabled={game.score < game.speedScalingCost}
          >
            Speed Scaling
          </Button>
        </div>
      </Modal>
    </div>
  );
};

export default GameUI;

```

Only make changes to `src/gameLogic.js`

Don't change anything about the logic or functionality of the game but add effects and particles to make the game look good. 

First talk about all the things that happen in the game that could have corresponding effects to make it look good, every event in the game should create an effect from the effectsLib

We should make sure all the entities are pixi containers (rather than just sprites). If they are sprites, they should be attached to the container. This makes the effects work better

-

General Implementation Guidelines:
1. Write out all the code of the files you intend to edit. I will be copy-pasting them
2. Do not create new files, add to the existing files in the appropriate locations
3. Do not do any refactoring outside of what you are requested to do

Directions:
In your response, do both steps, one after the other
1. First think carefully and describe in detail how you will implement the game design. Make sure to follow all the guidelines
2. Then write each file, according to the plan

Write out all the files in the format:
```filetype filepath
content
```

MOST IMPORTANT: Do not write "existing code here" or similar placeholders. If a file has been edited in anyway,
EVERY original unchanged line must be rewritten in your output
__________________
Role: assistant
Content: Let's analyze the game events that could benefit from effects:

1. Ball-Paddle Collision Events:
- Impact effect at collision point
- Screen shake for dramatic feel
- Particle burst in ball's direction
- Flash effect on the paddle
- Score floating text showing points earned

2. Ball-Wall (Top/Bottom) Collision:
- Smaller impact effect
- Minimal screen shake
- Smaller particle burst

3. Ball Reset (When going past paddles):
- Spiral particle effect at ball spawn point
- Spawn animation for ball

4. Paddle Movement:
- Trailing particles behind paddle during movement
- Shadow under paddle
- Subtle idle animation

5. Score/Upgrade Events:
- Floating text for points
- Highlight effect on upgraded paddle
- Particle burst from upgraded paddle

Implementation Plan:
1. Initialize EffectsLibrary in GameLogic constructor
2. Convert existing Graphics objects to Containers with sprites
3. Add effects to each collision event
4. Add continuous effects (trails, shadows)
5. Add upgrade effects

Here's the implementation:

```javascript src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAME_CONFIG } from './gameData';
import { EffectsLibrary } from '../lib/effectsLib';

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);
    
    // Initialize effects library
    this.effects = new EffectsLibrary(this.app);

    this.ready = false;
    this.score = 0;
    this.lastTimestamp = performance.now();
    
    // Game values
    this.paddleHeight = INITIAL_VALUES.PADDLE_HEIGHT;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.pointMultiplier = INITIAL_VALUES.POINT_MULTIPLIER;
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.currentBallSpeed = INITIAL_VALUES.BALL_SPEED;
    this.speedScaling = INITIAL_VALUES.SPEED_SCALING;

    // Upgrade costs
    this.paddleHeightCost = UPGRADE_COSTS.PADDLE_HEIGHT;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;
    this.pointMultiplierCost = UPGRADE_COSTS.POINT_MULTIPLIER;
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.speedScalingCost = UPGRADE_COSTS.SPEED_SCALING;

    this.createGameObjects();
    this.app.ticker.add(this.gameLoop.bind(this));
    this.ready = true;
  }

  createGameObjects() {
    // Create paddle containers
    this.leftPaddle = new PIXI.Container();
    this.rightPaddle = new PIXI.Container();

    // Create paddle graphics
    const leftPaddleGraphics = new PIXI.Graphics();
    leftPaddleGraphics.beginFill(0xFFFFFF);
    leftPaddleGraphics.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
    leftPaddleGraphics.endFill();

    const rightPaddleGraphics = new PIXI.Graphics();
    rightPaddleGraphics.beginFill(0xFFFFFF);
    rightPaddleGraphics.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
    rightPaddleGraphics.endFill();

    this.leftPaddle.addChild(leftPaddleGraphics);
    this.rightPaddle.addChild(rightPaddleGraphics);

    this.leftPaddle.x = GAME_CONFIG.PADDLE_EDGE_MARGIN;
    this.leftPaddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;
    this.rightPaddle.x = SCREEN_SIZE.width - GAME_CONFIG.PADDLE_EDGE_MARGIN - GAME_CONFIG.PADDLE_WIDTH;
    this.rightPaddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;

    // Create ball container
    this.ballContainer = new PIXI.Container();
    
    // Create ball graphics
    this.ball = new PIXI.Graphics();
    this.ball.beginFill(0xFFFFFF);
    this.ball.drawCircle(0, 0, GAME_CONFIG.BALL_SIZE / 2);
    this.ball.endFill();
    
    this.ballContainer.addChild(this.ball);

    // Create shadows
    this.effects.createShadow(this.leftPaddle, leftPaddleGraphics);
    this.effects.createShadow(this.rightPaddle, rightPaddleGraphics);
    this.effects.createShadow(this.ballContainer, this.ball);

    // Add idle animations
    this.effects.idleAnimation(this.leftPaddle);
    this.effects.idleAnimation(this.rightPaddle);

    this.resetBall();

    this.app.stage.addChild(this.leftPaddle);
    this.app.stage.addChild(this.rightPaddle);
    this.app.stage.addChild(this.ballContainer);

    // Create particle systems for paddles
    this.leftPaddleParticles = this.effects.createParticleSystem(this.leftPaddle);
    this.rightPaddleParticles = this.effects.createParticleSystem(this.rightPaddle);
  }

  resetBall() {
    this.ballContainer.x = SCREEN_SIZE.width / 2;
    this.ballContainer.y = SCREEN_SIZE.height / 2;
    this.currentBallSpeed = this.ballSpeed;
    const angle = (Math.random() - 0.5) * Math.PI / 2;
    this.ballContainer.vx = Math.cos(angle) * this.currentBallSpeed * (Math.random() < 0.5 ? 1 : -1);
    this.ballContainer.vy = Math.sin(angle) * this.currentBallSpeed;

    // Spawn animation
    this.effects.spawnAnimation(this.ballContainer);
    this.effects.createSpiralParticles(this.app.stage, {
      x: this.ballContainer.x,
      y: this.ballContainer.y
    });
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Move paddles towards ball
    this.movePaddle(this.leftPaddle, elapsedSecs);
    this.movePaddle(this.rightPaddle, elapsedSecs);

    // Move ball
    this.ballContainer.x += this.ballContainer.vx * elapsedSecs;
    this.ballContainer.y += this.ballContainer.vy * elapsedSecs;

    // Ball collision with top/bottom
    if (this.ballContainer.y < 0 || this.ballContainer.y > SCREEN_SIZE.height) {
      this.ballContainer.vy *= -1;
      
      // Wall collision effects
      this.effects.createImpactEffect(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y,
        color: 0x4444FF
      });
      this.effects.screenShake(this.app.stage, { intensity: 3 });
    }

    // Ball collision with paddles
    if (this.checkPaddleCollision(this.leftPaddle) || this.checkPaddleCollision(this.rightPaddle)) {
      const hitPaddle = this.checkPaddleCollision(this.leftPaddle) ? this.leftPaddle : this.rightPaddle;
      
      this.ballContainer.vx *= -1;
      this.currentBallSpeed *= this.speedScaling;
      const speed = Math.sqrt(this.ballContainer.vx * this.ballContainer.vx + this.ballContainer.vy * this.ballContainer.vy);
      this.ballContainer.vx = (this.ballContainer.vx / speed) * this.currentBallSpeed;
      this.ballContainer.vy = (this.ballContainer.vy / speed) * this.currentBallSpeed;
      
      // Add score based on current ball speed
      const points = Math.floor(this.currentBallSpeed / 100) * this.pointMultiplier;
      this.score += points;

      // Collision effects
      this.effects.createImpactEffect(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y
      });
      this.effects.screenShake(this.app.stage, { intensity: 5 });
      this.effects.flashColor(hitPaddle.children[0], { color: 0xFFFFFF });
      this.effects.showFloatingText(hitPaddle, `+${points}`);
      this.effects.createExplosionParticles(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y,
        color: 0xFFFFFF
      });
    }

    // Reset if ball goes past paddle
    if (this.ballContainer.x < 0 || this.ballContainer.x > SCREEN_SIZE.width) {
      this.resetBall();
    }
  }

  movePaddle(paddle, elapsedSecs) {
    const paddleCenter = paddle.y + this.paddleHeight / 2;
    if (Math.abs(paddleCenter - this.ballContainer.y) > 5) {
      const direction = this.ballContainer.y > paddleCenter ? 1 : -1;
      paddle.y += direction * this.paddleSpeed * elapsedSecs;
    }
    paddle.y = Math.max(0, Math.min(SCREEN_SIZE.height - this.paddleHeight, paddle.y));
  }

  checkPaddleCollision(paddle) {
    return this.ballContainer.x >= paddle.x && 
           this.ballContainer.x <= paddle.x + GAME_CONFIG.PADDLE_WIDTH &&
           this.ballContainer.y >= paddle.y && 
           this.ballContainer.y <= paddle.y + this.paddleHeight;
  }

  upgradePaddleHeight() {
    if (this.score >= this.paddleHeightCost) {
      this.score -= this.paddleHeightCost;
      this.paddleHeight += 10;
      this.paddleHeightCost *= 2;

      // Recreate paddles with new height
      this.leftPaddle.removeChildren();
      this.rightPaddle.removeChildren();

      const leftPaddleGraphics = new PIXI.Graphics();
      const rightPaddleGraphics = new PIXI.Graphics();
      
      leftPaddleGraphics.beginFill(0xFFFFFF);
      rightPaddleGraphics.beginFill(0xFFFFFF);
      leftPaddleGraphics.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
      rightPaddleGraphics.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
      leftPaddleGraphics.endFill();
      rightPaddleGraphics.endFill();

      this.leftPaddle.addChild(leftPaddleGraphics);
      this.rightPaddle.addChild(rightPaddleGraphics);

      // Upgrade effects
      this.effects.highlightCharacter(leftPaddleGraphics);
      this.effects.highlightCharacter(rightPaddleGraphics);
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.leftPaddle.x,
        y: this.leftPaddle.y + this.paddleHeight/2
      });
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.rightPaddle.x,
        y: this.rightPaddle.y + this.paddleHeight/2
      });
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed += 50;
      this.paddleSpeedCost *= 2;

      // Upgrade effects
      this.effects.highlightCharacter(this.leftPaddle.children[0]);
      this.effects.highlightCharacter(this.rightPaddle.children[0]);
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.leftPaddle.x,
        y: this.leftPaddle.y + this.paddleHeight/2
      });
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.rightPaddle.x,
        y: this.rightPaddle.y + this.paddleHeight/2
      });
    }
  }

  upgradePointMultiplier() {
    if (this.score >= this.pointMultiplierCost) {
      this.score -= this.pointMultiplierCost;
      this.pointMultiplier += 1;
      this.pointMultiplierCost *= 2;

      // Upgrade effects
      this.effects.createSpiralParticles(this.app.stage, {
        x: SCREEN_SIZE.width/2,
        y: SCREEN_SIZE.height/2,
        color: 0xFFD700
      });
    }
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed += 50;
      this.ballSpeedCost *= 2;

      // Upgrade effects
      this.effects.highlightCharacter(this.ball);
      this.effects.createExplosionParticles(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y,
        color: 0xFF4444
      });
    }
  }

  upgradeSpeedScaling() {
    if (this.score >= this.speedScalingCost) {
      this.score -= this.speedScalingCost;
      this.speedScaling += 0.1;
      this.speedScalingCost *= 2;

      // Upgrade effects
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y,
        color: 0x44FF44
      });
    }
  }

  destroy() {
    this.effects.destroyAll();
    this.app.destroy(true);
  }
}
```

This implementation adds rich visual feedback to every game event while maintaining the original game logic. The effects make the game feel more dynamic and responsive, with particles, flashes, and animations providing clear feedback for all player actions and game events.
__________________
Role: user
Content: there was an issue [issue redacted] with the implementation, fix it
__________________
Role: assistant
Content: Let's trace the error:

The error "Cannot read properties of undefined (reading 'width')" typically occurs when trying to access the 'width' property of an undefined object. In this case, it's happening in the effects library when trying to create shadows.

The issue is in these lines:
```javascript
// Create shadows
this.effects.createShadow(this.leftPaddle, leftPaddleGraphics);
this.effects.createShadow(this.rightPaddle, rightPaddleGraphics);
this.effects.createShadow(this.ballContainer, this.ball);
```

The createShadow method expects a sprite with width and height properties, but we're passing Graphics objects which don't have these properties in the same way. We need to get the width and height from the drawn graphics.

Here's the fixed implementation:

```javascript src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAME_CONFIG } from './gameData';
import { EffectsLibrary } from '../lib/effectsLib';

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);
    
    // Initialize effects library
    this.effects = new EffectsLibrary(this.app);

    this.ready = false;
    this.score = 0;
    this.lastTimestamp = performance.now();
    
    // Game values
    this.paddleHeight = INITIAL_VALUES.PADDLE_HEIGHT;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.pointMultiplier = INITIAL_VALUES.POINT_MULTIPLIER;
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.currentBallSpeed = INITIAL_VALUES.BALL_SPEED;
    this.speedScaling = INITIAL_VALUES.SPEED_SCALING;

    // Upgrade costs
    this.paddleHeightCost = UPGRADE_COSTS.PADDLE_HEIGHT;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;
    this.pointMultiplierCost = UPGRADE_COSTS.POINT_MULTIPLIER;
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.speedScalingCost = UPGRADE_COSTS.SPEED_SCALING;

    this.createGameObjects();
    this.app.ticker.add(this.gameLoop.bind(this));
    this.ready = true;
  }

  createGameObjects() {
    // Create paddle containers
    this.leftPaddle = new PIXI.Container();
    this.rightPaddle = new PIXI.Container();

    // Create paddle graphics
    const leftPaddleGraphics = new PIXI.Graphics();
    leftPaddleGraphics.beginFill(0xFFFFFF);
    leftPaddleGraphics.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
    leftPaddleGraphics.endFill();

    const rightPaddleGraphics = new PIXI.Graphics();
    rightPaddleGraphics.beginFill(0xFFFFFF);
    rightPaddleGraphics.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
    rightPaddleGraphics.endFill();

    this.leftPaddle.addChild(leftPaddleGraphics);
    this.rightPaddle.addChild(rightPaddleGraphics);

    this.leftPaddle.x = GAME_CONFIG.PADDLE_EDGE_MARGIN;
    this.leftPaddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;
    this.rightPaddle.x = SCREEN_SIZE.width - GAME_CONFIG.PADDLE_EDGE_MARGIN - GAME_CONFIG.PADDLE_WIDTH;
    this.rightPaddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;

    // Create ball container
    this.ballContainer = new PIXI.Container();
    
    // Create ball graphics
    this.ball = new PIXI.Graphics();
    this.ball.beginFill(0xFFFFFF);
    this.ball.drawCircle(0, 0, GAME_CONFIG.BALL_SIZE / 2);
    this.ball.endFill();
    
    this.ballContainer.addChild(this.ball);

    // Create shadows with explicit dimensions
    this.effects.createShadow(this.leftPaddle, {
      width: GAME_CONFIG.PADDLE_WIDTH,
      height: this.paddleHeight
    });
    this.effects.createShadow(this.rightPaddle, {
      width: GAME_CONFIG.PADDLE_WIDTH,
      height: this.paddleHeight
    });
    this.effects.createShadow(this.ballContainer, {
      width: GAME_CONFIG.BALL_SIZE,
      height: GAME_CONFIG.BALL_SIZE
    });

    // Add idle animations
    this.effects.idleAnimation(this.leftPaddle);
    this.effects.idleAnimation(this.rightPaddle);

    this.resetBall();

    this.app.stage.addChild(this.leftPaddle);
    this.app.stage.addChild(this.rightPaddle);
    this.app.stage.addChild(this.ballContainer);

    // Create particle systems for paddles
    this.leftPaddleParticles = this.effects.createParticleSystem(this.leftPaddle);
    this.rightPaddleParticles = this.effects.createParticleSystem(this.rightPaddle);
  }

  resetBall() {
    this.ballContainer.x = SCREEN_SIZE.width / 2;
    this.ballContainer.y = SCREEN_SIZE.height / 2;
    this.currentBallSpeed = this.ballSpeed;
    const angle = (Math.random() - 0.5) * Math.PI / 2;
    this.ballContainer.vx = Math.cos(angle) * this.currentBallSpeed * (Math.random() < 0.5 ? 1 : -1);
    this.ballContainer.vy = Math.sin(angle) * this.currentBallSpeed;

    // Spawn animation
    this.effects.spawnAnimation(this.ballContainer);
    this.effects.createSpiralParticles(this.app.stage, {
      x: this.ballContainer.x,
      y: this.ballContainer.y
    });
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Move paddles towards ball
    this.movePaddle(this.leftPaddle, elapsedSecs);
    this.movePaddle(this.rightPaddle, elapsedSecs);

    // Move ball
    this.ballContainer.x += this.ballContainer.vx * elapsedSecs;
    this.ballContainer.y += this.ballContainer.vy * elapsedSecs;

    // Ball collision with top/bottom
    if (this.ballContainer.y < 0 || this.ballContainer.y > SCREEN_SIZE.height) {
      this.ballContainer.vy *= -1;
      
      // Wall collision effects
      this.effects.createImpactEffect(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y,
        color: 0x4444FF
      });
      this.effects.screenShake(this.app.stage, { intensity: 3 });
    }

    // Ball collision with paddles
    if (this.checkPaddleCollision(this.leftPaddle) || this.checkPaddleCollision(this.rightPaddle)) {
      const hitPaddle = this.checkPaddleCollision(this.leftPaddle) ? this.leftPaddle : this.rightPaddle;
      
      this.ballContainer.vx *= -1;
      this.currentBallSpeed *= this.speedScaling;
      const speed = Math.sqrt(this.ballContainer.vx * this.ballContainer.vx + this.ballContainer.vy * this.ballContainer.vy);
      this.ballContainer.vx = (this.ballContainer.vx / speed) * this.currentBallSpeed;
      this.ballContainer.vy = (this.ballContainer.vy / speed) * this.currentBallSpeed;
      
      // Add score based on current ball speed
      const points = Math.floor(this.currentBallSpeed / 100) * this.pointMultiplier;
      this.score += points;

      // Collision effects
      this.effects.createImpactEffect(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y
      });
      this.effects.screenShake(this.app.stage, { intensity: 5 });
      this.effects.flashColor(hitPaddle.children[0], { color: 0xFFFFFF });
      this.effects.showFloatingText(hitPaddle, `+${points}`);
      this.effects.createExplosionParticles(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y,
        color: 0xFFFFFF
      });
    }

    // Reset if ball goes past paddle
    if (this.ballContainer.x < 0 || this.ballContainer.x > SCREEN_SIZE.width) {
      this.resetBall();
    }
  }

  movePaddle(paddle, elapsedSecs) {
    const paddleCenter = paddle.y + this.paddleHeight / 2;
    if (Math.abs(paddleCenter - this.ballContainer.y) > 5) {
      const direction = this.ballContainer.y > paddleCenter ? 1 : -1;
      paddle.y += direction * this.paddleSpeed * elapsedSecs;
    }
    paddle.y = Math.max(0, Math.min(SCREEN_SIZE.height - this.paddleHeight, paddle.y));
  }

  checkPaddleCollision(paddle) {
    return this.ballContainer.x >= paddle.x && 
           this.ballContainer.x <= paddle.x + GAME_CONFIG.PADDLE_WIDTH &&
           this.ballContainer.y >= paddle.y && 
           this.ballContainer.y <= paddle.y + this.paddleHeight;
  }

  upgradePaddleHeight() {
    if (this.score >= this.paddleHeightCost) {
      this.score -= this.paddleHeightCost;
      this.paddleHeight += 10;
      this.paddleHeightCost *= 2;

      // Recreate paddles with new height
      this.leftPaddle.removeChildren();
      this.rightPaddle.removeChildren();

      const leftPaddleGraphics = new PIXI.Graphics();
      const rightPaddleGraphics = new PIXI.Graphics();
      
      leftPaddleGraphics.beginFill(0xFFFFFF);
      rightPaddleGraphics.beginFill(0xFFFFFF);
      leftPaddleGraphics.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
      rightPaddleGraphics.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
      leftPaddleGraphics.endFill();
      rightPaddleGraphics.endFill();

      this.leftPaddle.addChild(leftPaddleGraphics);
      this.rightPaddle.addChild(rightPaddleGraphics);

      // Upgrade effects
      this.effects.highlightCharacter(leftPaddleGraphics);
      this.effects.highlightCharacter(rightPaddleGraphics);
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.leftPaddle.x,
        y: this.leftPaddle.y + this.paddleHeight/2
      });
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.rightPaddle.x,
        y: this.rightPaddle.y + this.paddleHeight/2
      });
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed += 50;
      this.paddleSpeedCost *= 2;

      // Upgrade effects
      this.effects.highlightCharacter(this.leftPaddle.children[0]);
      this.effects.highlightCharacter(this.rightPaddle.children[0]);
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.leftPaddle.x,
        y: this.leftPaddle.y + this.paddleHeight/2
      });
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.rightPaddle.x,
        y: this.rightPaddle.y + this.paddleHeight/2
      });
    }
  }

  upgradePointMultiplier() {
    if (this.score >= this.pointMultiplierCost) {
      this.score -= this.pointMultiplierCost;
      this.pointMultiplier += 1;
      this.pointMultiplierCost *= 2;

      // Upgrade effects
      this.effects.createSpiralParticles(this.app.stage, {
        x: SCREEN_SIZE.width/2,
        y: SCREEN_SIZE.height/2,
        color: 0xFFD700
      });
    }
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed += 50;
      this.ballSpeedCost *= 2;

      // Upgrade effects
      this.effects.highlightCharacter(this.ball);
      this.effects.createExplosionParticles(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y,
        color: 0xFF4444
      });
    }
  }

  upgradeSpeedScaling() {
    if (this.score >= this.speedScalingCost) {
      this.score -= this.speedScalingCost;
      this.speedScaling += 0.1;
      this.speedScalingCost *= 2;

      // Upgrade effects
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y,
        color: 0x44FF44
      });
    }
  }

  destroy() {
    this.effects.destroyAll();
    this.app.destroy(true);
  }
}
```

The key change is that instead of passing the graphics objects directly to createShadow, we now pass an object with explicit width and height properties. This ensures the shadow creation has the correct dimensions regardless of the internal implementation of the graphics objects.
__________________
Role: user
Content: there was an issue [issue redacted] with the implementation, fix it
__________________
Role: user
Content: Message: Console errors detected in app
Errors:
Type: Uncaught Exception
Cannot read properties of undefined (reading 'width')
---




Directions:

In your response, do all these steps, one after the other

1. For each failure, carefully trace through the code that caused the issue, showing me the lines that actually caused the error. Explain how those lines would be changed to solve the problem. If the problem is not actually caused by those lines, diagnose the problem

2. Write each file which has a required change, according to the plan. Write out every line of the file, including lines that are unchanged



Write out all the files in the format:

```filetype filepath

content

```



MOST IMPORTANT: Do not write "existing code here" or similar placeholders. If a file has been edited in anyway,

EVERY original unchanged line must be rewritten in your output
__________________
Role: assistant
Content: Let's trace the error:

The error "Cannot read properties of undefined (reading 'width')" is occurring in the effectsLib when trying to create a white texture. Looking at the code, this happens in the flashColor method when we try to create a white version of the texture, but we're passing a Graphics object instead of a Sprite with a texture.

The problematic line is:
```javascript
this.effects.flashColor(hitPaddle.children[0], { color: 0xFFFFFF });
```

Graphics objects don't have textures, so we can't create a white version of them. We need to modify our approach to handle Graphics objects differently than Sprites.

Here's the fixed implementation:

```javascript src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAME_CONFIG } from './gameData';
import { EffectsLibrary } from '../lib/effectsLib';

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);
    
    // Initialize effects library
    this.effects = new EffectsLibrary(this.app);

    this.ready = false;
    this.score = 0;
    this.lastTimestamp = performance.now();
    
    // Game values
    this.paddleHeight = INITIAL_VALUES.PADDLE_HEIGHT;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.pointMultiplier = INITIAL_VALUES.POINT_MULTIPLIER;
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.currentBallSpeed = INITIAL_VALUES.BALL_SPEED;
    this.speedScaling = INITIAL_VALUES.SPEED_SCALING;

    // Upgrade costs
    this.paddleHeightCost = UPGRADE_COSTS.PADDLE_HEIGHT;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;
    this.pointMultiplierCost = UPGRADE_COSTS.POINT_MULTIPLIER;
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.speedScalingCost = UPGRADE_COSTS.SPEED_SCALING;

    this.createGameObjects();
    this.app.ticker.add(this.gameLoop.bind(this));
    this.ready = true;
  }

  createGameObjects() {
    // Create paddle containers
    this.leftPaddle = new PIXI.Container();
    this.rightPaddle = new PIXI.Container();

    // Create paddle graphics
    const leftPaddleGraphics = new PIXI.Graphics();
    leftPaddleGraphics.beginFill(0xFFFFFF);
    leftPaddleGraphics.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
    leftPaddleGraphics.endFill();

    const rightPaddleGraphics = new PIXI.Graphics();
    rightPaddleGraphics.beginFill(0xFFFFFF);
    rightPaddleGraphics.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
    rightPaddleGraphics.endFill();

    this.leftPaddle.addChild(leftPaddleGraphics);
    this.rightPaddle.addChild(rightPaddleGraphics);

    this.leftPaddle.x = GAME_CONFIG.PADDLE_EDGE_MARGIN;
    this.leftPaddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;
    this.rightPaddle.x = SCREEN_SIZE.width - GAME_CONFIG.PADDLE_EDGE_MARGIN - GAME_CONFIG.PADDLE_WIDTH;
    this.rightPaddle.y = SCREEN_SIZE.height / 2 - this.paddleHeight / 2;

    // Create ball container
    this.ballContainer = new PIXI.Container();
    
    // Create ball graphics
    this.ball = new PIXI.Graphics();
    this.ball.beginFill(0xFFFFFF);
    this.ball.drawCircle(0, 0, GAME_CONFIG.BALL_SIZE / 2);
    this.ball.endFill();
    
    this.ballContainer.addChild(this.ball);

    // Create shadows with explicit dimensions
    this.effects.createShadow(this.leftPaddle, {
      width: GAME_CONFIG.PADDLE_WIDTH,
      height: this.paddleHeight
    });
    this.effects.createShadow(this.rightPaddle, {
      width: GAME_CONFIG.PADDLE_WIDTH,
      height: this.paddleHeight
    });
    this.effects.createShadow(this.ballContainer, {
      width: GAME_CONFIG.BALL_SIZE,
      height: GAME_CONFIG.BALL_SIZE
    });

    // Add idle animations
    this.effects.idleAnimation(this.leftPaddle);
    this.effects.idleAnimation(this.rightPaddle);

    this.resetBall();

    this.app.stage.addChild(this.leftPaddle);
    this.app.stage.addChild(this.rightPaddle);
    this.app.stage.addChild(this.ballContainer);

    // Create particle systems for paddles
    this.leftPaddleParticles = this.effects.createParticleSystem(this.leftPaddle);
    this.rightPaddleParticles = this.effects.createParticleSystem(this.rightPaddle);
  }

  resetBall() {
    this.ballContainer.x = SCREEN_SIZE.width / 2;
    this.ballContainer.y = SCREEN_SIZE.height / 2;
    this.currentBallSpeed = this.ballSpeed;
    const angle = (Math.random() - 0.5) * Math.PI / 2;
    this.ballContainer.vx = Math.cos(angle) * this.currentBallSpeed * (Math.random() < 0.5 ? 1 : -1);
    this.ballContainer.vy = Math.sin(angle) * this.currentBallSpeed;

    // Spawn animation
    this.effects.spawnAnimation(this.ballContainer);
    this.effects.createSpiralParticles(this.app.stage, {
      x: this.ballContainer.x,
      y: this.ballContainer.y
    });
  }

  gameLoop() {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Move paddles towards ball
    this.movePaddle(this.leftPaddle, elapsedSecs);
    this.movePaddle(this.rightPaddle, elapsedSecs);

    // Move ball
    this.ballContainer.x += this.ballContainer.vx * elapsedSecs;
    this.ballContainer.y += this.ballContainer.vy * elapsedSecs;

    // Ball collision with top/bottom
    if (this.ballContainer.y < 0 || this.ballContainer.y > SCREEN_SIZE.height) {
      this.ballContainer.vy *= -1;
      
      // Wall collision effects
      this.effects.createImpactEffect(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y,
        color: 0x4444FF
      });
      this.effects.screenShake(this.app.stage, { intensity: 3 });
    }

    // Ball collision with paddles
    if (this.checkPaddleCollision(this.leftPaddle) || this.checkPaddleCollision(this.rightPaddle)) {
      const hitPaddle = this.checkPaddleCollision(this.leftPaddle) ? this.leftPaddle : this.rightPaddle;
      
      this.ballContainer.vx *= -1;
      this.currentBallSpeed *= this.speedScaling;
      const speed = Math.sqrt(this.ballContainer.vx * this.ballContainer.vx + this.ballContainer.vy * this.ballContainer.vy);
      this.ballContainer.vx = (this.ballContainer.vx / speed) * this.currentBallSpeed;
      this.ballContainer.vy = (this.ballContainer.vy / speed) * this.currentBallSpeed;
      
      // Add score based on current ball speed
      const points = Math.floor(this.currentBallSpeed / 100) * this.pointMultiplier;
      this.score += points;

      // Collision effects
      this.effects.createImpactEffect(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y
      });
      this.effects.screenShake(this.app.stage, { intensity: 5 });
      
      // Instead of flash effect, temporarily change the tint of the paddle
      const paddleGraphics = hitPaddle.children[0];
      const originalTint = paddleGraphics.tint;
      paddleGraphics.tint = 0xFFFFFF;
      setTimeout(() => {
        paddleGraphics.tint = originalTint;
      }, 100);
      
      this.effects.showFloatingText(hitPaddle, `+${points}`);
      this.effects.createExplosionParticles(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y,
        color: 0xFFFFFF
      });
    }

    // Reset if ball goes past paddle
    if (this.ballContainer.x < 0 || this.ballContainer.x > SCREEN_SIZE.width) {
      this.resetBall();
    }
  }

  movePaddle(paddle, elapsedSecs) {
    const paddleCenter = paddle.y + this.paddleHeight / 2;
    if (Math.abs(paddleCenter - this.ballContainer.y) > 5) {
      const direction = this.ballContainer.y > paddleCenter ? 1 : -1;
      paddle.y += direction * this.paddleSpeed * elapsedSecs;
    }
    paddle.y = Math.max(0, Math.min(SCREEN_SIZE.height - this.paddleHeight, paddle.y));
  }

  checkPaddleCollision(paddle) {
    return this.ballContainer.x >= paddle.x && 
           this.ballContainer.x <= paddle.x + GAME_CONFIG.PADDLE_WIDTH &&
           this.ballContainer.y >= paddle.y && 
           this.ballContainer.y <= paddle.y + this.paddleHeight;
  }

  upgradePaddleHeight() {
    if (this.score >= this.paddleHeightCost) {
      this.score -= this.paddleHeightCost;
      this.paddleHeight += 10;
      this.paddleHeightCost *= 2;

      // Recreate paddles with new height
      this.leftPaddle.removeChildren();
      this.rightPaddle.removeChildren();

      const leftPaddleGraphics = new PIXI.Graphics();
      const rightPaddleGraphics = new PIXI.Graphics();
      
      leftPaddleGraphics.beginFill(0xFFFFFF);
      rightPaddleGraphics.beginFill(0xFFFFFF);
      leftPaddleGraphics.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
      rightPaddleGraphics.drawRect(0, 0, GAME_CONFIG.PADDLE_WIDTH, this.paddleHeight);
      leftPaddleGraphics.endFill();
      rightPaddleGraphics.endFill();

      this.leftPaddle.addChild(leftPaddleGraphics);
      this.rightPaddle.addChild(rightPaddleGraphics);

      // Upgrade effects
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.leftPaddle.x,
        y: this.leftPaddle.y + this.paddleHeight/2
      });
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.rightPaddle.x,
        y: this.rightPaddle.y + this.paddleHeight/2
      });
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed += 50;
      this.paddleSpeedCost *= 2;

      // Upgrade effects
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.leftPaddle.x,
        y: this.leftPaddle.y + this.paddleHeight/2
      });
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.rightPaddle.x,
        y: this.rightPaddle.y + this.paddleHeight/2
      });
    }
  }

  upgradePointMultiplier() {
    if (this.score >= this.pointMultiplierCost) {
      this.score -= this.pointMultiplierCost;
      this.pointMultiplier += 1;
      this.pointMultiplierCost *= 2;

      // Upgrade effects
      this.effects.createSpiralParticles(this.app.stage, {
        x: SCREEN_SIZE.width/2,
        y: SCREEN_SIZE.height/2,
        color: 0xFFD700
      });
    }
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed += 50;
      this.ballSpeedCost *= 2;

      // Upgrade effects
      this.effects.createExplosionParticles(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y,
        color: 0xFF4444
      });
    }
  }

  upgradeSpeedScaling() {
    if (this.score >= this.speedScalingCost) {
      this.score -= this.speedScalingCost;
      this.speedScaling += 0.1;
      this.speedScalingCost *= 2;

      // Upgrade effects
      this.effects.createSpiralParticles(this.app.stage, {
        x: this.ballContainer.x,
        y: this.ballContainer.y,
        color: 0x44FF44
      });
    }
  }

  destroy() {
    this.effects.destroyAll();
    this.app.destroy(true);
  }
}
```

The main changes are:
1. Removed the flashColor effect calls since they don't work with Graphics objects
2. Replaced them with simple tint changes using setTimeout
3. Removed highlightCharacter calls which also depended on textures
4. Simplified the upgrade effects to use only particle effects

This should resolve the texture-related errors while maintaining visual feedback for game events.
__________________
