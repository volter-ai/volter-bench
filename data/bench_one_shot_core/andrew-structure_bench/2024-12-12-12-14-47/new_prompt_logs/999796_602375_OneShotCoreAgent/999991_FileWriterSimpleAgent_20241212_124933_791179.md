Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let's trace the error:

1. Error Analysis:
# Excerpt ID: 30186694-7141-4533-a3b0-f05e57d62464
```javascript
// In gameLogic.js:
getSprite(spriteConfig) {
  const texture = this.resources[spriteConfig.path].texture; // Error here
  // ...
}
```

The error occurs because `this.resources[spriteConfig.path]` is undefined. Looking at the loader:

# Excerpt ID: 389b22f0-551e-4eed-baa9-90fc83b17377
```javascript
// In utils.js:
Object.entries(assetManifest).forEach(([key, config]) => {
  loader.add(key, config.path);
});
```

The issue is that we're using the path as the key in getSprite, but we registered the assets with their manifest key. We need to use the key instead of the path.

Here are the fixed files:

# Excerpt ID: 7856ffeb-9ab0-4bb6-a2b4-501c0f1e5029
```js src/game/utils.js
import * as PIXI from 'pixi.js';

export function loadAssets(assetManifest, onComplete) {
  const loader = PIXI.Loader.shared;
  
  // Add all assets to the loader
  Object.entries(assetManifest).forEach(([key, config]) => {
    loader.add(key, config.path);
  });

  // Start loading
  loader.load((loader, resources) => {
    onComplete(resources);
  });
}
```

# Excerpt ID: 36dced35-4866-4ae9-a4cd-dd38f272a6ef
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.credits = 0;
    this.tankSpeed = INITIAL_VALUES.TANK_SPEED;
    this.tankDamage = INITIAL_VALUES.TANK_DAMAGE;
    this.tankRange = INITIAL_VALUES.TANK_RANGE;
    this.tankArmor = INITIAL_VALUES.TANK_ARMOR;
    this.tankCount = INITIAL_VALUES.TANK_COUNT;
    this.enemySpawnRate = INITIAL_VALUES.ENEMY_SPAWN_RATE;
    
    this.tankSpeedCost = UPGRADE_COSTS.TANK_SPEED;
    this.tankDamageCost = UPGRADE_COSTS.TANK_DAMAGE;
    this.tankRangeCost = UPGRADE_COSTS.TANK_RANGE;
    this.tankArmorCost = UPGRADE_COSTS.TANK_ARMOR;
    this.tankCountCost = UPGRADE_COSTS.TANK_COUNT;
    this.enemySpawnRateCost = UPGRADE_COSTS.ENEMY_SPAWN_RATE;

    this.spawnTimer = 0;
    this.lastTimestamp = performance.now();
    this.resources = null;

    loadAssets(SPRITES, (resources) => {
      this.resources = resources;
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(key, spriteConfig) {
    const texture = this.resources[key].texture;
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite('background', SPRITES.background);
    this.friendlyTanks = new PIXI.Container();
    this.enemyTanks = new PIXI.Container();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.friendlyTanks);
    this.app.stage.addChild(this.enemyTanks);

    for (let i = 0; i < this.tankCount; i++) {
      this.createFriendlyTank();
    }
  }

  createFriendlyTank() {
    const tank = this.getSprite('friendlyTank', SPRITES.friendlyTank);
    tank.anchor.set(0.5);
    tank.x = Math.random() * (this.app.screen.width / 2);
    tank.y = Math.random() * this.app.screen.height;
    tank.health = this.tankArmor;
    tank.targetX = Math.random() * (this.app.screen.width / 2);
    tank.targetY = Math.random() * this.app.screen.height;
    tank.shootTimer = 0;
    this.friendlyTanks.addChild(tank);
  }

  createEnemyTank() {
    const tank = this.getSprite('enemyTank', SPRITES.enemyTank);
    tank.anchor.set(0.5);
    tank.x = this.app.screen.width;
    tank.y = Math.random() * this.app.screen.height;
    tank.health = INITIAL_VALUES.ENEMY_HEALTH;
    
    const healthBar = new PIXI.Graphics();
    healthBar.beginFill(0xff0000);
    healthBar.drawRect(-32, -40, 64, 5);
    healthBar.endFill();
    tank.addChild(healthBar);
    tank.healthBar = healthBar;
    
    this.enemyTanks.addChild(tank);
  }

  // ... rest of the file remains exactly the same ...
}
```

Key changes:
1. Modified getSprite to take the key and spriteConfig
2. Updated all getSprite calls to pass the key
3. The resources object now uses the manifest keys instead of paths

The rest of the implementation remains unchanged. This should resolve the texture loading errors while maintaining all game functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
