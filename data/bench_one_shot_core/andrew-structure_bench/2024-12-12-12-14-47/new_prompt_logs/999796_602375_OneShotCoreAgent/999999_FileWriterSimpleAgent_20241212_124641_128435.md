Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data (gameData.js):
- Define initial values for tank stats: speed, damage, range, armor
- Define initial costs for upgrades
- Define enemy tank stats and credit reward values

2. Asset Manifest (assetManifest.js):
- Add sprites for friendly tank, enemy tank
- Keep existing background

3. Game Logic (gameLogic.js):
- Track credits as score
- Create containers for friendly tanks and enemy tanks
- Implement tank movement logic:
  * Friendly tanks patrol random points when no enemies nearby
  * Move towards enemies when in range
- Implement shooting mechanics
- Implement enemy spawning system with timer
- Implement health system for tanks
- Add collision detection
- Add upgrade functions

4. Game UI (GameUI.js):
- Display credits
- Add upgrade buttons with costs
- Show current stats

Now, I'll implement each file:

# Excerpt ID: 0c7e4b39-c969-470c-a50c-69b49d751176
```js src/game/gameData.js
export const INITIAL_VALUES = {
  TANK_SPEED: 100,
  TANK_DAMAGE: 10,
  TANK_RANGE: 200,
  TANK_ARMOR: 100,
  TANK_COUNT: 1,
  ENEMY_SPAWN_RATE: 1,
  ENEMY_HEALTH: 50,
  ENEMY_SPEED: 60,
  ENEMY_DAMAGE: 5,
  CREDITS_PER_KILL: 10
};

export const UPGRADE_COSTS = {
  TANK_SPEED: 50,
  TANK_DAMAGE: 100,
  TANK_RANGE: 75,
  TANK_ARMOR: 150,
  TANK_COUNT: 200,
  ENEMY_SPAWN_RATE: 125
};
```

# Excerpt ID: cc68a25f-9e0d-4966-8710-4cd117f524fb
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  friendlyTank: {
    path: 'assets/friendly_tank.png',
    width: 64,
    height: 64
  },
  enemyTank: {
    path: 'assets/enemy_tank.png',
    width: 64,
    height: 64
  }
};
```

# Excerpt ID: 04179078-436f-44ec-ba34-f50a0c182631
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.credits = 0;
    this.tankSpeed = INITIAL_VALUES.TANK_SPEED;
    this.tankDamage = INITIAL_VALUES.TANK_DAMAGE;
    this.tankRange = INITIAL_VALUES.TANK_RANGE;
    this.tankArmor = INITIAL_VALUES.TANK_ARMOR;
    this.tankCount = INITIAL_VALUES.TANK_COUNT;
    this.enemySpawnRate = INITIAL_VALUES.ENEMY_SPAWN_RATE;
    
    this.tankSpeedCost = UPGRADE_COSTS.TANK_SPEED;
    this.tankDamageCost = UPGRADE_COSTS.TANK_DAMAGE;
    this.tankRangeCost = UPGRADE_COSTS.TANK_RANGE;
    this.tankArmorCost = UPGRADE_COSTS.TANK_ARMOR;
    this.tankCountCost = UPGRADE_COSTS.TANK_COUNT;
    this.enemySpawnRateCost = UPGRADE_COSTS.ENEMY_SPAWN_RATE;

    this.spawnTimer = 0;
    this.lastTimestamp = performance.now();

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.friendlyTanks = new PIXI.Container();
    this.enemyTanks = new PIXI.Container();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.friendlyTanks);
    this.app.stage.addChild(this.enemyTanks);

    for (let i = 0; i < this.tankCount; i++) {
      this.createFriendlyTank();
    }
  }

  createFriendlyTank() {
    const tank = this.getSprite(SPRITES.friendlyTank);
    tank.anchor.set(0.5);
    tank.x = Math.random() * (this.app.screen.width / 2);
    tank.y = Math.random() * this.app.screen.height;
    tank.health = this.tankArmor;
    tank.targetX = Math.random() * (this.app.screen.width / 2);
    tank.targetY = Math.random() * this.app.screen.height;
    tank.shootTimer = 0;
    this.friendlyTanks.addChild(tank);
  }

  createEnemyTank() {
    const tank = this.getSprite(SPRITES.enemyTank);
    tank.anchor.set(0.5);
    tank.x = this.app.screen.width;
    tank.y = Math.random() * this.app.screen.height;
    tank.health = INITIAL_VALUES.ENEMY_HEALTH;
    
    const healthBar = new PIXI.Graphics();
    healthBar.beginFill(0xff0000);
    healthBar.drawRect(-32, -40, 64, 5);
    healthBar.endFill();
    tank.addChild(healthBar);
    tank.healthBar = healthBar;
    
    this.enemyTanks.addChild(tank);
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    this.spawnTimer += elapsedSecs;
    if (this.spawnTimer >= 1 / this.enemySpawnRate) {
      this.createEnemyTank();
      this.spawnTimer = 0;
    }

    this.updateFriendlyTanks(elapsedSecs);
    this.updateEnemyTanks(elapsedSecs);
  }

  updateFriendlyTanks(elapsedSecs) {
    this.friendlyTanks.children.forEach(tank => {
      let nearestEnemy = null;
      let nearestDistance = Infinity;

      this.enemyTanks.children.forEach(enemy => {
        const dx = enemy.x - tank.x;
        const dy = enemy.y - tank.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      });

      if (nearestEnemy && nearestDistance < this.tankRange) {
        tank.targetX = nearestEnemy.x;
        tank.targetY = nearestEnemy.y;
        
        tank.shootTimer += elapsedSecs;
        if (tank.shootTimer >= 1) {
          nearestEnemy.health -= this.tankDamage;
          tank.shootTimer = 0;
          
          const healthPercent = nearestEnemy.health / INITIAL_VALUES.ENEMY_HEALTH;
          nearestEnemy.healthBar.width = 64 * healthPercent;
          
          if (nearestEnemy.health <= 0) {
            this.enemyTanks.removeChild(nearestEnemy);
            this.credits += INITIAL_VALUES.CREDITS_PER_KILL;
          }
        }
      } else if (Math.abs(tank.x - tank.targetX) < 5 && Math.abs(tank.y - tank.targetY) < 5) {
        tank.targetX = Math.random() * (this.app.screen.width / 2);
        tank.targetY = Math.random() * this.app.screen.height;
      }

      const dx = tank.targetX - tank.x;
      const dy = tank.targetY - tank.y;
      const angle = Math.atan2(dy, dx);
      
      tank.x += Math.cos(angle) * this.tankSpeed * elapsedSecs;
      tank.y += Math.sin(angle) * this.tankSpeed * elapsedSecs;
      tank.rotation = angle;
    });
  }

  updateEnemyTanks(elapsedSecs) {
    this.enemyTanks.children.forEach(enemy => {
      let nearestFriendly = null;
      let nearestDistance = Infinity;

      this.friendlyTanks.children.forEach(friendly => {
        const dx = friendly.x - enemy.x;
        const dy = friendly.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestFriendly = friendly;
        }
      });

      if (nearestFriendly) {
        const dx = nearestFriendly.x - enemy.x;
        const dy = nearestFriendly.y - enemy.y;
        const angle = Math.atan2(dy, dx);
        
        enemy.x += Math.cos(angle) * INITIAL_VALUES.ENEMY_SPEED * elapsedSecs;
        enemy.y += Math.sin(angle) * INITIAL_VALUES.ENEMY_SPEED * elapsedSecs;
        enemy.rotation = angle;
      }
    });
  }

  upgradeTankSpeed() {
    if (this.credits >= this.tankSpeedCost) {
      this.credits -= this.tankSpeedCost;
      this.tankSpeed *= 1.2;
      this.tankSpeedCost *= 2;
    }
  }

  upgradeTankDamage() {
    if (this.credits >= this.tankDamageCost) {
      this.credits -= this.tankDamageCost;
      this.tankDamage *= 1.2;
      this.tankDamageCost *= 2;
    }
  }

  upgradeTankRange() {
    if (this.credits >= this.tankRangeCost) {
      this.credits -= this.tankRangeCost;
      this.tankRange *= 1.2;
      this.tankRangeCost *= 2;
    }
  }

  upgradeTankArmor() {
    if (this.credits >= this.tankArmorCost) {
      this.credits -= this.tankArmorCost;
      this.tankArmor *= 1.2;
      this.tankArmorCost *= 2;
    }
  }

  upgradeTankCount() {
    if (this.credits >= this.tankCountCost) {
      this.credits -= this.tankCountCost;
      this.tankCount++;
      this.createFriendlyTank();
      this.tankCountCost *= 2;
    }
  }

  upgradeEnemySpawnRate() {
    if (this.credits >= this.enemySpawnRateCost) {
      this.credits -= this.enemySpawnRateCost;
      this.enemySpawnRate *= 1.2;
      this.enemySpawnRateCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: 0f02eaa6-43fb-4204-bc48-6a5f21afc116
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} credits)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Credits: {Math.floor(game.credits)} | Tanks: {game.tankCount} | Damage: {Math.floor(game.tankDamage)} | Speed: {Math.floor(game.tankSpeed)} | Range: {Math.floor(game.tankRange)} | Armor: {Math.floor(game.tankArmor)} | Spawn Rate: {game.enemySpawnRate.toFixed(1)}/s</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeTankSpeed()} cost={game.tankSpeedCost}>Upgrade Tank Speed</Button>
        <Button onClick={() => game.upgradeTankDamage()} cost={game.tankDamageCost}>Upgrade Tank Damage</Button>
        <Button onClick={() => game.upgradeTankRange()} cost={game.tankRangeCost}>Upgrade Tank Range</Button>
        <Button onClick={() => game.upgradeTankArmor()} cost={game.tankArmorCost}>Upgrade Tank Armor</Button>
        <Button onClick={() => game.upgradeTankCount()} cost={game.tankCountCost}>Add Tank</Button>
        <Button onClick={() => game.upgradeEnemySpawnRate()} cost={game.enemySpawnRateCost}>Increase Enemy Spawn Rate</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the requested features:
- Auto-playing tanks that patrol and engage enemies
- Enemy tanks that spawn and move towards friendly tanks
- Credit system for destroying enemies
- Six different upgrades with doubling costs
- Health bars for enemy tanks
- Proper movement and targeting system
- All speeds and timers use elapsed seconds
- Tank sprites are 64x64

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
