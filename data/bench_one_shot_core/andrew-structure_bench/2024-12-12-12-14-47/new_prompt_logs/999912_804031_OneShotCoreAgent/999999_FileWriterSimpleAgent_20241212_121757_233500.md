Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data Structure:
- Add initial values and costs for all upgrades in gameData.js
- Include constants for customer payment, station positions, timers

2. Game Logic Components:
- Track baristas, customers, stations (ordering/service counters, coffee machines)
- Implement movement system with position tracking and speed calculations
- Handle order processing flow: customer appears -> barista takes order -> prepares coffee -> delivers
- Manage money accumulation and upgrades

3. Visual Implementation:
- Add sprites for baristas, customers, counters, and coffee machines
- Create containers for each entity type
- Implement smooth movement between stations

4. Game Loop:
- Update entity positions
- Process customer spawning
- Handle order completion and money generation
- Update timers for coffee preparation and service

Now, let's implement the files:

# Excerpt ID: 24ebe6e4-f707-466f-954a-4711bb5aa257
```js src/game/gameData.js
export const INITIAL_VALUES = {
  BARISTA_SPEED: 100, // pixels per second
  BARISTA_COUNT: 1,
  COFFEE_PREP_TIME: 3, // seconds
  SERVICE_TIME: 2, // seconds
  COUNTER_COUNT: 1,
  PAYMENT_AMOUNT: 10,
};

export const UPGRADE_COSTS = {
  BARISTA: 100,
  BARISTA_SPEED: 50,
  COFFEE_MACHINE: 75,
  COUNTER: 150,
  PREMIUM_PRICES: 200,
  TRAINING: 125,
};

export const STATION_POSITIONS = {
  IDLE_POSITION: { x: 400, y: 500 },
  COFFEE_MACHINES: [
    { x: 200, y: 300 },
    { x: 300, y: 300 },
    { x: 400, y: 300 }
  ],
  ORDER_COUNTERS: [
    { x: 200, y: 100 },
    { x: 300, y: 100 },
    { x: 400, y: 100 }
  ],
  SERVICE_COUNTERS: [
    { x: 600, y: 100 },
    { x: 600, y: 200 },
    { x: 600, y: 300 }
  ]
};
```

# Excerpt ID: c79302ba-93cc-477b-a1e8-b2702092b6d7
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  barista: {
    path: 'assets/barista.png',
    width: 64,
    height: 64
  },
  customer: {
    path: 'assets/customer.png',
    width: 64,
    height: 64
  },
  counter: {
    path: 'assets/counter.png',
    width: 80,
    height: 64
  },
  coffee_machine: {
    path: 'assets/coffee_machine.png',
    width: 64,
    height: 64
  }
};
```

# Excerpt ID: da6695a0-04dd-472d-96f2-6033140a6179
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, STATION_POSITIONS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils';

const SCREEN_SIZE = {
  width: 800,
  height: 600
};

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.money = 0;
    this.baristaSpeed = INITIAL_VALUES.BARISTA_SPEED;
    this.baristaCount = INITIAL_VALUES.BARISTA_COUNT;
    this.coffeeTime = INITIAL_VALUES.COFFEE_PREP_TIME;
    this.serviceTime = INITIAL_VALUES.SERVICE_TIME;
    this.counterCount = INITIAL_VALUES.COUNTER_COUNT;
    this.paymentAmount = INITIAL_VALUES.PAYMENT_AMOUNT;

    this.upgradeCosts = {...UPGRADE_COSTS};
    this.lastTimestamp = performance.now();

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.baristas = new PIXI.Container();
    this.customers = new PIXI.Container();
    this.stations = new PIXI.Container();

    // Create initial barista
    this.createBarista();

    // Create stations
    this.createStations();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.stations);
    this.app.stage.addChild(this.customers);
    this.app.stage.addChild(this.baristas);
  }

  createBarista() {
    const barista = this.getSprite(SPRITES.barista);
    barista.anchor.set(0.5);
    barista.x = STATION_POSITIONS.IDLE_POSITION.x;
    barista.y = STATION_POSITIONS.IDLE_POSITION.y;
    barista.state = 'idle';
    barista.targetX = barista.x;
    barista.targetY = barista.y;
    this.baristas.addChild(barista);
  }

  createStations() {
    // Create order counters
    for (let i = 0; i < 3; i++) {
      const counter = this.getSprite(SPRITES.counter);
      counter.anchor.set(0.5);
      counter.x = STATION_POSITIONS.ORDER_COUNTERS[i].x;
      counter.y = STATION_POSITIONS.ORDER_COUNTERS[i].y;
      counter.occupied = false;
      this.stations.addChild(counter);
    }

    // Create coffee machines
    for (let i = 0; i < 3; i++) {
      const machine = this.getSprite(SPRITES.coffee_machine);
      machine.anchor.set(0.5);
      machine.x = STATION_POSITIONS.COFFEE_MACHINES[i].x;
      machine.y = STATION_POSITIONS.COFFEE_MACHINES[i].y;
      machine.occupied = false;
      this.stations.addChild(machine);
    }
  }

  spawnCustomer() {
    const availableCounter = STATION_POSITIONS.ORDER_COUNTERS.find((_, index) => 
      !this.customers.children.some(c => c.x === STATION_POSITIONS.ORDER_COUNTERS[index].x)
    );

    if (availableCounter) {
      const customer = this.getSprite(SPRITES.customer);
      customer.anchor.set(0.5);
      customer.x = availableCounter.x;
      customer.y = availableCounter.y;
      customer.state = 'waiting';
      this.customers.addChild(customer);
    }
  }

  moveEntity(entity, targetX, targetY, speed, elapsedSecs) {
    const dx = targetX - entity.x;
    const dy = targetY - entity.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > 1) {
      const moveDistance = speed * elapsedSecs;
      const ratio = moveDistance / distance;
      entity.x += dx * ratio;
      entity.y += dy * ratio;
      return false;
    }
    
    entity.x = targetX;
    entity.y = targetY;
    return true;
  }

  gameLoop(delta) {
    const currentTime = performance.now();
    const elapsedSecs = (currentTime - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTime;

    // Spawn customers
    if (this.customers.children.length < this.counterCount) {
      this.spawnCustomer();
    }

    // Update baristas
    this.baristas.children.forEach(barista => {
      if (barista.state === 'idle') {
        const waitingCustomer = this.customers.children.find(c => c.state === 'waiting');
        if (waitingCustomer) {
          barista.state = 'moving_to_customer';
          barista.targetX = waitingCustomer.x;
          barista.targetY = waitingCustomer.y;
          waitingCustomer.state = 'being_served';
        }
      }
      
      if (barista.state === 'moving_to_customer' || barista.state === 'moving_to_machine' || 
          barista.state === 'moving_to_service' || barista.state === 'returning') {
        const arrived = this.moveEntity(barista, barista.targetX, barista.targetY, this.baristaSpeed, elapsedSecs);
        if (arrived) {
          if (barista.state === 'moving_to_customer') {
            barista.state = 'moving_to_machine';
            const machine = STATION_POSITIONS.COFFEE_MACHINES[0];
            barista.targetX = machine.x;
            barista.targetY = machine.y;
          } else if (barista.state === 'moving_to_machine') {
            barista.state = 'preparing';
            barista.timer = this.coffeeTime;
          } else if (barista.state === 'moving_to_service') {
            barista.state = 'serving';
            barista.timer = this.serviceTime;
          } else if (barista.state === 'returning') {
            barista.state = 'idle';
          }
        }
      }

      if (barista.state === 'preparing' || barista.state === 'serving') {
        barista.timer -= elapsedSecs;
        if (barista.timer <= 0) {
          if (barista.state === 'preparing') {
            barista.state = 'moving_to_service';
            const service = STATION_POSITIONS.SERVICE_COUNTERS[0];
            barista.targetX = service.x;
            barista.targetY = service.y;
          } else if (barista.state === 'serving') {
            this.money += this.paymentAmount;
            barista.state = 'returning';
            barista.targetX = STATION_POSITIONS.IDLE_POSITION.x;
            barista.targetY = STATION_POSITIONS.IDLE_POSITION.y;
            
            // Remove served customer
            const servedCustomer = this.customers.children.find(c => c.state === 'being_served');
            if (servedCustomer) {
              this.customers.removeChild(servedCustomer);
            }
          }
        }
      }
    });
  }

  upgradeBaristas() {
    if (this.money >= this.upgradeCosts.BARISTA) {
      this.money -= this.upgradeCosts.BARISTA;
      this.createBarista();
      this.baristaCount++;
      this.upgradeCosts.BARISTA *= 2;
    }
  }

  upgradeBaristaSpeed() {
    if (this.money >= this.upgradeCosts.BARISTA_SPEED) {
      this.money -= this.upgradeCosts.BARISTA_SPEED;
      this.baristaSpeed *= 1.2;
      this.upgradeCosts.BARISTA_SPEED *= 2;
    }
  }

  upgradeCoffeeMachine() {
    if (this.money >= this.upgradeCosts.COFFEE_MACHINE) {
      this.money -= this.upgradeCosts.COFFEE_MACHINE;
      this.coffeeTime *= 0.8;
      this.upgradeCosts.COFFEE_MACHINE *= 2;
    }
  }

  upgradeCounter() {
    if (this.money >= this.upgradeCosts.COUNTER) {
      this.money -= this.upgradeCosts.COUNTER;
      this.counterCount++;
      this.upgradeCosts.COUNTER *= 2;
    }
  }

  upgradePrices() {
    if (this.money >= this.upgradeCosts.PREMIUM_PRICES) {
      this.money -= this.upgradeCosts.PREMIUM_PRICES;
      this.paymentAmount *= 1.5;
      this.upgradeCosts.PREMIUM_PRICES *= 2;
    }
  }

  upgradeTraining() {
    if (this.money >= this.upgradeCosts.TRAINING) {
      this.money -= this.upgradeCosts.TRAINING;
      this.serviceTime *= 0.8;
      this.upgradeCosts.TRAINING *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: 37be77fb-b4a1-46ed-988d-f5398cff9473
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
    position: 'relative',
  }}>
    {children} (${cost})
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Money: ${Math.floor(game.money)} | Baristas: {game.baristaCount} | Counters: {game.counterCount}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeBaristas()} cost={game.upgradeCosts.BARISTA}>Hire Barista</Button>
        <Button onClick={() => game.upgradeBaristaSpeed()} cost={game.upgradeCosts.BARISTA_SPEED}>Faster Baristas</Button>
        <Button onClick={() => game.upgradeCoffeeMachine()} cost={game.upgradeCosts.COFFEE_MACHINE}>Better Machines</Button>
        <Button onClick={() => game.upgradeCounter()} cost={game.upgradeCosts.COUNTER}>Add Counter</Button>
        <Button onClick={() => game.upgradePrices()} cost={game.upgradeCosts.PREMIUM_PRICES}>Premium Prices</Button>
        <Button onClick={() => game.upgradeTraining()} cost={game.upgradeCosts.TRAINING}>Efficient Training</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the required features:
1. Automated customer spawning
2. Barista movement and order processing
3. Multiple stations (ordering counters, coffee machines, service counters)
4. All six upgrades with doubling costs
5. Money generation from completed orders
6. Smooth movement system
7. Complete UI with status display and upgrade buttons

The game will run automatically with baristas serving customers and generating money, while the player can purchase upgrades to improve efficiency.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
