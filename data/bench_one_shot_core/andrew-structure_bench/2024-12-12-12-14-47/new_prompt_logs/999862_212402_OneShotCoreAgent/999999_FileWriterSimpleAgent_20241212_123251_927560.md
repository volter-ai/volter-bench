Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Design Implementation Plan:
- In gameData.js:
  - Define initial values for runners, tracks, speeds, spawn rates
  - Define upgrade costs and multipliers

- In assetManifest.js:
  - Add sprites for runner, coin, obstacle
  - Keep background

- In gameLogic.js:
  - Track class properties:
    - runners array
    - coins array
    - obstacles array
    - score/coins collected
    - timers for coin/obstacle spawning
    - upgrade values
  - Core mechanics:
    - Runner movement system with track switching
    - Coin spawning and collection
    - Obstacle spawning and avoidance
    - Track management
    - Upgrade functions
  - Game loop:
    - Update positions
    - Spawn coins/obstacles
    - Check collisions
    - Manage runners reaching end

- In GameUI.js:
  - Display current coins
  - Show all upgrade buttons with costs
  - Display current stats

Now I'll implement each file:

# Excerpt ID: 8aec0bdc-fa55-441c-8c96-e9312ff6e553
```javascript src/game/gameData.js
export const INITIAL_VALUES = {
  RUNNER_SPEED: 100,
  COIN_SPAWN_RATE: 1.5,
  OBSTACLE_SPAWN_RATE: 3,
  RUNNER_COUNT: 1,
  TRACK_COUNT: 3,
  COIN_VALUE: 1,
  COLLECTION_RADIUS: 20
};

export const UPGRADE_COSTS = {
  RUNNER_SPEED: 10,
  COIN_SPAWN_RATE: 15,
  RUNNER_COUNT: 25,
  TRACK_COUNT: 50,
  COIN_VALUE: 20,
  COLLECTION_RADIUS: 30
};
```

# Excerpt ID: eeb30b14-a616-436a-a376-2f057497e44c
```javascript src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  runner: {
    path: 'assets/runner.png',
    width: 64,
    height: 64
  },
  coin: {
    path: 'assets/coin.png',
    width: 32,
    height: 32
  },
  obstacle: {
    path: 'assets/obstacle.png',
    width: 48,
    height: 48
  }
};
```

# Excerpt ID: e2510372-bb96-4759-bd7e-716c7f5cead2
```javascript src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.coins = 0;
    this.lastTimestamp = performance.now();
    
    // Game values
    this.runnerSpeed = INITIAL_VALUES.RUNNER_SPEED;
    this.coinSpawnRate = INITIAL_VALUES.COIN_SPAWN_RATE;
    this.runnerCount = INITIAL_VALUES.RUNNER_COUNT;
    this.trackCount = INITIAL_VALUES.TRACK_COUNT;
    this.coinValue = INITIAL_VALUES.COIN_VALUE;
    this.collectionRadius = INITIAL_VALUES.COLLECTION_RADIUS;

    // Costs
    this.runnerSpeedCost = UPGRADE_COSTS.RUNNER_SPEED;
    this.coinSpawnRateCost = UPGRADE_COSTS.COIN_SPAWN_RATE;
    this.runnerCountCost = UPGRADE_COSTS.RUNNER_COUNT;
    this.trackCountCost = UPGRADE_COSTS.TRACK_COUNT;
    this.coinValueCost = UPGRADE_COSTS.COIN_VALUE;
    this.collectionRadiusCost = UPGRADE_COSTS.COLLECTION_RADIUS;

    // Timers
    this.coinSpawnTimer = 0;
    this.obstacleSpawnTimer = 0;

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    this.runners = new PIXI.Container();
    this.coins = new PIXI.Container();
    this.obstacles = new PIXI.Container();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.runners);
    this.app.stage.addChild(this.coins);
    this.app.stage.addChild(this.obstacles);

    // Create initial runners
    for (let i = 0; i < this.runnerCount; i++) {
      this.createRunner();
    }
  }

  createRunner() {
    const runner = this.getSprite(SPRITES.runner);
    runner.anchor.set(0.5);
    runner.x = 0;
    runner.y = (SCREEN_SIZE.height / (this.trackCount + 1)) * (Math.floor(Math.random() * this.trackCount) + 1);
    runner.currentTrack = Math.floor(runner.y / (SCREEN_SIZE.height / (this.trackCount + 1)));
    this.runners.addChild(runner);
  }

  createCoin() {
    const coin = this.getSprite(SPRITES.coin);
    coin.anchor.set(0.5);
    coin.x = SCREEN_SIZE.width;
    coin.y = (SCREEN_SIZE.height / (this.trackCount + 1)) * (Math.floor(Math.random() * this.trackCount) + 1);
    this.coins.addChild(coin);
  }

  createObstacle() {
    const obstacle = this.getSprite(SPRITES.obstacle);
    obstacle.anchor.set(0.5);
    obstacle.x = SCREEN_SIZE.width;
    obstacle.y = (SCREEN_SIZE.height / (this.trackCount + 1)) * (Math.floor(Math.random() * this.trackCount) + 1);
    this.obstacles.addChild(obstacle);
  }

  gameLoop(delta) {
    const currentTimestamp = performance.now();
    const elapsedSecs = (currentTimestamp - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTimestamp;

    // Spawn coins
    this.coinSpawnTimer += elapsedSecs;
    if (this.coinSpawnTimer >= this.coinSpawnRate) {
      this.createCoin();
      this.coinSpawnTimer = 0;
    }

    // Spawn obstacles
    this.obstacleSpawnTimer += elapsedSecs;
    if (this.obstacleSpawnTimer >= INITIAL_VALUES.OBSTACLE_SPAWN_RATE) {
      this.createObstacle();
      this.obstacleSpawnTimer = 0;
    }

    // Move runners
    this.runners.children.forEach(runner => {
      runner.x += this.runnerSpeed * elapsedSecs;
      
      // Check for nearby obstacles and avoid
      this.obstacles.children.forEach(obstacle => {
        if (Math.abs(obstacle.x - runner.x) < 100 && runner.currentTrack === Math.floor(obstacle.y / (SCREEN_SIZE.height / (this.trackCount + 1)))) {
          const newTrack = runner.currentTrack + (Math.random() < 0.5 ? 1 : -1);
          if (newTrack >= 0 && newTrack < this.trackCount) {
            runner.currentTrack = newTrack;
            runner.y = (SCREEN_SIZE.height / (this.trackCount + 1)) * (runner.currentTrack + 1);
          }
        }
      });

      // Collect coins
      this.coins.children.forEach(coin => {
        const dx = coin.x - runner.x;
        const dy = coin.y - runner.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < this.collectionRadius) {
          this.coins.removeChild(coin);
          this.coins += this.coinValue;
        }
      });

      // Reset runner position
      if (runner.x > SCREEN_SIZE.width) {
        runner.x = 0;
        runner.currentTrack = Math.floor(Math.random() * this.trackCount);
        runner.y = (SCREEN_SIZE.height / (this.trackCount + 1)) * (runner.currentTrack + 1);
      }
    });

    // Clean up off-screen objects
    this.coins.children.forEach(coin => {
      if (coin.x < 0) this.coins.removeChild(coin);
    });
    
    this.obstacles.children.forEach(obstacle => {
      if (obstacle.x < 0) this.obstacles.removeChild(obstacle);
    });
  }

  upgradeRunnerSpeed() {
    if (this.coins >= this.runnerSpeedCost) {
      this.coins -= this.runnerSpeedCost;
      this.runnerSpeed *= 1.2;
      this.runnerSpeedCost *= 2;
    }
  }

  upgradeCoinSpawnRate() {
    if (this.coins >= this.coinSpawnRateCost) {
      this.coins -= this.coinSpawnRateCost;
      this.coinSpawnRate *= 0.8;
      this.coinSpawnRateCost *= 2;
    }
  }

  upgradeRunnerCount() {
    if (this.coins >= this.runnerCountCost) {
      this.coins -= this.runnerCountCost;
      this.runnerCount++;
      this.createRunner();
      this.runnerCountCost *= 2;
    }
  }

  upgradeTrackCount() {
    if (this.coins >= this.trackCountCost) {
      this.coins -= this.trackCountCost;
      this.trackCount++;
      this.trackCountCost *= 2;
    }
  }

  upgradeCoinValue() {
    if (this.coins >= this.coinValueCost) {
      this.coins -= this.coinValueCost;
      this.coinValue *= 1.5;
      this.coinValueCost *= 2;
    }
  }

  upgradeCollectionRadius() {
    if (this.coins >= this.collectionRadiusCost) {
      this.coins -= this.collectionRadiusCost;
      this.collectionRadius *= 1.2;
      this.collectionRadiusCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: 2ba458a4-1cab-4abf-8a02-4d8af675b142
```javascript src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} coins)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Coins: {Math.floor(game.coins)} | Runners: {game.runnerCount} | Tracks: {game.trackCount}</p>
    <p>Runner Speed: {game.runnerSpeed.toFixed(1)} | Coin Spawn Rate: {game.coinSpawnRate.toFixed(1)}s | Coin Value: {game.coinValue}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeRunnerSpeed()} cost={game.runnerSpeedCost}>Upgrade Runner Speed</Button>
        <Button onClick={() => game.upgradeCoinSpawnRate()} cost={game.coinSpawnRateCost}>Upgrade Coin Spawn Rate</Button>
        <Button onClick={() => game.upgradeRunnerCount()} cost={game.runnerCountCost}>Add Runner</Button>
        <Button onClick={() => game.upgradeTrackCount()} cost={game.trackCountCost}>Add Track</Button>
        <Button onClick={() => game.upgradeCoinValue()} cost={game.coinValueCost}>Increase Coin Value</Button>
        <Button onClick={() => game.upgradeCollectionRadius()} cost={game.collectionRadiusCost}>Increase Collection Radius</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the requested features:
- Multiple parallel tracks
- Auto-running runners
- Coin spawning and collection
- Obstacle avoidance
- Track switching
- All specified upgrades
- Proper timing and movement systems
- Complete UI with all upgrade buttons and stats display

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
