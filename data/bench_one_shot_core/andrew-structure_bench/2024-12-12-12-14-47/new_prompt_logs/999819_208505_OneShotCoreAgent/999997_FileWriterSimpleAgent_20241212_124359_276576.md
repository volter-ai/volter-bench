Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me analyze the error:

The error occurs in utils.js when trying to access resources.default.texture and ASSET_MANIFEST[key].path. This suggests:

1. The utils.js file is missing from our implementation
2. The asset loading code expects a different format than what we're providing

The fix requires:
1. Implementing utils.js with proper PIXI asset loading
2. Adjusting how we reference sprites in gameLogic.js

Here are the corrected files:

# Excerpt ID: b622d217-e76d-472d-a425-0b5191aedda7
```js src/game/utils.js
import * as PIXI from 'pixi.js';

export function loadAssets(assetManifest, onComplete) {
  const loader = PIXI.Loader.shared;
  
  // Add each sprite to the loader
  Object.entries(assetManifest).forEach(([key, sprite]) => {
    loader.add(key, sprite.path);
  });

  loader.load((loader, resources) => {
    onComplete();
  });
}
```

# Excerpt ID: 7311e3d7-59ad-44c8-a35e-368b5b669767
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAME_CONFIG } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;
    this.lastTimestamp = performance.now();
    
    // Game attributes
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.paddleSize = INITIAL_VALUES.PADDLE_SIZE;
    this.ballCount = INITIAL_VALUES.BALL_COUNT;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.pointsPerHit = INITIAL_VALUES.POINTS_PER_HIT;

    // Upgrade costs
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.paddleSizeCost = UPGRADE_COSTS.PADDLE_SIZE;
    this.ballCountCost = UPGRADE_COSTS.BALL_COUNT;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;
    this.pointsPerHitCost = UPGRADE_COSTS.POINTS_PER_HIT;

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(name) {
    const sprite = new PIXI.Sprite(PIXI.Loader.shared.resources[name].texture);
    sprite.width = SPRITES[name].width;
    sprite.height = SPRITES[name].height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite('background');
    
    // Create paddles
    this.leftPaddle = this.getSprite('paddle');
    this.rightPaddle = this.getSprite('paddle');
    
    this.leftPaddle.x = GAME_CONFIG.PADDLE_OFFSET;
    this.rightPaddle.x = SCREEN_SIZE.width - GAME_CONFIG.PADDLE_OFFSET;
    
    this.leftPaddle.y = SCREEN_SIZE.height / 2;
    this.rightPaddle.y = SCREEN_SIZE.height / 2;
    
    this.leftPaddle.anchor.set(0.5);
    this.rightPaddle.anchor.set(0.5);

    // Create balls container
    this.balls = new PIXI.Container();
    this.createBall();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.leftPaddle);
    this.app.stage.addChild(this.rightPaddle);
    this.app.stage.addChild(this.balls);
  }

  createBall() {
    const ball = this.getSprite('ball');
    ball.anchor.set(0.5);
    this.resetBall(ball);
    this.balls.addChild(ball);
  }

  resetBall(ball) {
    ball.x = SCREEN_SIZE.width / 2;
    ball.y = SCREEN_SIZE.height / 2;
    const angle = (Math.random() * Math.PI / 2) - Math.PI / 4;
    ball.dx = Math.cos(angle) * this.ballSpeed * (Math.random() < 0.5 ? 1 : -1);
    ball.dy = Math.sin(angle) * this.ballSpeed;
  }

  gameLoop(delta) {
    const currentTimestamp = performance.now();
    const elapsedSecs = (currentTimestamp - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTimestamp;

    // Update paddle sizes
    this.leftPaddle.height = this.paddleSize;
    this.rightPaddle.height = this.paddleSize;

    // AI paddle movement
    this.movePaddles(elapsedSecs);
    this.moveBalls(elapsedSecs);
  }

  movePaddles(elapsedSecs) {
    // Each paddle tracks the closest ball
    [this.leftPaddle, this.rightPaddle].forEach(paddle => {
      let closestBall = null;
      let closestDist = Infinity;
      
      this.balls.children.forEach(ball => {
        const dist = Math.abs(ball.x - paddle.x);
        if (dist < closestDist) {
          closestDist = dist;
          closestBall = ball;
        }
      });

      if (closestBall) {
        const targetY = closestBall.y;
        const dy = targetY - paddle.y;
        const movement = Math.min(Math.abs(dy), this.paddleSpeed * elapsedSecs) * Math.sign(dy);
        paddle.y += movement;
      }

      // Clamp paddle position
      paddle.y = Math.max(paddle.height/2, Math.min(SCREEN_SIZE.height - paddle.height/2, paddle.y));
    });
  }

  moveBalls(elapsedSecs) {
    this.balls.children.forEach(ball => {
      ball.x += ball.dx * elapsedSecs;
      ball.y += ball.dy * elapsedSecs;

      // Bounce off top/bottom
      if (ball.y < 0 || ball.y > SCREEN_SIZE.height) {
        ball.dy *= -1;
      }

      // Check paddle collisions
      [this.leftPaddle, this.rightPaddle].forEach(paddle => {
        if (this.checkPaddleCollision(ball, paddle)) {
          const paddleCenter = paddle.y;
          const relativeIntersectY = paddleCenter - ball.y;
          const normalizedIntersectY = relativeIntersectY / (paddle.height / 2);
          const bounceAngle = normalizedIntersectY * Math.PI / 4;
          
          const direction = paddle === this.leftPaddle ? 1 : -1;
          ball.dx = this.ballSpeed * Math.cos(bounceAngle) * direction;
          ball.dy = -this.ballSpeed * Math.sin(bounceAngle);
          
          this.score += this.pointsPerHit;
        }
      });

      // Reset ball if it goes past paddles
      if (ball.x < 0 || ball.x > SCREEN_SIZE.width) {
        this.resetBall(ball);
      }
    });
  }

  checkPaddleCollision(ball, paddle) {
    return ball.x + ball.width/2 > paddle.x - paddle.width/2 &&
           ball.x - ball.width/2 < paddle.x + paddle.width/2 &&
           ball.y + ball.height/2 > paddle.y - paddle.height/2 &&
           ball.y - ball.height/2 < paddle.y + paddle.height/2;
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed *= 1.1;
      this.ballSpeedCost *= 2;
    }
  }

  upgradePaddleSize() {
    if (this.score >= this.paddleSizeCost) {
      this.score -= this.paddleSizeCost;
      this.paddleSize *= 1.2;
      this.paddleSizeCost *= 2;
    }
  }

  addBall() {
    if (this.score >= this.ballCountCost) {
      this.score -= this.ballCountCost;
      this.ballCount++;
      this.createBall();
      this.ballCountCost *= 2;
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed *= 1.2;
      this.paddleSpeedCost *= 2;
    }
  }

  upgradePointsPerHit() {
    if (this.score >= this.pointsPerHitCost) {
      this.score -= this.pointsPerHitCost;
      this.pointsPerHit++;
      this.pointsPerHitCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

The key changes are:
1. Added utils.js with proper PIXI loader implementation
2. Modified getSprite() in gameLogic.js to use PIXI.Loader.shared.resources
3. Changed sprite references to use asset keys instead of sprite configs

All other files remain unchanged as they weren't related to the loading error.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
