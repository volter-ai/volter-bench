Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation first:

1. Game Data Requirements:
- Initial values for ball speed, paddle size, number of balls, paddle speed, points per hit
- Base costs for each upgrade
- Screen dimensions and paddle dimensions

2. Game Logic Implementation:
- Create paddle and ball sprites
- Implement paddle AI movement to track balls
- Handle ball movement and bouncing physics
- Track score when balls hit paddles
- Respawn balls when they go past paddles
- Implement all upgrade functions

3. UI Requirements:
- Display current score
- Show current level of each upgrade
- Display upgrade buttons with costs
- Update UI frequently to show new values

Now, let's implement the files:

# Excerpt ID: ecf68f4d-1551-44c6-b9be-6f36be718389
```js src/game/gameData.js
export const INITIAL_VALUES = {
  BALL_SPEED: 200,
  PADDLE_SIZE: 100,
  BALL_COUNT: 1,
  PADDLE_SPEED: 300,
  POINTS_PER_HIT: 1
};

export const UPGRADE_COSTS = {
  BALL_SPEED: 10,
  PADDLE_SIZE: 15,
  BALL_COUNT: 100,
  PADDLE_SPEED: 20,
  POINTS_PER_HIT: 50
};

export const GAME_CONFIG = {
  PADDLE_WIDTH: 20,
  BALL_SIZE: 16,
  PADDLE_OFFSET: 40
};
```

# Excerpt ID: 03c1d57a-f581-4c47-ac96-518ccb4a7908
```js src/game/assetManifest.js
export const SPRITES = {
  background: {
    path: 'assets/background.png',
    width: 800,
    height: 600
  },
  paddle: {
    path: 'assets/paddle.png',
    width: 20,
    height: 100
  },
  ball: {
    path: 'assets/ball.png',
    width: 16,
    height: 16
  }
};
```

# Excerpt ID: e4f06306-b660-42ea-94da-093ed66cb8e4
```js src/game/gameLogic.js
import * as PIXI from 'pixi.js';
import { INITIAL_VALUES, UPGRADE_COSTS, GAME_CONFIG } from './gameData';
import { SPRITES } from './assetManifest';
import { loadAssets } from './utils'

const SCREEN_SIZE = {
  width: 800,
  height: 600
}

export class GameLogic {
  constructor(container) {
    this.app = new PIXI.Application({
      width: SCREEN_SIZE.width,
      height: SCREEN_SIZE.height,
      backgroundColor: 0x222C37,
    });

    container.appendChild(this.app.view);

    this.ready = false;
    this.score = 0;
    this.lastTimestamp = performance.now();
    
    // Game attributes
    this.ballSpeed = INITIAL_VALUES.BALL_SPEED;
    this.paddleSize = INITIAL_VALUES.PADDLE_SIZE;
    this.ballCount = INITIAL_VALUES.BALL_COUNT;
    this.paddleSpeed = INITIAL_VALUES.PADDLE_SPEED;
    this.pointsPerHit = INITIAL_VALUES.POINTS_PER_HIT;

    // Upgrade costs
    this.ballSpeedCost = UPGRADE_COSTS.BALL_SPEED;
    this.paddleSizeCost = UPGRADE_COSTS.PADDLE_SIZE;
    this.ballCountCost = UPGRADE_COSTS.BALL_COUNT;
    this.paddleSpeedCost = UPGRADE_COSTS.PADDLE_SPEED;
    this.pointsPerHitCost = UPGRADE_COSTS.POINTS_PER_HIT;

    loadAssets(SPRITES, () => {
      if (!this.app.stage) return;
      this.createGameObjects();
      this.app.ticker.add(this.gameLoop.bind(this));
      this.ready = true;
    });
  }

  getSprite(spriteConfig) {
    const texture = PIXI.Texture.from(spriteConfig.path);
    const sprite = new PIXI.Sprite(texture);
    sprite.width = spriteConfig.width;
    sprite.height = spriteConfig.height;
    return sprite;
  }

  createGameObjects() {
    this.background = this.getSprite(SPRITES.background);
    
    // Create paddles
    this.leftPaddle = this.getSprite(SPRITES.paddle);
    this.rightPaddle = this.getSprite(SPRITES.paddle);
    
    this.leftPaddle.x = GAME_CONFIG.PADDLE_OFFSET;
    this.rightPaddle.x = SCREEN_SIZE.width - GAME_CONFIG.PADDLE_OFFSET;
    
    this.leftPaddle.y = SCREEN_SIZE.height / 2;
    this.rightPaddle.y = SCREEN_SIZE.height / 2;
    
    this.leftPaddle.anchor.set(0.5);
    this.rightPaddle.anchor.set(0.5);

    // Create balls container
    this.balls = new PIXI.Container();
    this.createBall();

    this.app.stage.addChild(this.background);
    this.app.stage.addChild(this.leftPaddle);
    this.app.stage.addChild(this.rightPaddle);
    this.app.stage.addChild(this.balls);
  }

  createBall() {
    const ball = this.getSprite(SPRITES.ball);
    ball.anchor.set(0.5);
    this.resetBall(ball);
    this.balls.addChild(ball);
  }

  resetBall(ball) {
    ball.x = SCREEN_SIZE.width / 2;
    ball.y = SCREEN_SIZE.height / 2;
    const angle = (Math.random() * Math.PI / 2) - Math.PI / 4;
    ball.dx = Math.cos(angle) * this.ballSpeed * (Math.random() < 0.5 ? 1 : -1);
    ball.dy = Math.sin(angle) * this.ballSpeed;
  }

  gameLoop(delta) {
    const currentTimestamp = performance.now();
    const elapsedSecs = (currentTimestamp - this.lastTimestamp) / 1000;
    this.lastTimestamp = currentTimestamp;

    // Update paddle sizes
    this.leftPaddle.height = this.paddleSize;
    this.rightPaddle.height = this.paddleSize;

    // AI paddle movement
    this.movePaddles(elapsedSecs);
    this.moveBalls(elapsedSecs);
  }

  movePaddles(elapsedSecs) {
    // Each paddle tracks the closest ball
    [this.leftPaddle, this.rightPaddle].forEach(paddle => {
      let closestBall = null;
      let closestDist = Infinity;
      
      this.balls.children.forEach(ball => {
        const dist = Math.abs(ball.x - paddle.x);
        if (dist < closestDist) {
          closestDist = dist;
          closestBall = ball;
        }
      });

      if (closestBall) {
        const targetY = closestBall.y;
        const dy = targetY - paddle.y;
        const movement = Math.min(Math.abs(dy), this.paddleSpeed * elapsedSecs) * Math.sign(dy);
        paddle.y += movement;
      }

      // Clamp paddle position
      paddle.y = Math.max(paddle.height/2, Math.min(SCREEN_SIZE.height - paddle.height/2, paddle.y));
    });
  }

  moveBalls(elapsedSecs) {
    this.balls.children.forEach(ball => {
      ball.x += ball.dx * elapsedSecs;
      ball.y += ball.dy * elapsedSecs;

      // Bounce off top/bottom
      if (ball.y < 0 || ball.y > SCREEN_SIZE.height) {
        ball.dy *= -1;
      }

      // Check paddle collisions
      [this.leftPaddle, this.rightPaddle].forEach(paddle => {
        if (this.checkPaddleCollision(ball, paddle)) {
          const paddleCenter = paddle.y;
          const relativeIntersectY = paddleCenter - ball.y;
          const normalizedIntersectY = relativeIntersectY / (paddle.height / 2);
          const bounceAngle = normalizedIntersectY * Math.PI / 4;
          
          const direction = paddle === this.leftPaddle ? 1 : -1;
          ball.dx = this.ballSpeed * Math.cos(bounceAngle) * direction;
          ball.dy = -this.ballSpeed * Math.sin(bounceAngle);
          
          this.score += this.pointsPerHit;
        }
      });

      // Reset ball if it goes past paddles
      if (ball.x < 0 || ball.x > SCREEN_SIZE.width) {
        this.resetBall(ball);
      }
    });
  }

  checkPaddleCollision(ball, paddle) {
    return ball.x + ball.width/2 > paddle.x - paddle.width/2 &&
           ball.x - ball.width/2 < paddle.x + paddle.width/2 &&
           ball.y + ball.height/2 > paddle.y - paddle.height/2 &&
           ball.y - ball.height/2 < paddle.y + paddle.height/2;
  }

  upgradeBallSpeed() {
    if (this.score >= this.ballSpeedCost) {
      this.score -= this.ballSpeedCost;
      this.ballSpeed *= 1.1;
      this.ballSpeedCost *= 2;
    }
  }

  upgradePaddleSize() {
    if (this.score >= this.paddleSizeCost) {
      this.score -= this.paddleSizeCost;
      this.paddleSize *= 1.2;
      this.paddleSizeCost *= 2;
    }
  }

  addBall() {
    if (this.score >= this.ballCountCost) {
      this.score -= this.ballCountCost;
      this.ballCount++;
      this.createBall();
      this.ballCountCost *= 2;
    }
  }

  upgradePaddleSpeed() {
    if (this.score >= this.paddleSpeedCost) {
      this.score -= this.paddleSpeedCost;
      this.paddleSpeed *= 1.2;
      this.paddleSpeedCost *= 2;
    }
  }

  upgradePointsPerHit() {
    if (this.score >= this.pointsPerHitCost) {
      this.score -= this.pointsPerHitCost;
      this.pointsPerHit++;
      this.pointsPerHitCost *= 2;
    }
  }

  destroy() {
    this.app.destroy(true);
  }
}
```

# Excerpt ID: ec39335d-5b6e-4ba4-a197-a5307dd70ffb
```js src/ui/GameUI.js
import React, { useState, useEffect } from 'react';

const Button = ({ onClick, children, cost }) => (
  <button onClick={onClick} style={{
    margin: '5px',
    padding: '5px 10px',
    fontSize: '14px',
    color: '#d3d3d3',
    border: 'none',
    cursor: 'pointer',
    backgroundColor: '#7C45CB',
  }}>
    {children} ({cost} points)
  </button>
);

const HUD = ({ game }) => (
  <div style={{ position: 'absolute', top: 0, left: 0, right: 0, padding: '10px', backgroundColor: 'rgba(0,0,0,0.5)', color: '#d3d3d3' }}>
    <p>Score: {game.score} | Balls: {game.ballCount} | Ball Speed: {game.ballSpeed.toFixed(0)} | Paddle Size: {game.paddleSize.toFixed(0)} | Points/Hit: {game.pointsPerHit}</p>
  </div>
);

const GameUI = ({ gameRef }) => {
  const [, forceUpdate] = useState();
  useEffect(() => {
    const interval = setInterval(() => forceUpdate({}), 100);
    return () => clearInterval(interval);
  }, []);

  if (!gameRef.current) return null;

  const game = gameRef.current;

  return (
    <div style={{ width: '100%', height: '100%', color: '#d3d3d3' }}>
      <HUD game={game} />
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', right: '10px', textAlign: 'center' }}>
        <Button onClick={() => game.upgradeBallSpeed()} cost={game.ballSpeedCost}>Upgrade Ball Speed</Button>
        <Button onClick={() => game.upgradePaddleSize()} cost={game.paddleSizeCost}>Upgrade Paddle Size</Button>
        <Button onClick={() => game.addBall()} cost={game.ballCountCost}>Add Ball</Button>
        <Button onClick={() => game.upgradePaddleSpeed()} cost={game.paddleSpeedCost}>Upgrade Paddle Speed</Button>
        <Button onClick={() => game.upgradePointsPerHit()} cost={game.pointsPerHitCost}>Upgrade Points Per Hit</Button>
      </div>
    </div>
  );
};

export default GameUI;
```

This implementation includes all the required features:
1. Auto-playing pong game with AI paddles
2. Multiple balls that bounce realistically
3. Score accumulation when balls hit paddles
4. Ball respawning when missed
5. All five upgrades with doubling costs
6. Proper physics and movement systems
7. Complete UI with score display and upgrade buttons

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
