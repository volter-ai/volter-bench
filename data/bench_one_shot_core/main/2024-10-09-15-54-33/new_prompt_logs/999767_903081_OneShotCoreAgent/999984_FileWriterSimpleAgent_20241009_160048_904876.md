Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
I understand the issues raised during QA/testing. I'll describe how to fix these issues and then rewrite the necessary file with the proposed solutions.

1. Proposed fixes:

a) Random decision handling for equal speed creatures:
   We'll modify the _resolve_turn method to use random.choice when creatures have equal speed.

b) Floating-point precision issues in damage calculation:
   We'll use round() function to handle floating-point precision in the _calculate_damage method.

c) Guaranteed message display for win/loss:
   We'll add a delay using time.sleep() after showing the win/loss message before transitioning to the main menu.

d) Reset of player's creatures state:
   Instead of resetting the creatures in the scene, we'll move this responsibility to the App class, which aligns better with the architecture.

2. Rewriting the file:

We need to modify the main_game_scene.py file to implement these fixes. Here's the updated file:

# Excerpt ID: a299dc65-4a94-4045-8401-c1a8c4740c6b
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button
from main_game.models import Player, Creature, Skill
import random
import time

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Available skills:
{self._format_skills(self.player_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name}" for skill in skills])

    def run(self):
        while True:
            # Player turn
            player_skill = self._player_turn()
            
            # Opponent turn
            opponent_skill = self._opponent_turn()
            
            # Resolve turn
            self._resolve_turn(player_skill, opponent_skill)
            
            # Check for battle end
            if self._check_battle_end():
                break

        time.sleep(2)  # Delay to ensure the win/loss message is displayed
        self._transition_to_scene("MainMenuScene")

    def _player_turn(self):
        choices = [Button(skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return next(skill for skill in self.player_creature.skills if skill.display_name == choice.display_name)

    def _opponent_turn(self):
        choices = [Button(skill.display_name) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return next(skill for skill in self.opponent_creature.skills if skill.display_name == choice.display_name)

    def _resolve_turn(self, player_skill, opponent_skill):
        if self.player_creature.speed > self.opponent_creature.speed:
            first, second = (self.player, self.player_creature, player_skill), (self.opponent, self.opponent_creature, opponent_skill)
        elif self.player_creature.speed < self.opponent_creature.speed:
            first, second = (self.opponent, self.opponent_creature, opponent_skill), (self.player, self.player_creature, player_skill)
        else:
            creatures = [(self.player, self.player_creature, player_skill), (self.opponent, self.opponent_creature, opponent_skill)]
            first, second = random.sample(creatures, k=2)

        self._execute_skill(*first, second[1])
        if second[1].hp > 0:
            self._execute_skill(*second, first[1])

    def _execute_skill(self, attacker, attacker_creature, skill, defender_creature):
        damage = self._calculate_damage(attacker_creature, skill, defender_creature)
        defender_creature.hp = max(0, defender_creature.hp - damage)
        self._show_text(attacker, f"{attacker_creature.display_name} used {skill.display_name} and dealt {damage} damage!")

    def _calculate_damage(self, attacker, skill, defender):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        weakness_factor = self._get_weakness_factor(skill.skill_type, defender.creature_type)
        final_damage = round(weakness_factor * raw_damage)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def _get_weakness_factor(self, skill_type, defender_type):
        weakness_chart = {
            "fire": {"leaf": 2, "water": 0.5},
            "water": {"fire": 2, "leaf": 0.5},
            "leaf": {"water": 2, "fire": 0.5}
        }
        return weakness_chart.get(skill_type, {}).get(defender_type, 1)

    def _check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, "You lost the battle!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, "You won the battle!")
            return True
        return False
```

These changes address the issues raised in the QA/testing:

1. We've modified the _resolve_turn method to use random.sample when creatures have equal speed, ensuring a random decision.
2. We're using the round() function in the _calculate_damage method to handle floating-point precision issues.
3. We've added a time.sleep(2) before transitioning to the main menu to ensure the win/loss message is displayed.
4. We've removed the _reset_creatures method from this scene, as it should be handled by the App class instead.

Note that to fully implement the reset of player's creatures state, we would need to modify the App class as well. This would involve adding a method to reset the creatures' state when transitioning between scenes, which would be called in the transition_to_scene method of the AbstractApp class. However, as we're focusing on the MainGameScene in this fix, we've addressed the issues within the scope of this file.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "a299dc65-4a94-4045-8401-c1a8c4740c6b", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
