Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis and Solution:
The issue is that the MainGameScene needs to properly queue skills before resolving them. Here's how I'll fix it:

1. First collect both skills into a queue (list)
2. Then resolve them in order during the resolution phase
3. Keep the model as pure data schemas
4. Keep all game logic in the scene

The main changes will be in MainGameScene to separate the phases:
- Player Choice Phase: Queue player skill
- Foe Choice Phase: Queue bot skill  
- Resolution Phase: Process queued skills in order

Here's the fixed implementation:

# Excerpt ID: d4a26d4e-63ae-4583-a731-d48d300e8a71
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature
from typing import List, Tuple

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("default_player")
        self.player_creature = player.creatures[0]
        self.bot_creature = self.bot.creatures[0]
        
        # Reset creatures at start by setting hp to max_hp
        self.player_creature.hp = self.player_creature.max_hp
        self.bot_creature.hp = self.bot_creature.max_hp

    def __str__(self):
        return f"""=== Battle ===
Your {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
Foe's {self.bot_creature.display_name}: HP {self.bot_creature.hp}/{self.bot_creature.max_hp}

Available Skills:
{chr(10).join([f"> {skill.display_name} ({skill.damage} damage)" for skill in self.player_creature.skills])}
"""

    def run(self):
        self._show_text(self.player, "A wild trainer appears!")
        
        while True:
            # Initialize empty skill queue for this turn
            skill_queue: List[Tuple[Creature, Creature, Skill]] = []
            
            # Player Choice Phase
            self._show_text(self.player, "Your turn!")
            player_skill = self._wait_for_choice(self.player, 
                [SelectThing(skill) for skill in self.player_creature.skills]).thing
            skill_queue.append((self.player_creature, self.bot_creature, player_skill))
            
            # Foe Choice Phase
            self._show_text(self.player, "Foe's turn!")
            bot_skill = self._wait_for_choice(self.bot,
                [SelectThing(skill) for skill in self.bot_creature.skills]).thing
            skill_queue.append((self.bot_creature, self.player_creature, bot_skill))
            
            # Resolution Phase
            self._show_text(self.player, "Skills are being resolved!")
            for attacker, defender, skill in skill_queue:
                defender.hp -= skill.damage
                self._show_text(self.player, 
                    f"{attacker.display_name} used {skill.display_name}!")
                
                # Check for battle end after each skill resolution
                if defender.hp <= 0:
                    if defender == self.bot_creature:
                        self._show_text(self.player, "You won!")
                    else:
                        self._show_text(self.player, "You lost!")
                    self._transition_to_scene("MainMenuScene")
                    return

            # Clear skill queue at end of turn
            skill_queue.clear()
```

Key changes:
1. Added a skill_queue to store skills before resolution
2. Clearly separated the three phases:
   - Player Choice Phase
   - Foe Choice Phase  
   - Resolution Phase
3. Skills are now queued before being resolved
4. Resolution happens in order from the queue
5. Queue is cleared at end of turn
6. Maintained pure data schemas in models
7. Kept all game logic in scene
8. Used proper typing for the queue

This implementation now properly follows the architecture document's specification for queuing skills before resolution.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
