Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
To fix the issue of popping from an empty list in the `_resolve_turn` method, we need to ensure that the skill queues are never empty when we try to resolve a turn. The problem occurs because we're not checking if the players have actually chosen a skill before trying to resolve the turn.

Here's how we'll fix this:

1. We'll modify the `_player_turn` and `_opponent_turn` methods to ensure that a skill is always chosen.
2. We'll add a check in the `run` method to only call `_resolve_turn` if both players have chosen a skill.
3. We'll modify the `_resolve_turn` method to handle cases where one or both players might not have chosen a skill (although this shouldn't happen with our new checks).

Let's rewrite the `main_game_scene.py` file with these changes:

# Excerpt ID: 2def2dd2-ab1c-4294-89dc-be167872821c
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("default_player")
        self.player_creature = player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.player_skill_queue = []
        self.opponent_skill_queue = []

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Your skills:
{self._format_skills(self.player_creature.skills)}

> Use Skill
> Quit
"""

    def _format_skills(self, skills):
        return "\n".join([f"- {skill.display_name}" for skill in skills])

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appeared!")
        
        while True:
            if self._check_battle_end():
                break

            self._player_turn()
            self._opponent_turn()
            
            if self.player_skill_queue and self.opponent_skill_queue:
                self._resolve_turn()

    def _player_turn(self):
        while not self.player_skill_queue:
            use_skill_button = Button("Use Skill")
            quit_button = Button("Quit")
            choices = [use_skill_button, quit_button]
            choice = self._wait_for_choice(self.player, choices)

            if use_skill_button == choice:
                skill_choices = [SelectThing(skill) for skill in self.player_creature.skills]
                skill_choice = self._wait_for_choice(self.player, skill_choices)
                self.player_skill_queue.append(skill_choice.thing)
            elif quit_button == choice:
                self._quit_whole_game()

    def _opponent_turn(self):
        while not self.opponent_skill_queue:
            skill_choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
            skill_choice = self._wait_for_choice(self.opponent, skill_choices)
            self.opponent_skill_queue.append(skill_choice.thing)

    def _resolve_turn(self):
        if self.player_skill_queue and self.opponent_skill_queue:
            player_skill = self.player_skill_queue.pop(0)
            opponent_skill = self.opponent_skill_queue.pop(0)

            self._show_text(self.player, f"Your {self.player_creature.display_name} used {player_skill.display_name}!")
            self.opponent_creature.hp -= player_skill.damage
            self._show_text(self.player, f"Opponent's {self.opponent_creature.display_name} took {player_skill.damage} damage!")

            if not self._check_battle_end():
                self._show_text(self.player, f"Opponent's {self.opponent_creature.display_name} used {opponent_skill.display_name}!")
                self.player_creature.hp -= opponent_skill.damage
                self._show_text(self.player, f"Your {self.player_creature.display_name} took {opponent_skill.damage} damage!")
        else:
            self._show_text(self.player, "An error occurred: No skills were chosen. Skipping turn.")

    def _check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"Your {self.player_creature.display_name} fainted! You lost the battle.")
            self._reset_creatures()
            self._transition_to_scene("MainMenuScene")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"Opponent's {self.opponent_creature.display_name} fainted! You won the battle!")
            self._reset_creatures()
            self._transition_to_scene("MainMenuScene")
            return True
        return False

    def _reset_creatures(self):
        self.player_creature.hp = self.player_creature.max_hp
        self.opponent_creature.hp = self.opponent_creature.max_hp
```

These changes ensure that:

1. The `_player_turn` and `_opponent_turn` methods will always add a skill to their respective queues before returning.
2. The `run` method only calls `_resolve_turn` if both players have chosen a skill.
3. The `_resolve_turn` method has an additional check to handle cases where one or both skill queues might be empty (although this shouldn't happen with our new checks).

These modifications should resolve the IndexError issue while maintaining the game's logic and adhering to the engine's capabilities and architecture.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
