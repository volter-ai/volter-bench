Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To address the issue of missing implementation for resetting the state of the player's creatures when leaving the MainGameScene, we'll follow these steps:

1. We'll add a method to the MainGameScene class to reset the state of all creatures for both the player and the opponent.
2. We'll call this method at the end of the battle, just before quitting the game.
3. We'll ensure that this reset method only modifies the state of the creatures and doesn't add any methods or properties to the models.

Here's the rewritten `main_game_scene.py` file with the proposed solution:

# Excerpt ID: 166fec1b-dda6-45ca-b6e0-7e01215857e9
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.initialize_battle()
        self.battle_ended = False

    def initialize_battle(self):
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}: {self.player.active_creature.display_name} (HP: {self.player.active_creature.hp}/{self.player.active_creature.max_hp})
{self.opponent.display_name}: {self.opponent.active_creature.display_name} (HP: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp})

> Attack
> Swap
"""

    def run(self):
        while not self.battle_ended:
            self.player_turn()
            if self.check_battle_end():
                break
            self.opponent_turn()
            if self.check_battle_end():
                break
        self.reset_creatures_state()
        self._quit_whole_game()

    def player_turn(self):
        self._show_text(self.player, f"It's your turn, {self.player.display_name}!")
        action = self.get_player_action(self.player)
        if action:
            self.execute_action(self.player, self.opponent, action)

    def opponent_turn(self):
        self._show_text(self.player, f"It's {self.opponent.display_name}'s turn!")
        action = self.get_player_action(self.opponent)
        if action:
            self.execute_action(self.opponent, self.player, action)

    def get_player_action(self, acting_player):
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        choices = [attack_button, swap_button]
        choice = self._wait_for_choice(acting_player, choices)

        if attack_button == choice:
            return self.get_attack_action(acting_player)
        elif swap_button == choice:
            return self.get_swap_action(acting_player)

    def get_attack_action(self, acting_player):
        skill_choices = [SelectThing(skill) for skill in acting_player.active_creature.skills]
        return self._wait_for_choice(acting_player, skill_choices)

    def get_swap_action(self, acting_player):
        available_creatures = [creature for creature in acting_player.creatures if creature != acting_player.active_creature and creature.hp > 0]
        if not available_creatures:
            self._show_text(acting_player, f"No available creatures to swap to!")
            return None
        creature_choices = [SelectThing(creature) for creature in available_creatures]
        return self._wait_for_choice(acting_player, creature_choices)

    def execute_action(self, acting_player, defending_player, action):
        if isinstance(action.thing, Skill):
            self.execute_attack(acting_player, defending_player, action.thing)
        elif isinstance(action.thing, Creature):
            self.execute_swap(acting_player, action.thing)

    def execute_attack(self, attacker, defender, skill):
        damage = self.calculate_damage(attacker.active_creature, defender.active_creature, skill)
        defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
        self._show_text(self.player, f"{attacker.active_creature.display_name} used {skill.display_name} and dealt {damage} damage to {defender.active_creature.display_name}!")

    def execute_swap(self, player, new_creature):
        player.active_creature = new_creature
        self._show_text(self.player, f"{player.display_name} swapped to {new_creature.display_name}!")

    def calculate_damage(self, attacker, defender, skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_effectiveness)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def get_type_effectiveness(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def check_battle_end(self):
        if all(creature.hp == 0 for creature in self.player.creatures):
            self._show_text(self.player, f"All your creatures have fainted. {self.opponent.display_name} wins!")
            self.battle_ended = True
            return True
        elif all(creature.hp == 0 for creature in self.opponent.creatures):
            self._show_text(self.player, f"All opponent's creatures have fainted. You win!")
            self.battle_ended = True
            return True
        elif self.player.active_creature.hp == 0:
            self.force_swap(self.player)
        elif self.opponent.active_creature.hp == 0:
            self.force_swap(self.opponent)
        return False

    def force_swap(self, player):
        available_creatures = [creature for creature in player.creatures if creature.hp > 0]
        if available_creatures:
            creature_choices = [SelectThing(creature) for creature in available_creatures]
            new_creature = self._wait_for_choice(player, creature_choices).thing
            player.active_creature = new_creature
            self._show_text(self.player, f"{player.display_name} was forced to swap to {new_creature.display_name}!")
        else:
            self._show_text(self.player, f"{player.display_name} has no more creatures available!")

    def reset_creatures_state(self):
        for player in [self.player, self.opponent]:
            for creature in player.creatures:
                creature.hp = creature.max_hp
        self._show_text(self.player, "All creatures have been restored to full health.")
```

This solution addresses the issue by:

1. Adding a new `reset_creatures_state` method to the `MainGameScene` class.
2. Calling this method at the end of the battle, just before quitting the game.
3. The `reset_creatures_state` method resets the HP of all creatures for both the player and the opponent to their maximum HP.
4. A message is shown to the player indicating that all creatures have been restored to full health.

These changes ensure that the state of the player's creatures is reset when leaving the MainGameScene, as required. This solution stays within the capabilities of the engine and maintains the current architecture without modifying the models. The `Creature` class in `models.py` remains a pure data schema, and we're only modifying the state of the creatures within the scene logic.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "166fec1b-dda6-45ca-b6e0-7e01215857e9", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
