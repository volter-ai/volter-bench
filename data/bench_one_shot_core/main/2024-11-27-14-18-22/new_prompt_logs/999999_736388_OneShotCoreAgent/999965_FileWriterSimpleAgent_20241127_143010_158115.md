Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis and Solution Plan:

The QA found two issues:
a) Missing "Back" option in Player Choice Phase
b) Not resetting creature state when leaving scene

To fix these:

1. In MainGameScene, I'll modify get_player_action() to:
- Add a "Back" button to both the skill selection and creature swap menus
- Return to the main action menu (Attack/Swap) when Back is selected

2. Add a reset_creatures() method to MainGameScene that:
- Resets each creature's HP to its max_hp
- Call this in run() before exiting the scene

This maintains the pure data model approach since we're not adding methods to the models, just manipulating their properties from the scene.

Here's the fixed implementation:

# Excerpt ID: 0ae08480-6ad3-4799-ba6a-b41af80c859d
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        
        # Set initial active creatures
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]

    def __str__(self):
        p_creature = self.player.active_creature
        o_creature = self.opponent.active_creature
        
        return f"""=== Battle ===
Your {p_creature.display_name}: {p_creature.hp}/{p_creature.max_hp} HP
Foe's {o_creature.display_name}: {o_creature.hp}/{o_creature.max_hp} HP

> Attack
> Swap"""

    def run(self):
        while True:
            # Player turn
            player_action = self.get_player_action(self.player)
            if not player_action:
                continue
                
            # Opponent turn
            opponent_action = self.get_player_action(self.opponent)
            if not opponent_action:
                continue
                
            # Resolve actions
            self.resolve_turn(player_action, opponent_action)
            
            # Check for battle end
            if self.check_battle_end():
                self.reset_creatures()
                self._quit_whole_game()

    def reset_creatures(self):
        # Reset player creatures
        for creature in self.player.creatures:
            creature.hp = creature.max_hp
        
        # Reset opponent creatures
        for creature in self.opponent.creatures:
            creature.hp = creature.max_hp

    def get_player_action(self, player):
        while True:
            # Main action menu
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            
            choice = self._wait_for_choice(player, [attack_button, swap_button])
            
            if choice == attack_button:
                # Attack submenu
                back_button = Button("Back")
                choices = [SelectThing(skill) for skill in player.active_creature.skills]
                choices.append(back_button)
                
                sub_choice = self._wait_for_choice(player, choices)
                if sub_choice == back_button:
                    continue
                return sub_choice
                
            else:  # Swap selected
                # Swap submenu
                available_creatures = [c for c in player.creatures 
                                     if c != player.active_creature and c.hp > 0]
                if not available_creatures:
                    self._show_text(player, "No other creatures available!")
                    continue
                
                back_button = Button("Back")
                choices = [SelectThing(creature) for creature in available_creatures]
                choices.append(back_button)
                
                sub_choice = self._wait_for_choice(player, choices)
                if sub_choice == back_button:
                    continue
                return sub_choice

    def resolve_turn(self, player_action, opponent_action):
        # Handle swaps first
        if isinstance(player_action.thing, Creature):
            self.player.active_creature = player_action.thing
        if isinstance(opponent_action.thing, Creature):
            self.opponent.active_creature = opponent_action.thing
            
        # Then handle attacks
        actions = [(self.player, player_action), (self.opponent, opponent_action)]
        
        # Sort by speed
        actions.sort(key=lambda x: x[0].active_creature.speed, reverse=True)
        
        for actor, action in actions:
            if isinstance(action.thing, Skill):
                self.execute_skill(actor, action.thing)

    def execute_skill(self, attacker, skill):
        defender = self.opponent if attacker == self.player else self.player
        
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = (attacker.active_creature.attack + 
                         skill.base_damage - 
                         defender.active_creature.defense)
        else:
            raw_damage = (skill.base_damage * 
                         attacker.active_creature.sp_attack / 
                         defender.active_creature.sp_defense)
            
        # Apply type effectiveness
        multiplier = self.get_type_multiplier(skill.skill_type, 
                                            defender.active_creature.creature_type)
        
        final_damage = int(raw_damage * multiplier)
        defender.active_creature.hp = max(0, 
            defender.active_creature.hp - final_damage)

    def get_type_multiplier(self, skill_type, creature_type):
        if skill_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(skill_type, {}).get(creature_type, 1.0)

    def check_battle_end(self):
        def has_available_creatures(player):
            return any(c.hp > 0 for c in player.creatures)
            
        if not has_available_creatures(self.player):
            self._show_text(self.player, "You lost!")
            return True
        elif not has_available_creatures(self.opponent):
            self._show_text(self.player, "You won!")
            return True
            
        return False
```

Key changes:
1. Added reset_creatures() method to restore HP when leaving scene
2. Restructured get_player_action() to include Back buttons in submenus
3. Made get_player_action() use a while loop to handle Back button navigation
4. Added reset_creatures() call before quitting game when battle ends

This implementation now fully matches the architecture requirements while maintaining the separation between data models and game logic.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
