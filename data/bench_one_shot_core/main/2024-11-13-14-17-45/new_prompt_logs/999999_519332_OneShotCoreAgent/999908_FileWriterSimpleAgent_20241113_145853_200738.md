Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The error occurs because we're creating an empty list of creature_choices when there are no available creatures to swap to. Looking at the test output, this happens after all creatures are knocked out and we're still trying to handle swaps.

The fix should:
- Move the availability check before creating creature_choices
- Only attempt to swap if there are available creatures
- Check for game over conditions before attempting any swaps
- Follow the engine's pattern of always having valid choices for _wait_for_choice

2. Here's the fixed MainGameScene:

# Excerpt ID: 3e0e9e51-0b16-47ac-9fd6-fcc4c08eeadb
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        # Initialize creatures
        for p in [self.player, self.bot]:
            p.active_creature = p.creatures[0]
            for c in p.creatures:
                c.hp = c.max_hp

    def __str__(self):
        p_creature = self.player.active_creature
        b_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {p_creature.display_name}: {p_creature.hp}/{p_creature.max_hp} HP
Foe's {b_creature.display_name}: {b_creature.hp}/{b_creature.max_hp} HP

> Attack
> Swap
"""

    def calculate_damage(self, attacker: Creature, defender: Creature, skill):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Type effectiveness
        effectiveness = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf": effectiveness = 2.0
            elif defender.creature_type == "water": effectiveness = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire": effectiveness = 2.0
            elif defender.creature_type == "leaf": effectiveness = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water": effectiveness = 2.0
            elif defender.creature_type == "fire": effectiveness = 0.5
            
        return int(raw_damage * effectiveness)

    def get_available_creatures(self, player: Player):
        return [c for c in player.creatures if c.hp > 0 and c != player.active_creature]

    def handle_turn(self, attacker: Player, defender: Player):
        # Get action choice
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        
        # Only show swap if there are creatures to swap to
        available = self.get_available_creatures(attacker)
        choices = [attack_button]
        if available:
            choices.append(swap_button)
            
        choice = self._wait_for_choice(attacker, choices)
        
        if choice == attack_button:
            # Choose skill
            skill_choices = [SelectThing(s) for s in attacker.active_creature.skills]
            skill = self._wait_for_choice(attacker, skill_choices).thing
            return ("attack", skill)
        else:
            # We know there are available creatures because swap was only shown if there were
            creature_choices = [SelectThing(c) for c in available]
            new_creature = self._wait_for_choice(attacker, creature_choices).thing
            return ("swap", new_creature)

    def handle_knocked_out_creature(self, player: Player):
        """Handle a knocked out creature, returns True if the player can continue"""
        # Check if any creatures are still alive
        available = self.get_available_creatures(player)
        if not available:
            self._show_text(self.player, 
                "You win!" if player == self.bot else "You lose!")
            self._quit_whole_game()
            
        # We have creatures available, so swap to one
        creature_choices = [SelectThing(c) for c in available]
        new_creature = self._wait_for_choice(player, creature_choices).thing
        player.active_creature = new_creature
        self._show_text(self.player,
            f"{'You' if player == self.player else 'Foe'} sent out {new_creature.display_name}!")

    def run(self):
        while True:
            # Get actions
            p_action = self.handle_turn(self.player, self.bot)
            b_action = self.handle_turn(self.bot, self.player)
            
            # Handle swaps first
            if p_action[0] == "swap":
                self.player.active_creature = p_action[1]
                self._show_text(self.player, f"You sent out {p_action[1].display_name}!")
            if b_action[0] == "swap":
                self.bot.active_creature = b_action[1]
                self._show_text(self.player, f"Foe sent out {b_action[1].display_name}!")
                
            # Handle attacks based on speed
            actions = []
            if p_action[0] == "attack":
                actions.append((self.player, self.bot, p_action[1]))
            if b_action[0] == "attack":
                actions.append((self.bot, self.player, b_action[1]))
                
            actions.sort(key=lambda x: x[0].active_creature.speed, reverse=True)
            
            for attacker, defender, skill in actions:
                damage = self.calculate_damage(attacker.active_creature, defender.active_creature, skill)
                defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
                self._show_text(self.player, 
                    f"{attacker.active_creature.display_name} used {skill.display_name}! "
                    f"Dealt {damage} damage to {defender.active_creature.display_name}!")
                
                if defender.active_creature.hp == 0:
                    self.handle_knocked_out_creature(defender)
```

Key changes:
- Added `handle_knocked_out_creature` helper method to encapsulate knockout logic
- Only show swap button if there are creatures available to swap to
- Moved availability checks before creating choice lists
- Maintained engine constraints by ensuring all _wait_for_choice calls have valid choices
- Kept the same game logic but made it more robust

This fixes the issue while maintaining the engine's architecture and requirements.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
