Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for bringing this issue to my attention. I'll address the problem with the resolution phase in the MainGameScene where it doesn't handle the case of creatures having the same speed with a random decision.

1. To fix this issue, I'll modify the `_resolution_phase` method in the MainGameScene class. Here's how I'll implement the fix:

   - Compare the speeds of the player's creature and the opponent's creature.
   - If the speeds are equal, use Python's `random.choice()` function to randomly decide which creature goes first.
   - If the speeds are not equal, the creature with higher speed goes first (as already implemented).
   - The rest of the resolution phase logic will remain the same.

This solution adheres to the architecture documentation and stays within the capabilities of the engine. It doesn't require any changes to the models, as we're only modifying the game logic within the scene.

2. Here's the rewritten MainGameScene with the proposed solution:

# Excerpt ID: bc1e7a24-249d-4419-a73b-864eaa5394e1
```python main_game/scenes/main_game_scene.py
import random
from mini_game_engine.engine.lib import AbstractGameScene, Button
from main_game.models import Player, Creature

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Your turn! Choose a skill:
{self._get_skill_choices_str()}
"""

    def _get_skill_choices_str(self):
        return "\n".join([f"> {skill.display_name}" for skill in self.player_creature.skills])

    def run(self):
        self.game_loop()

    def game_loop(self):
        while True:
            # Player Choice Phase
            player_skill = self._player_choice_phase(self.player, self.player_creature)

            # Foe Choice Phase
            foe_skill = self._foe_choice_phase(self.opponent, self.opponent_creature)

            # Resolution Phase
            self._resolution_phase(player_skill, foe_skill)

            # Check for battle end
            if self._check_battle_end():
                self._reset_creatures()
                self._transition_to_scene("MainMenuScene")
                break

    def _player_choice_phase(self, player: Player, creature: Creature):
        choices = [Button(skill.display_name) for skill in creature.skills]
        choice = self._wait_for_choice(player, choices)
        return next(skill for skill in creature.skills if skill.display_name == choice.display_name)

    def _foe_choice_phase(self, opponent: Player, creature: Creature):
        choices = [Button(skill.display_name) for skill in creature.skills]
        choice = self._wait_for_choice(opponent, choices)
        return next(skill for skill in creature.skills if skill.display_name == choice.display_name)

    def _resolution_phase(self, player_skill, foe_skill):
        if self.player_creature.speed == self.opponent_creature.speed:
            # If speeds are equal, randomly decide who goes first
            first_attacker = random.choice([self.player, self.opponent])
            if first_attacker == self.player:
                first, second = (self.player, self.player_creature, player_skill), (self.opponent, self.opponent_creature, foe_skill)
            else:
                first, second = (self.opponent, self.opponent_creature, foe_skill), (self.player, self.player_creature, player_skill)
        elif self.player_creature.speed > self.opponent_creature.speed:
            first, second = (self.player, self.player_creature, player_skill), (self.opponent, self.opponent_creature, foe_skill)
        else:
            first, second = (self.opponent, self.opponent_creature, foe_skill), (self.player, self.player_creature, player_skill)

        for attacker, attacker_creature, skill in [first, second]:
            if attacker == self.player:
                defender, defender_creature = self.opponent, self.opponent_creature
            else:
                defender, defender_creature = self.player, self.player_creature

            damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
            defender_creature.hp = max(0, defender_creature.hp - damage)

            self._show_text(self.player, f"{attacker.display_name}'s {attacker_creature.display_name} used {skill.display_name}!")
            self._show_text(self.player, f"{defender.display_name}'s {defender_creature.display_name} took {damage} damage!")

            if defender_creature.hp == 0:
                break

    def _check_battle_end(self):
        if self.player_creature.hp == 0:
            self._show_text(self.player, f"Your {self.player_creature.display_name} fainted! You lose!")
            return True
        elif self.opponent_creature.hp == 0:
            self._show_text(self.player, f"Opponent's {self.opponent_creature.display_name} fainted! You win!")
            return True
        return False

    def _reset_creatures(self):
        self.player_creature.hp = self.player_creature.max_hp
        self.opponent_creature.hp = self.opponent_creature.max_hp
```

This updated implementation now correctly handles the case where creatures have the same speed by making a random decision, as required by the architecture documentation. The rest of the game logic remains unchanged, ensuring that the solution stays within the capabilities of the engine and doesn't affect the models.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "bc1e7a24-249d-4419-a73b-864eaa5394e1", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
