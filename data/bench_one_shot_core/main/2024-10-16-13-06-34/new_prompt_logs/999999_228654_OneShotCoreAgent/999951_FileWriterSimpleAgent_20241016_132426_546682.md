Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issues raised during QA/testing, we need to address two main problems:

1. The MainGameScene is not exiting properly, either by transitioning to another scene or quitting the game.
2. The scene is not being exited in an expected manner in the random run test.

To resolve these issues, we'll make the following changes to the MainGameScene:

1. After a battle ends (win or lose), we'll transition back to the MainMenuScene.
2. We'll add a "Back to Main Menu" option after displaying the battle result.
3. We'll ensure that the scene always exits properly by using _transition_to_scene or _quit_whole_game.

Here's the proposed solution for the MainGameScene:

# Excerpt ID: 410b6fa4-89e2-4a1f-8259-a4def357b353
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

> Use Skill
> Back to Main Menu
"""

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appeared!")
        while True:
            choices = [
                Button("Use Skill"),
                Button("Back to Main Menu")
            ]
            choice = self._wait_for_choice(self.player, choices)

            if choice.display_name == "Use Skill":
                if self.player_turn():
                    if self.check_battle_end():
                        break
                if self.opponent_turn():
                    if self.check_battle_end():
                        break
            elif choice.display_name == "Back to Main Menu":
                self._transition_to_scene("MainMenuScene")
                return

    def player_turn(self):
        self._show_text(self.player, f"It's your turn! Choose a skill:")
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return self.execute_skill(self.player_creature, self.opponent_creature, choice.thing)

    def opponent_turn(self):
        opponent_skill = random.choice(self.opponent_creature.skills)
        self._show_text(self.player, f"{self.opponent_creature.display_name} uses {opponent_skill.display_name}!")
        return self.execute_skill(self.opponent_creature, self.player_creature, opponent_skill)

    def execute_skill(self, attacker: Creature, defender: Creature, skill: Skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        weakness_factor = self.calculate_weakness_factor(skill.skill_type, defender.creature_type)
        final_damage = int(weakness_factor * raw_damage)
        defender.hp = max(0, defender.hp - final_damage)
        self._show_text(self.player, f"{defender.display_name} took {final_damage} damage!")
        return defender.hp == 0

    def calculate_weakness_factor(self, skill_type: str, defender_type: str):
        if skill_type == defender_type:
            return 1
        elif (skill_type == "fire" and defender_type == "leaf") or \
             (skill_type == "water" and defender_type == "fire") or \
             (skill_type == "leaf" and defender_type == "water"):
            return 2
        elif (skill_type == "fire" and defender_type == "water") or \
             (skill_type == "water" and defender_type == "leaf") or \
             (skill_type == "leaf" and defender_type == "fire"):
            return 0.5
        else:
            return 1

    def check_battle_end(self):
        if self.player_creature.hp == 0:
            self._show_text(self.player, f"Your {self.player_creature.display_name} fainted! You lose!")
            self.end_battle()
            return True
        elif self.opponent_creature.hp == 0:
            self._show_text(self.player, f"The opponent's {self.opponent_creature.display_name} fainted! You win!")
            self.end_battle()
            return True
        return False

    def end_battle(self):
        choices = [Button("Back to Main Menu")]
        choice = self._wait_for_choice(self.player, choices)
        self._transition_to_scene("MainMenuScene")
```

These changes address the issues by:

1. Adding a "Back to Main Menu" option in the main battle loop, allowing the player to exit the battle at any time.
2. Ensuring that the battle always ends by transitioning back to the MainMenuScene, either after a win/loss or when the player chooses to go back.
3. Using _transition_to_scene to properly exit the scene, which should resolve the issues in both the MainGameScene test and the full game flow test.

This solution maintains the existing model structure and adheres to the engine's capabilities and architecture. It should fix the test failures by ensuring that the scene always exits in an expected manner.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "410b6fa4-89e2-4a1f-8259-a4def357b353", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
