Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: To fix the issue, we need to modify the `MainGameScene` class in the `main_game/scenes/main_game_scene.py` file. The problem is that the scene is calling `_quit_whole_game()` directly, which is causing the test to fail. Instead, we should allow the scene to end naturally and return control to the `App` class.

Here's how we'll fix it:

1. Remove the direct call to `_quit_whole_game()`.
2. Implement a loop in the `run` method that continues until the player chooses to quit.
3. When the player chooses to quit, we'll break out of the loop and let the scene end naturally.
4. We'll use the `_transition_to_scene` method to return to the `MainMenuScene` when the player chooses to play again.

This approach will ensure that the scene ends properly without raising an exception, allowing the test to continue running for multiple iterations.

Here's the rewritten `main_game/scenes/main_game_scene.py` file with the proposed solution:

# Excerpt ID: 779afad9-00e2-4199-9158-098151403792
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button
from main_game.models import Player, Creature, Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app: "AbstractApp", player: Player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""
Creature Battle!

{self.player.display_name}'s {self.player_creature.display_name}:
HP: {self.player_creature.hp}/{self.player_creature.max_hp}

{self.opponent.display_name}'s {self.opponent_creature.display_name}:
HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available skills:
{', '.join(skill.display_name for skill in self.player_creature.skills)}
"""

    def run(self):
        while True:
            self._reset_creatures()
            self._battle()
            if not self._play_again_choice():
                break

    def _reset_creatures(self):
        self.player_creature.hp = self.player_creature.max_hp
        self.opponent_creature.hp = self.opponent_creature.max_hp

    def _battle(self):
        while True:
            self._show_text(self.player, str(self))
            
            player_skill = self._player_choice_phase()
            opponent_skill = self._foe_choice_phase()
            self._resolution_phase(player_skill, opponent_skill)
            
            if self._check_battle_end():
                break

    def _player_choice_phase(self):
        choices = [Button(skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return next(skill for skill in self.player_creature.skills if skill.display_name == choice.display_name)

    def _foe_choice_phase(self):
        choices = [Button(skill.display_name) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return next(skill for skill in self.opponent_creature.skills if skill.display_name == choice.display_name)

    def _resolution_phase(self, player_skill: Skill, opponent_skill: Skill):
        if self.player_creature.speed >= self.opponent_creature.speed:
            self._execute_skill(self.player, self.player_creature, player_skill, self.opponent_creature)
            if self.opponent_creature.hp > 0:
                self._execute_skill(self.opponent, self.opponent_creature, opponent_skill, self.player_creature)
        else:
            self._execute_skill(self.opponent, self.opponent_creature, opponent_skill, self.player_creature)
            if self.player_creature.hp > 0:
                self._execute_skill(self.player, self.player_creature, player_skill, self.opponent_creature)

    def _execute_skill(self, attacker: Player, attacker_creature: Creature, skill: Skill, defender_creature: Creature):
        raw_damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        weakness_factor = self._calculate_weakness_factor(skill.skill_type, defender_creature.creature_type)
        final_damage = int(weakness_factor * raw_damage)
        defender_creature.hp = max(0, defender_creature.hp - final_damage)
        
        self._show_text(self.player, f"{attacker.display_name}'s {attacker_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"It dealt {final_damage} damage to {defender_creature.display_name}!")

    def _calculate_weakness_factor(self, skill_type: str, defender_type: str) -> float:
        if skill_type == defender_type:
            return 1.0
        elif (skill_type == "fire" and defender_type == "leaf") or \
             (skill_type == "water" and defender_type == "fire") or \
             (skill_type == "leaf" and defender_type == "water"):
            return 2.0
        elif (skill_type == "fire" and defender_type == "water") or \
             (skill_type == "water" and defender_type == "leaf") or \
             (skill_type == "leaf" and defender_type == "fire"):
            return 0.5
        else:
            return 1.0

    def _check_battle_end(self) -> bool:
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name}, you have lost the battle!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"Congratulations {self.player.display_name}, you have won the battle!")
            return True
        return False

    def _play_again_choice(self) -> bool:
        choice = self._wait_for_choice(self.player, [
            Button("Play Again"),
            Button("Quit")
        ])
        if choice.display_name == "Play Again":
            return True
        else:
            return False
```

This solution addresses the issue by removing the direct call to `_quit_whole_game()` and instead allowing the scene to end naturally when the player chooses to quit. The main game loop continues until the player decides to quit, and each battle is reset properly for a new round. This should resolve the test failures and maintain the proper flow of the game within the engine's architecture.
__________________
Role: assistant
Content: ```json
{
  "actions": [
    {
      "action": "overwrite",
      "excerpt_id": "779afad9-00e2-4199-9158-098151403792",
      "file_path": "main_game/scenes/main_game_scene.py"
    }
  ]
}
```
__________________
