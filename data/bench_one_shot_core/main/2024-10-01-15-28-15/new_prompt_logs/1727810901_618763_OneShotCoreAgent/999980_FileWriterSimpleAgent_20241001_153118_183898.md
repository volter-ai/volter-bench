Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: To fix the issues raised during QA/testing, we need to address two main problems:

1. The opponent's listener is not set, causing an AttributeError when trying to show text to the opponent.
2. The MainGameScene is not registered in the TestApp used for testing, causing a KeyError when trying to transition to it.

Here's how we'll fix these issues:

1. In the MainGameScene, we'll ensure that the opponent's listener is set when creating the bot.
2. In the test files, we'll update the TestApp to register both MainMenuScene and MainGameScene.

Let's rewrite the necessary files with these fixes:

# Excerpt ID: 1c213a3d-b402-4634-ad11-6767e14985e0
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, AbstractApp
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app: "AbstractApp", player: Player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return (
            f"Player: {self.player.display_name}\n"
            f"Creature: {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})\n"
            f"Opponent: {self.opponent.display_name}\n"
            f"Creature: {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})\n"
            f"Available skills:\n" + "\n".join([f"- {skill.display_name}" for skill in self.player_creature.skills])
        )

    def run(self):
        while True:
            self._show_text(self.player, str(self))
            self._show_text(self.opponent, str(self))

            player_skill = self._player_choice_phase()
            opponent_skill = self._foe_choice_phase()

            self._resolution_phase(player_skill, opponent_skill)

            if self._check_battle_end():
                break

    def _player_choice_phase(self) -> Skill:
        choices = [Button(skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return next(skill for skill in self.player_creature.skills if skill.display_name == choice.display_name)

    def _foe_choice_phase(self) -> Skill:
        choices = [Button(skill.display_name) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return next(skill for skill in self.opponent_creature.skills if skill.display_name == choice.display_name)

    def _resolution_phase(self, player_skill: Skill, opponent_skill: Skill):
        if self.player_creature.speed > self.opponent_creature.speed:
            self._execute_skill(self.player, self.player_creature, player_skill, self.opponent_creature)
            if not self._check_battle_end():
                self._execute_skill(self.opponent, self.opponent_creature, opponent_skill, self.player_creature)
        elif self.player_creature.speed < self.opponent_creature.speed:
            self._execute_skill(self.opponent, self.opponent_creature, opponent_skill, self.player_creature)
            if not self._check_battle_end():
                self._execute_skill(self.player, self.player_creature, player_skill, self.opponent_creature)
        else:
            if random.choice([True, False]):
                self._execute_skill(self.player, self.player_creature, player_skill, self.opponent_creature)
                if not self._check_battle_end():
                    self._execute_skill(self.opponent, self.opponent_creature, opponent_skill, self.player_creature)
            else:
                self._execute_skill(self.opponent, self.opponent_creature, opponent_skill, self.player_creature)
                if not self._check_battle_end():
                    self._execute_skill(self.player, self.player_creature, player_skill, self.opponent_creature)

    def _execute_skill(self, attacker: Player, attacker_creature: Creature, skill: Skill, defender_creature: Creature):
        damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        defender_creature.hp = max(0, defender_creature.hp - damage)
        self._show_text(self.player, f"{attacker_creature.display_name} used {skill.display_name} and dealt {damage} damage to {defender_creature.display_name}!")
        self._show_text(self.opponent, f"{attacker_creature.display_name} used {skill.display_name} and dealt {damage} damage to {defender_creature.display_name}!")

    def _check_battle_end(self) -> bool:
        if self.player_creature.hp == 0:
            self._show_text(self.player, "You lost the battle!")
            self._show_text(self.opponent, "You won the battle!")
            self._transition_to_scene("MainMenuScene")
            return True
        elif self.opponent_creature.hp == 0:
            self._show_text(self.player, "You won the battle!")
            self._show_text(self.opponent, "You lost the battle!")
            self._transition_to_scene("MainMenuScene")
            return True
        return False
```

# Excerpt ID: dad27bd4-3ba9-46b9-a169-8f063db73085
```python main_game/tests/test_main_menu_scene.py
import pytest
from mini_game_engine.engine.lib import HumanListener, AbstractApp, BotListener
from main_game.scenes.main_menu_scene import MainMenuScene
from main_game.scenes.main_game_scene import MainGameScene
from main_game.models import Player

class TestApp(AbstractApp):
    def __init__(self):
        super().__init__()
        self.register_scene("MainMenuScene", MainMenuScene)
        self.register_scene("MainGameScene", MainGameScene)

    def create_player(self, player_id: str) -> Player:
        player = Player.from_prototype_id("default_player")
        player.uid = player_id
        player.set_listener(HumanListener())
        return player

    def create_bot(self, prototype_id: str) -> Player:
        bot = Player.from_prototype_id(prototype_id)
        bot.set_listener(BotListener())
        return bot

@pytest.fixture
def app():
    return TestApp()

@pytest.fixture
def player(app):
    return app.create_player("test_player")

def test_main_menu_scene(app, player):
    HumanListener.random_mode = True
    for _ in range(10):
        scene = MainMenuScene(app, player)
        scene.run()
```

# Excerpt ID: 4ce685a7-1f46-4a28-8457-948af7a0f46d
```python main_game/tests/test_main_game_scene.py
import pytest
from mini_game_engine.engine.lib import HumanListener, AbstractApp, BotListener
from main_game.scenes.main_game_scene import MainGameScene
from main_game.scenes.main_menu_scene import MainMenuScene
from main_game.models import Player

class TestApp(AbstractApp):
    def __init__(self):
        super().__init__()
        self.register_scene("MainMenuScene", MainMenuScene)
        self.register_scene("MainGameScene", MainGameScene)

    def create_player(self, player_id: str) -> Player:
        player = Player.from_prototype_id("default_player")
        player.uid = player_id
        player.set_listener(HumanListener())
        return player

    def create_bot(self, prototype_id: str) -> Player:
        bot = Player.from_prototype_id(prototype_id)
        bot.set_listener(BotListener())
        return bot

@pytest.fixture
def app():
    return TestApp()

@pytest.fixture
def player(app):
    return app.create_player("test_player")

def test_main_game_scene(app, player):
    HumanListener.random_mode = True
    for _ in range(10):
        scene = MainGameScene(app, player)
        scene.run()
```

These changes should resolve the issues:

1. In the MainGameScene, we didn't need to change anything as the `create_bot` method in the App class is responsible for setting the listener.
2. In both test files, we've updated the TestApp to register both MainMenuScene and MainGameScene, and ensured that the `create_bot` method sets the listener for the bot.

These modifications should fix the AttributeError and KeyError issues while maintaining the architecture and staying within the capabilities of the engine.
__________________
Role: assistant
Content: ```json
{
  "actions": [
    {
      "action": "overwrite",
      "excerpt_id": "1c213a3d-b402-4634-ad11-6767e14985e0",
      "file_path": "main_game/scenes/main_game_scene.py"
    },
    {
      "action": "overwrite",
      "excerpt_id": "dad27bd4-3ba9-46b9-a169-8f063db73085",
      "file_path": "main_game/tests/test_main_menu_scene.py"
    },
    {
      "action": "overwrite",
      "excerpt_id": "4ce685a7-1f46-4a28-8457-948af7a0f46d",
      "file_path": "main_game/tests/test_main_game_scene.py"
    }
  ]
}
```
__________________
