Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
The issue is that the MainGameScene returns directly after showing the win/loss message instead of properly transitioning back to the main menu or quitting the game. According to the engine's requirements, scenes must always end by either:

1. Transitioning to another scene using `_transition_to_scene()` 
2. Quitting the game using `_quit_whole_game()`

For this game, after a battle ends (win or loss), we should transition back to the MainMenuScene so the player can choose to play again or quit.

Here's the fixed MainGameScene:

# Excerpt ID: 62e68849-cffb-42f6-95f5-c926a27d5ecc
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        
        # Initialize creatures
        for p in [self.player, self.bot]:
            p.active_creature = p.creatures[0]
            for c in p.creatures:
                c.hp = c.max_hp

    def __str__(self):
        p_creature = self.player.active_creature
        b_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {p_creature.display_name}: {p_creature.hp}/{p_creature.max_hp} HP
Foe's {b_creature.display_name}: {b_creature.hp}/{b_creature.max_hp} HP

> Attack
> Swap
"""

    def calculate_damage(self, attacker: Creature, defender: Creature, skill):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        # Type effectiveness
        effectiveness = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf": effectiveness = 2.0
            elif defender.creature_type == "water": effectiveness = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire": effectiveness = 2.0
            elif defender.creature_type == "leaf": effectiveness = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water": effectiveness = 2.0
            elif defender.creature_type == "fire": effectiveness = 0.5

        return int(raw_damage * effectiveness)

    def get_available_creatures(self, player: Player):
        return [c for c in player.creatures if c.hp > 0 and c != player.active_creature]

    def handle_turn(self, attacker: Player, defender: Player):
        # Get action choice
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        choice = self._wait_for_choice(attacker, [attack_button, swap_button])

        if choice == attack_button:
            # Choose skill
            skill_choices = [SelectThing(s) for s in attacker.active_creature.skills]
            back_button = Button("Back")
            skill_choice = self._wait_for_choice(attacker, skill_choices + [back_button])
            
            if skill_choice == back_button:
                return self.handle_turn(attacker, defender)
            
            return ("attack", skill_choice.thing)
        else:
            # Choose creature to swap to
            available = self.get_available_creatures(attacker)
            if not available:
                self._show_text(attacker, "No creatures available to swap to!")
                return self.handle_turn(attacker, defender)
                
            swap_choices = [SelectThing(c) for c in available]
            back_button = Button("Back")
            swap_choice = self._wait_for_choice(attacker, swap_choices + [back_button])
            
            if swap_choice == back_button:
                return self.handle_turn(attacker, defender)
                
            return ("swap", swap_choice.thing)

    def run(self):
        while True:
            # Get actions
            player_action = self.handle_turn(self.player, self.bot)
            bot_action = self.handle_turn(self.bot, self.player)

            # Handle swaps first
            for actor, action in [(self.player, player_action), (self.bot, bot_action)]:
                if action[0] == "swap":
                    actor.active_creature = action[1]
                    self._show_text(self.player, f"{actor.display_name} swapped to {action[1].display_name}!")

            # Handle attacks in speed order
            actors = [(self.player, player_action), (self.bot, bot_action)]
            actors.sort(key=lambda x: x[0].active_creature.speed, reverse=True)

            for actor, action in actors:
                if action[0] == "attack":
                    defender = self.bot if actor == self.player else self.player
                    damage = self.calculate_damage(actor.active_creature, defender.active_creature, action[1])
                    defender.active_creature.hp -= damage
                    self._show_text(self.player, 
                        f"{actor.display_name}'s {actor.active_creature.display_name} used {action[1].display_name}! "
                        f"Dealt {damage} damage!")

                    # Check for fainted creature
                    if defender.active_creature.hp <= 0:
                        defender.active_creature.hp = 0
                        self._show_text(self.player, 
                            f"{defender.display_name}'s {defender.active_creature.display_name} fainted!")
                        
                        # Check for available creatures
                        available = self.get_available_creatures(defender)
                        if not available:
                            self._show_text(self.player, 
                                f"{'You won!' if defender == self.bot else 'You lost!'}")
                            # Instead of returning, transition back to main menu
                            self._transition_to_scene("MainMenuScene")
                            return  # Need return after transition
                            
                        # Force swap
                        swap_choices = [SelectThing(c) for c in available]
                        swap_choice = self._wait_for_choice(defender, swap_choices)
                        defender.active_creature = swap_choice.thing
                        self._show_text(self.player,
                            f"{defender.display_name} sent out {swap_choice.thing.display_name}!")
```

The key change is replacing the direct `return` after showing the win/loss message with:

# Excerpt ID: 0dcd160b-3591-482c-8146-c489092cccdd
```python
self._transition_to_scene("MainMenuScene")
return  # Need return after transition
```

This ensures the scene properly transitions back to the main menu when the battle ends, following the engine's requirements that scenes must end with either a transition or quit.

The rest of the file remains unchanged since the issue was specifically about the scene termination behavior. This change maintains the game's architecture and functionality while properly following the engine's scene transition requirements.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
