timestamp,run_id,agent_id,ladder,run,status,error,traceback,logs,project_directory,commit_url,branch_name,project_type,override_model,strong_completion_model,base_chat_completion_model,fast_chat_completion_model,strong_coding_completion_model
2024-12-15 14:17:55,5c607855-199f-46a9-8fa2-8345916d4a4b,OneShotCoreAgent,creature_battler_01,6,success,,,['new_prompt_logs/999991_143990_OneShotCoreAgent'],ladder/creature_battler_01_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:17:59,bd37df78-e56e-4aeb-9ac1-2ae29ca9c0e0,OneShotCoreAgent,creature_battler_01,7,success,,,['new_prompt_logs/999993_727898_OneShotCoreAgent'],ladder/creature_battler_01_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:18:00,8aa8ea4b-295d-4ab9-acf6-990cd3a53e6c,OneShotCoreAgent,creature_battler_01,2,success,,,['new_prompt_logs/999998_878960_OneShotCoreAgent'],ladder/creature_battler_01_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:18:07,cc42d079-98b3-42a3-9346-7c185f76c71e,OneShotCoreAgent,creature_battler_01,1,success,,,['new_prompt_logs/999997_398020_OneShotCoreAgent'],ladder/creature_battler_01_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:18:11,e5924ad1-eb71-467e-b56a-9a4a44df4380,OneShotCoreAgent,creature_battler_02,3,success,,,['new_prompt_logs/999999_515681_OneShotCoreAgent'],ladder/creature_battler_02_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:18:11,4425c1e7-2810-4b27-9278-da0d2cfe70fb,OneShotCoreAgent,creature_battler_01,3,success,,,['new_prompt_logs/999996_309788_OneShotCoreAgent'],ladder/creature_battler_01_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:18:12,9cb81fbc-5b76-4e9e-930d-adc4d0deb62a,OneShotCoreAgent,creature_battler_02,1,success,,,['new_prompt_logs/999994_664394_OneShotCoreAgent'],ladder/creature_battler_02_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:18:13,252d1e1a-d78b-4a39-acf8-415cce18b152,OneShotCoreAgent,creature_battler_01,4,success,,,['new_prompt_logs/999992_873044_OneShotCoreAgent'],ladder/creature_battler_01_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:18:15,f6d8b776-5d7c-4c89-9d0c-b21b557ea588,OneShotCoreAgent,creature_battler_02,2,success,,,['new_prompt_logs/999995_200193_OneShotCoreAgent'],ladder/creature_battler_02_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:18:57,3a9c3c82-8d08-47d8-9c3e-8bb381cbecfd,OneShotCoreAgent,creature_battler_01,5,success,,,['new_prompt_logs/999990_225532_OneShotCoreAgent'],ladder/creature_battler_01_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:19:24,3f1ade99-71d3-4b5a-a213-547647fba3a9,OneShotCoreAgent,creature_battler_02,7,success,,,['new_prompt_logs/999997_398020_OneShotCoreAgent'],ladder/creature_battler_02_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:19:25,0f096181-e225-4722-a85e-3a934c0c68ca,OneShotCoreAgent,creature_battler_02,4,success,,,['new_prompt_logs/999991_143990_OneShotCoreAgent'],ladder/creature_battler_02_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:19:29,4c9bc372-aad6-454f-88bd-3f52adc7c5f3,OneShotCoreAgent,creature_battler_02,5,success,,,['new_prompt_logs/999993_727898_OneShotCoreAgent'],ladder/creature_battler_02_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:19:29,ef1239fc-a40c-4022-8c84-70491d5e1c03,OneShotCoreAgent,creature_battler_02,6,success,,,['new_prompt_logs/999998_878960_OneShotCoreAgent'],ladder/creature_battler_02_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:19:36,07a6f0b5-7932-429e-8af4-4bc3c7483c7d,OneShotCoreAgent,creature_battler_03,2,success,,,['new_prompt_logs/999996_309788_OneShotCoreAgent'],ladder/creature_battler_03_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:19:39,6676bde4-ead8-4f9f-9277-510105b64981,OneShotCoreAgent,creature_battler_03,5,success,,,['new_prompt_logs/999995_200193_OneShotCoreAgent'],ladder/creature_battler_03_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:19:41,05b9eb4a-3b83-43f9-98db-a2a2276da870,OneShotCoreAgent,creature_battler_03,4,success,,,['new_prompt_logs/999992_873044_OneShotCoreAgent'],ladder/creature_battler_03_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:19:41,9601e74f-cadd-42fe-a6b1-27bcb4cdce5d,OneShotCoreAgent,creature_battler_03,3,success,,,['new_prompt_logs/999994_664394_OneShotCoreAgent'],ladder/creature_battler_03_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:20:24,d197740b-8f7e-4892-9269-9e270c616221,OneShotCoreAgent,creature_battler_03,1,success,,,['new_prompt_logs/999999_515681_OneShotCoreAgent'],ladder/creature_battler_03_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:20:38,159dadbd-d037-4375-acc1-5bc5fcf6759e,OneShotCoreAgent,creature_battler_03,6,success,,,['new_prompt_logs/999990_225532_OneShotCoreAgent'],ladder/creature_battler_03_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:20:55,89632f96-61e0-49e5-9950-5db4b61fe3f3,OneShotCoreAgent,creature_battler_04,3,success,,,['new_prompt_logs/999998_878960_OneShotCoreAgent'],ladder/creature_battler_04_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:21:02,c28c79a1-35bd-4ec8-aa1d-8dc977703f79,OneShotCoreAgent,creature_battler_04,1,success,,,['new_prompt_logs/999991_143990_OneShotCoreAgent'],ladder/creature_battler_04_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:21:06,fa6d6cc3-5059-45d3-ba46-f7ed3dff7cc6,OneShotCoreAgent,creature_battler_04,4,success,,,['new_prompt_logs/999996_309788_OneShotCoreAgent'],ladder/creature_battler_04_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:21:33,fb73bd18-e8c0-46ef-9ca5-78d217c6f65f,OneShotCoreAgent,creature_battler_04,7,success,,,['new_prompt_logs/999994_664394_OneShotCoreAgent'],ladder/creature_battler_04_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:21:36,c3d0e901-79ec-40bf-b436-6d08e12525df,OneShotCoreAgent,creature_battler_04,5,success,,,['new_prompt_logs/999995_200193_OneShotCoreAgent'],ladder/creature_battler_04_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:21:45,96a2326b-2630-4357-9f97-e50a52763917,OneShotCoreAgent,creature_battler_04,2,success,,,['new_prompt_logs/999993_727898_OneShotCoreAgent'],ladder/creature_battler_04_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:21:58,1c8ef667-1afd-439c-a159-4c12838f7935,OneShotCoreAgent,creature_battler_04,6,success,,,['new_prompt_logs/999992_873044_OneShotCoreAgent'],ladder/creature_battler_04_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:22:00,69388342-2012-4075-b01d-292cdd81abac,OneShotCoreAgent,creature_battler_03,7,success,,,['new_prompt_logs/999997_398020_OneShotCoreAgent'],ladder/creature_battler_03_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:22:47,b1e3a0e9-ce9e-4fc7-a2f4-b55ebc8bd9f8,OneShotCoreAgent,creature_battler_05,2,success,,,['new_prompt_logs/999990_225532_OneShotCoreAgent'],ladder/creature_battler_05_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:22:55,e6d51389-acd0-4c53-a764-654425ac7ddb,OneShotCoreAgent,creature_battler_05,3,success,,,['new_prompt_logs/999998_878960_OneShotCoreAgent'],ladder/creature_battler_05_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:23:28,6e8061a1-8843-409c-96c0-78ad40ab9cd8,OneShotCoreAgent,creature_battler_05,4,success,,,['new_prompt_logs/999991_143990_OneShotCoreAgent'],ladder/creature_battler_05_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:23:38,b1310b17-8238-48c6-8d88-837eb3c8517d,OneShotCoreAgent,creature_battler_05,1,failure,"After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform linux -- Python 3.11.9, pytest-7.3.1, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: sugar-0.9.7, cov-4.1.0, anyio-4.7.0, Faker-30.10.0, timeout-2.3.1, metadata-3.1.1, asyncio-0.23.8, html-3.2.0, time-machine-2.16.0
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
                main_game_scene.run()
            except (RandomModeGracefulExit, AbstractApp._QuitWholeGame) as e:
                print(f""Run {i} completed successfully with: {str(e)}"")
                continue
            except Exception as e:
>               raise e  # Re-raise unexpected exceptions

main_game/tests/test_main_game_scene.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/tests/test_main_game_scene.py:21: in test_main_game_scene_random_run
    main_game_scene.run()
main_game/scenes/main_game_scene.py:37: in run
    bot_action = self.get_player_action(self.bot)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Basic Opponent

    def get_player_action(self, player):
        while True:
            attack_button = Button(""Attack"")
            swap_button = Button(""Swap"")
    
            choice = self._wait_for_choice(player, [attack_button, swap_button])
    
            if choice == attack_button:
                # Add Back button for human players
                choices = [SelectThing(skill) for skill in player.active_creature.skills]
                if player == self.player:  # Only add Back for human player
                    back_button = Button(""Back"")
                    choices.append(back_button)
    
                skill_choice = self._wait_for_choice(player, choices)
                if skill_choice == back_button:
                    continue  # Go back to main choice
                return skill_choice
            else:
                valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
                if not valid_creatures:
                    return None
    
                choices = [SelectThing(creature) for creature in valid_creatures]
                if player == self.player:  # Only add Back for human player
                    back_button = Button(""Back"")
                    choices.append(back_button)
    
                swap_choice = self._wait_for_choice(player, choices)
>               if swap_choice == back_button:
E               UnboundLocalError: cannot access local variable 'back_button' where it is not associated with a value

main_game/scenes/main_game_scene.py:79: UnboundLocalError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:629: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:23: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:462: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:37: in run
    bot_action = self.get_player_action(self.bot)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Basic Opponent

    def get_player_action(self, player):
        while True:
            attack_button = Button(""Attack"")
            swap_button = Button(""Swap"")
    
            choice = self._wait_for_choice(player, [attack_button, swap_button])
    
            if choice == attack_button:
                # Add Back button for human players
                choices = [SelectThing(skill) for skill in player.active_creature.skills]
                if player == self.player:  # Only add Back for human player
                    back_button = Button(""Back"")
                    choices.append(back_button)
    
                skill_choice = self._wait_for_choice(player, choices)
                if skill_choice == back_button:
                    continue  # Go back to main choice
                return skill_choice
            else:
                valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
                if not valid_creatures:
                    return None
    
                choices = [SelectThing(creature) for creature in valid_creatures]
                if player == self.player:  # Only add Back for human player
                    back_button = Button(""Back"")
                    choices.append(back_button)
    
                swap_choice = self._wait_for_choice(player, choices)
>               if swap_choice == back_button:
E               UnboundLocalError: cannot access local variable 'back_button' where it is not associated with a value

main_game/scenes/main_game_scene.py:79: UnboundLocalError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run - UnboundLocalError: cannot access local variable 'back_button' where it is not associated with a value
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots - UnboundLocalError: cannot access local variable 'back_button' where it is not associated with a value
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1
","Traceback (most recent call last):
  File ""/home/runner/_work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py"", line 72, in execute
    await self.sdk.execute_as_task(PytestRunnerAgent, verbose=False)
  File ""/home/runner/_work/volter-monorepo/volter-monorepo/volter-monorepo/packages/volter-common/common/sdk/SDK.py"", line 255, in execute_as_task
    response = await agent.execute()
               ^^^^^^^^^^^^^^^^^^^^^
  File ""/home/runner/_work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_agents/internal/game/pytest_runner_agent/logic.py"", line 30, in execute
    output = run_pytest(test_file_path, project_root=self.sdk.project_directory, verbose=self.verbose)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/runner/_work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-std-agents/agent_lib/random_run_utils.py"", line 141, in run_pytest
    raise AssertionError(f""Pytest failed with exit code {exit_code}. Output:\n{output}"")
AssertionError: Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform linux -- Python 3.11.9, pytest-7.3.1, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: sugar-0.9.7, cov-4.1.0, anyio-4.7.0, Faker-30.10.0, timeout-2.3.1, metadata-3.1.1, asyncio-0.23.8, html-3.2.0, time-machine-2.16.0
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
                main_game_scene.run()
            except (RandomModeGracefulExit, AbstractApp._QuitWholeGame) as e:
                print(f""Run {i} completed successfully with: {str(e)}"")
                continue
            except Exception as e:
>               raise e  # Re-raise unexpected exceptions

main_game/tests/test_main_game_scene.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/tests/test_main_game_scene.py:21: in test_main_game_scene_random_run
    main_game_scene.run()
main_game/scenes/main_game_scene.py:37: in run
    bot_action = self.get_player_action(self.bot)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Basic Opponent

    def get_player_action(self, player):
        while True:
            attack_button = Button(""Attack"")
            swap_button = Button(""Swap"")
    
            choice = self._wait_for_choice(player, [attack_button, swap_button])
    
            if choice == attack_button:
                # Add Back button for human players
                choices = [SelectThing(skill) for skill in player.active_creature.skills]
                if player == self.player:  # Only add Back for human player
                    back_button = Button(""Back"")
                    choices.append(back_button)
    
                skill_choice = self._wait_for_choice(player, choices)
                if skill_choice == back_button:
                    continue  # Go back to main choice
                return skill_choice
            else:
                valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
                if not valid_creatures:
                    return None
    
                choices = [SelectThing(creature) for creature in valid_creatures]
                if player == self.player:  # Only add Back for human player
                    back_button = Button(""Back"")
                    choices.append(back_button)
    
                swap_choice = self._wait_for_choice(player, choices)
>               if swap_choice == back_button:
E               UnboundLocalError: cannot access local variable 'back_button' where it is not associated with a value

main_game/scenes/main_game_scene.py:79: UnboundLocalError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:629: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:23: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:462: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:37: in run
    bot_action = self.get_player_action(self.bot)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Basic Opponent

    def get_player_action(self, player):
        while True:
            attack_button = Button(""Attack"")
            swap_button = Button(""Swap"")
    
            choice = self._wait_for_choice(player, [attack_button, swap_button])
    
            if choice == attack_button:
                # Add Back button for human players
                choices = [SelectThing(skill) for skill in player.active_creature.skills]
                if player == self.player:  # Only add Back for human player
                    back_button = Button(""Back"")
                    choices.append(back_button)
    
                skill_choice = self._wait_for_choice(player, choices)
                if skill_choice == back_button:
                    continue  # Go back to main choice
                return skill_choice
            else:
                valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
                if not valid_creatures:
                    return None
    
                choices = [SelectThing(creature) for creature in valid_creatures]
                if player == self.player:  # Only add Back for human player
                    back_button = Button(""Back"")
                    choices.append(back_button)
    
                swap_choice = self._wait_for_choice(player, choices)
>               if swap_choice == back_button:
E               UnboundLocalError: cannot access local variable 'back_button' where it is not associated with a value

main_game/scenes/main_game_scene.py:79: UnboundLocalError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run - UnboundLocalError: cannot access local variable 'back_button' where it is not associated with a value
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots - UnboundLocalError: cannot access local variable 'back_button' where it is not associated with a value
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1


During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/home/runner/_work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_bench/bench_utils.py"", line 93, in execute_agent
    asyncio.run(agent.execute())
  File ""/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/asyncio/runners.py"", line 190, in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
  File ""/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/asyncio/runners.py"", line 118, in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/asyncio/base_events.py"", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File ""/home/runner/_work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py"", line 79, in execute
    raise FixableException(
common.exceptions.FixableException: After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform linux -- Python 3.11.9, pytest-7.3.1, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: sugar-0.9.7, cov-4.1.0, anyio-4.7.0, Faker-30.10.0, timeout-2.3.1, metadata-3.1.1, asyncio-0.23.8, html-3.2.0, time-machine-2.16.0
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
                main_game_scene.run()
            except (RandomModeGracefulExit, AbstractApp._QuitWholeGame) as e:
                print(f""Run {i} completed successfully with: {str(e)}"")
                continue
            except Exception as e:
>               raise e  # Re-raise unexpected exceptions

main_game/tests/test_main_game_scene.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/tests/test_main_game_scene.py:21: in test_main_game_scene_random_run
    main_game_scene.run()
main_game/scenes/main_game_scene.py:37: in run
    bot_action = self.get_player_action(self.bot)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Basic Opponent

    def get_player_action(self, player):
        while True:
            attack_button = Button(""Attack"")
            swap_button = Button(""Swap"")
    
            choice = self._wait_for_choice(player, [attack_button, swap_button])
    
            if choice == attack_button:
                # Add Back button for human players
                choices = [SelectThing(skill) for skill in player.active_creature.skills]
                if player == self.player:  # Only add Back for human player
                    back_button = Button(""Back"")
                    choices.append(back_button)
    
                skill_choice = self._wait_for_choice(player, choices)
                if skill_choice == back_button:
                    continue  # Go back to main choice
                return skill_choice
            else:
                valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
                if not valid_creatures:
                    return None
    
                choices = [SelectThing(creature) for creature in valid_creatures]
                if player == self.player:  # Only add Back for human player
                    back_button = Button(""Back"")
                    choices.append(back_button)
    
                swap_choice = self._wait_for_choice(player, choices)
>               if swap_choice == back_button:
E               UnboundLocalError: cannot access local variable 'back_button' where it is not associated with a value

main_game/scenes/main_game_scene.py:79: UnboundLocalError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:629: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:23: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:462: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:37: in run
    bot_action = self.get_player_action(self.bot)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Basic Opponent

    def get_player_action(self, player):
        while True:
            attack_button = Button(""Attack"")
            swap_button = Button(""Swap"")
    
            choice = self._wait_for_choice(player, [attack_button, swap_button])
    
            if choice == attack_button:
                # Add Back button for human players
                choices = [SelectThing(skill) for skill in player.active_creature.skills]
                if player == self.player:  # Only add Back for human player
                    back_button = Button(""Back"")
                    choices.append(back_button)
    
                skill_choice = self._wait_for_choice(player, choices)
                if skill_choice == back_button:
                    continue  # Go back to main choice
                return skill_choice
            else:
                valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
                if not valid_creatures:
                    return None
    
                choices = [SelectThing(creature) for creature in valid_creatures]
                if player == self.player:  # Only add Back for human player
                    back_button = Button(""Back"")
                    choices.append(back_button)
    
                swap_choice = self._wait_for_choice(player, choices)
>               if swap_choice == back_button:
E               UnboundLocalError: cannot access local variable 'back_button' where it is not associated with a value

main_game/scenes/main_game_scene.py:79: UnboundLocalError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run - UnboundLocalError: cannot access local variable 'back_button' where it is not associated with a value
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots - UnboundLocalError: cannot access local variable 'back_button' where it is not associated with a value
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1

",['new_prompt_logs/999999_515681_OneShotCoreAgent'],ladder/creature_battler_05_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:24:01,dc8d3fe8-6aec-4c87-9b93-d057e2c6cbbb,OneShotCoreAgent,creature_battler_05,7,success,,,['new_prompt_logs/999995_200193_OneShotCoreAgent'],ladder/creature_battler_05_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:24:39,9d1e5c9f-39b3-410c-bafb-a9c8acddb430,OneShotCoreAgent,creature_battler_05,6,failure,"After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform linux -- Python 3.11.9, pytest-7.3.1, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: sugar-0.9.7, cov-4.1.0, anyio-4.7.0, Faker-30.10.0, timeout-2.3.1, metadata-3.1.1, asyncio-0.23.8, html-3.2.0, time-machine-2.16.0
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
>               main_game_scene.run()

main_game/tests/test_main_game_scene.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        while True:
            # Player Choice Phase
>           player_action = self.player_choice_phase()

main_game/scenes/main_game_scene.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def player_choice_phase(self):
        while True:
            # Main choice menu
            choices = [
                Button(""Attack""),
                Button(""Swap"")
            ]
>           main_choice = self._wait_for_choice(self.player, choices)

main_game/scenes/main_game_scene.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Default Player, choices = [Button(Attack), Button(Swap)]

    def _wait_for_choice(self, player: AbstractPlayer, choices: List[AbstractChoice]) -> AbstractChoice:
        assert len(choices) > 0, ""`_wait_for_choice` was called with no choices""
        # hidden
        self._app._show_changes()
        # hidden
        if isinstance(self, AbstractMultiplayerScene):
            for p in self.players:
                if p != player:
                    p._listener.on_show_event(event_type=""OnGamePending"",
                                              event_data=OnGamePending(text=f""Waiting for {player}..."").model_dump()
                                              )
    
        # hidden
        if self._app.persistence_client:
            self._app.persistence_client.store(
                # TODO: optimize; there is no need to serialize the entire stack most of the time:
                deep_serialize(self._app._scene_stack), next_scene_name="""", checkpoint=""choice""
            )
        else:
            pass
        # print(f""{self.__class__.__name__}:_wait_for_choice({player.display_name}, {str(choices)})"")
>       choice = player._listener.on_wait_for_choice(self, choices)

../../../../mge2/mini_game_engine/engine/lib.py:444: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <mini_game_engine.engine.lib.HumanListener object at 0x[REDACTED]>
scene = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
choices = [Button(Attack), Button(Swap)]

    def on_wait_for_choice(self, scene: ""AbstractGameScene"", choices: List[AbstractChoice]) -> AbstractChoice:
        if HumanListener.random_mode or self.random_mode:
>           assert str(scene)

../../../../mge2/mini_game_engine/engine/lib.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

        def __str__(self):
            return f""""""=== Battle ===
    Your {self.player.active_creature.display_name}: {self.player.active_creature.hp}/{self.player.active_creature.max_hp} HP
    Opponent's {self.opponent.active_creature.display_name}: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp} HP
    
>   Phase: {'Player Choice' if self.current_phase == self.player_choice_phase else 'Foe Choice' if self.current_phase == self.foe_choice_phase else 'Resolution'}
    """"""
E   AttributeError: 'MainGameScene' object has no attribute 'current_phase'

main_game/scenes/main_game_scene.py:26: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
                main_game_scene.run()
            except RandomModeGracefulExit:
                print(f""Random mode completed successfully for run {i}"")
            except AbstractApp._QuitWholeGame:
                print(f""Game completed successfully for run {i}"")
            except Exception as e:
>               pytest.fail(f""Unexpected error in run {i}: {str(e)}"")
E               Failed: Unexpected error in run 0: 'MainGameScene' object has no attribute 'current_phase'

main_game/tests/test_main_game_scene.py:27: Failed
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:629: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:23: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:462: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:32: in run
    player_action = self.player_choice_phase()
main_game/scenes/main_game_scene.py:53: in player_choice_phase
    main_choice = self._wait_for_choice(self.player, choices)
../../../../mge2/mini_game_engine/engine/lib.py:444: in _wait_for_choice
    choice = player._listener.on_wait_for_choice(self, choices)
../../../../mge2/mini_game_engine/engine/lib.py:339: in on_wait_for_choice
    assert str(scene)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

        def __str__(self):
            return f""""""=== Battle ===
    Your {self.player.active_creature.display_name}: {self.player.active_creature.hp}/{self.player.active_creature.max_hp} HP
    Opponent's {self.opponent.active_creature.display_name}: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp} HP
    
>   Phase: {'Player Choice' if self.current_phase == self.player_choice_phase else 'Foe Choice' if self.current_phase == self.foe_choice_phase else 'Resolution'}
    """"""
E   AttributeError: 'MainGameScene' object has no attribute 'current_phase'

main_game/scenes/main_game_scene.py:26: AttributeError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run - Failed: Unexpected error in run 0: 'MainGameScene' object has no attribute 'current_phase'
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots - AttributeError: 'MainGameScene' object has no attribute 'current_phase'
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1
","Traceback (most recent call last):
  File ""/home/runner/_work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py"", line 72, in execute
    await self.sdk.execute_as_task(PytestRunnerAgent, verbose=False)
  File ""/home/runner/_work/volter-monorepo/volter-monorepo/volter-monorepo/packages/volter-common/common/sdk/SDK.py"", line 255, in execute_as_task
    response = await agent.execute()
               ^^^^^^^^^^^^^^^^^^^^^
  File ""/home/runner/_work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_agents/internal/game/pytest_runner_agent/logic.py"", line 30, in execute
    output = run_pytest(test_file_path, project_root=self.sdk.project_directory, verbose=self.verbose)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/runner/_work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-std-agents/agent_lib/random_run_utils.py"", line 141, in run_pytest
    raise AssertionError(f""Pytest failed with exit code {exit_code}. Output:\n{output}"")
AssertionError: Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform linux -- Python 3.11.9, pytest-7.3.1, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: sugar-0.9.7, cov-4.1.0, anyio-4.7.0, Faker-30.10.0, timeout-2.3.1, metadata-3.1.1, asyncio-0.23.8, html-3.2.0, time-machine-2.16.0
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
>               main_game_scene.run()

main_game/tests/test_main_game_scene.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        while True:
            # Player Choice Phase
>           player_action = self.player_choice_phase()

main_game/scenes/main_game_scene.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def player_choice_phase(self):
        while True:
            # Main choice menu
            choices = [
                Button(""Attack""),
                Button(""Swap"")
            ]
>           main_choice = self._wait_for_choice(self.player, choices)

main_game/scenes/main_game_scene.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Default Player, choices = [Button(Attack), Button(Swap)]

    def _wait_for_choice(self, player: AbstractPlayer, choices: List[AbstractChoice]) -> AbstractChoice:
        assert len(choices) > 0, ""`_wait_for_choice` was called with no choices""
        # hidden
        self._app._show_changes()
        # hidden
        if isinstance(self, AbstractMultiplayerScene):
            for p in self.players:
                if p != player:
                    p._listener.on_show_event(event_type=""OnGamePending"",
                                              event_data=OnGamePending(text=f""Waiting for {player}..."").model_dump()
                                              )
    
        # hidden
        if self._app.persistence_client:
            self._app.persistence_client.store(
                # TODO: optimize; there is no need to serialize the entire stack most of the time:
                deep_serialize(self._app._scene_stack), next_scene_name="""", checkpoint=""choice""
            )
        else:
            pass
        # print(f""{self.__class__.__name__}:_wait_for_choice({player.display_name}, {str(choices)})"")
>       choice = player._listener.on_wait_for_choice(self, choices)

../../../../mge2/mini_game_engine/engine/lib.py:444: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <mini_game_engine.engine.lib.HumanListener object at 0x[REDACTED]>
scene = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
choices = [Button(Attack), Button(Swap)]

    def on_wait_for_choice(self, scene: ""AbstractGameScene"", choices: List[AbstractChoice]) -> AbstractChoice:
        if HumanListener.random_mode or self.random_mode:
>           assert str(scene)

../../../../mge2/mini_game_engine/engine/lib.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

        def __str__(self):
            return f""""""=== Battle ===
    Your {self.player.active_creature.display_name}: {self.player.active_creature.hp}/{self.player.active_creature.max_hp} HP
    Opponent's {self.opponent.active_creature.display_name}: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp} HP
    
>   Phase: {'Player Choice' if self.current_phase == self.player_choice_phase else 'Foe Choice' if self.current_phase == self.foe_choice_phase else 'Resolution'}
    """"""
E   AttributeError: 'MainGameScene' object has no attribute 'current_phase'

main_game/scenes/main_game_scene.py:26: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
                main_game_scene.run()
            except RandomModeGracefulExit:
                print(f""Random mode completed successfully for run {i}"")
            except AbstractApp._QuitWholeGame:
                print(f""Game completed successfully for run {i}"")
            except Exception as e:
>               pytest.fail(f""Unexpected error in run {i}: {str(e)}"")
E               Failed: Unexpected error in run 0: 'MainGameScene' object has no attribute 'current_phase'

main_game/tests/test_main_game_scene.py:27: Failed
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:629: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:23: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:462: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:32: in run
    player_action = self.player_choice_phase()
main_game/scenes/main_game_scene.py:53: in player_choice_phase
    main_choice = self._wait_for_choice(self.player, choices)
../../../../mge2/mini_game_engine/engine/lib.py:444: in _wait_for_choice
    choice = player._listener.on_wait_for_choice(self, choices)
../../../../mge2/mini_game_engine/engine/lib.py:339: in on_wait_for_choice
    assert str(scene)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

        def __str__(self):
            return f""""""=== Battle ===
    Your {self.player.active_creature.display_name}: {self.player.active_creature.hp}/{self.player.active_creature.max_hp} HP
    Opponent's {self.opponent.active_creature.display_name}: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp} HP
    
>   Phase: {'Player Choice' if self.current_phase == self.player_choice_phase else 'Foe Choice' if self.current_phase == self.foe_choice_phase else 'Resolution'}
    """"""
E   AttributeError: 'MainGameScene' object has no attribute 'current_phase'

main_game/scenes/main_game_scene.py:26: AttributeError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run - Failed: Unexpected error in run 0: 'MainGameScene' object has no attribute 'current_phase'
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots - AttributeError: 'MainGameScene' object has no attribute 'current_phase'
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1


During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/home/runner/_work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_bench/bench_utils.py"", line 93, in execute_agent
    asyncio.run(agent.execute())
  File ""/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/asyncio/runners.py"", line 190, in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
  File ""/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/asyncio/runners.py"", line 118, in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/asyncio/base_events.py"", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File ""/home/runner/_work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py"", line 79, in execute
    raise FixableException(
common.exceptions.FixableException: After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform linux -- Python 3.11.9, pytest-7.3.1, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: sugar-0.9.7, cov-4.1.0, anyio-4.7.0, Faker-30.10.0, timeout-2.3.1, metadata-3.1.1, asyncio-0.23.8, html-3.2.0, time-machine-2.16.0
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
>               main_game_scene.run()

main_game/tests/test_main_game_scene.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        while True:
            # Player Choice Phase
>           player_action = self.player_choice_phase()

main_game/scenes/main_game_scene.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def player_choice_phase(self):
        while True:
            # Main choice menu
            choices = [
                Button(""Attack""),
                Button(""Swap"")
            ]
>           main_choice = self._wait_for_choice(self.player, choices)

main_game/scenes/main_game_scene.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Default Player, choices = [Button(Attack), Button(Swap)]

    def _wait_for_choice(self, player: AbstractPlayer, choices: List[AbstractChoice]) -> AbstractChoice:
        assert len(choices) > 0, ""`_wait_for_choice` was called with no choices""
        # hidden
        self._app._show_changes()
        # hidden
        if isinstance(self, AbstractMultiplayerScene):
            for p in self.players:
                if p != player:
                    p._listener.on_show_event(event_type=""OnGamePending"",
                                              event_data=OnGamePending(text=f""Waiting for {player}..."").model_dump()
                                              )
    
        # hidden
        if self._app.persistence_client:
            self._app.persistence_client.store(
                # TODO: optimize; there is no need to serialize the entire stack most of the time:
                deep_serialize(self._app._scene_stack), next_scene_name="""", checkpoint=""choice""
            )
        else:
            pass
        # print(f""{self.__class__.__name__}:_wait_for_choice({player.display_name}, {str(choices)})"")
>       choice = player._listener.on_wait_for_choice(self, choices)

../../../../mge2/mini_game_engine/engine/lib.py:444: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <mini_game_engine.engine.lib.HumanListener object at 0x[REDACTED]>
scene = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
choices = [Button(Attack), Button(Swap)]

    def on_wait_for_choice(self, scene: ""AbstractGameScene"", choices: List[AbstractChoice]) -> AbstractChoice:
        if HumanListener.random_mode or self.random_mode:
>           assert str(scene)

../../../../mge2/mini_game_engine/engine/lib.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

        def __str__(self):
            return f""""""=== Battle ===
    Your {self.player.active_creature.display_name}: {self.player.active_creature.hp}/{self.player.active_creature.max_hp} HP
    Opponent's {self.opponent.active_creature.display_name}: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp} HP
    
>   Phase: {'Player Choice' if self.current_phase == self.player_choice_phase else 'Foe Choice' if self.current_phase == self.foe_choice_phase else 'Resolution'}
    """"""
E   AttributeError: 'MainGameScene' object has no attribute 'current_phase'

main_game/scenes/main_game_scene.py:26: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
                main_game_scene.run()
            except RandomModeGracefulExit:
                print(f""Random mode completed successfully for run {i}"")
            except AbstractApp._QuitWholeGame:
                print(f""Game completed successfully for run {i}"")
            except Exception as e:
>               pytest.fail(f""Unexpected error in run {i}: {str(e)}"")
E               Failed: Unexpected error in run 0: 'MainGameScene' object has no attribute 'current_phase'

main_game/tests/test_main_game_scene.py:27: Failed
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:629: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:23: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:462: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:32: in run
    player_action = self.player_choice_phase()
main_game/scenes/main_game_scene.py:53: in player_choice_phase
    main_choice = self._wait_for_choice(self.player, choices)
../../../../mge2/mini_game_engine/engine/lib.py:444: in _wait_for_choice
    choice = player._listener.on_wait_for_choice(self, choices)
../../../../mge2/mini_game_engine/engine/lib.py:339: in on_wait_for_choice
    assert str(scene)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

        def __str__(self):
            return f""""""=== Battle ===
    Your {self.player.active_creature.display_name}: {self.player.active_creature.hp}/{self.player.active_creature.max_hp} HP
    Opponent's {self.opponent.active_creature.display_name}: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp} HP
    
>   Phase: {'Player Choice' if self.current_phase == self.player_choice_phase else 'Foe Choice' if self.current_phase == self.foe_choice_phase else 'Resolution'}
    """"""
E   AttributeError: 'MainGameScene' object has no attribute 'current_phase'

main_game/scenes/main_game_scene.py:26: AttributeError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run - Failed: Unexpected error in run 0: 'MainGameScene' object has no attribute 'current_phase'
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots - AttributeError: 'MainGameScene' object has no attribute 'current_phase'
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1

",['new_prompt_logs/999994_664394_OneShotCoreAgent'],ladder/creature_battler_05_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-12-15 14:24:49,bbabb6a2-363f-4ff5-bf72-e1ebe33b3a2c,OneShotCoreAgent,creature_battler_05,5,success,,,['new_prompt_logs/999996_309788_OneShotCoreAgent'],ladder/creature_battler_05_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/3033ba0e0a202d32f5647c3631ce6a33f46a11ea/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
