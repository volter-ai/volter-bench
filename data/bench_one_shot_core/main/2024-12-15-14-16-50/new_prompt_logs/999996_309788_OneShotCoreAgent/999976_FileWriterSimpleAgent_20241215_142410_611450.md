Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis and Fix Plan:

The issue has two parts to fix in MainGameScene:

a) Missing "Back" option:
- Add a "Back" button to both the Attack and Swap choice menus
- When Back is selected, return to the main choice menu (Attack/Swap)
- Implement this using nested loops in _handle_turn()

b) Speed tie resolution:
- When creatures have equal speed, randomize the order
- Modify _resolve_actions() to use random.choice when speeds are equal
- Keep the existing speed sorting but add randomization for ties

The fix requires no model changes since it's purely scene logic. We'll modify MainGameScene.py to:
1. Add Back buttons using the Button class
2. Add logic to handle Back button selections
3. Add randomization for speed ties
4. Keep all other battle mechanics the same

Here's the complete fixed file:

# Excerpt ID: 73a20067-1c53-475d-817e-54b240e39591
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Creature
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        
        # Reset creatures
        for creature in self.player.creatures:
            creature.hp = creature.max_hp
        for creature in self.bot.creatures:
            creature.hp = creature.max_hp
            
        # Set initial active creatures
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]

    def __str__(self):
        player_creature = self.player.active_creature
        bot_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {player_creature.display_name}: {player_creature.hp}/{player_creature.max_hp} HP
Foe's {bot_creature.display_name}: {bot_creature.hp}/{bot_creature.max_hp} HP

Your Team:
{self._format_team(self.player)}

Foe's Team:
{self._format_team(self.bot)}

> Attack
> Swap
"""

    def _format_team(self, player):
        return "\n".join([f"- {c.display_name}: {c.hp}/{c.max_hp} HP" for c in player.creatures])

    def run(self):
        while True:
            # Player turn
            player_action = self._handle_turn(self.player)
            if not player_action:
                self._quit_whole_game()
                return
                
            # Bot turn
            bot_action = self._handle_turn(self.bot)
            if not bot_action:
                self._quit_whole_game()
                return
                
            # Resolve actions
            self._resolve_actions(player_action, bot_action)
            
            # Check for battle end
            if self._check_battle_end():
                self._quit_whole_game()
                return

    def _handle_turn(self, player):
        if player.active_creature.hp <= 0:
            available_creatures = [c for c in player.creatures if c.hp > 0]
            if not available_creatures:
                self._show_text(player, f"{player.display_name} has no creatures left!")
                return None
                
            choices = [SelectThing(c) for c in available_creatures]
            choice = self._wait_for_choice(player, choices)
            player.active_creature = choice.thing
            return {"type": "swap", "creature": choice.thing}
            
        while True:  # Main choice loop
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choice = self._wait_for_choice(player, [attack_button, swap_button])
            
            if choice == attack_button:
                # Attack submenu
                skill_choices = [SelectThing(s) for s in player.active_creature.skills]
                back_button = Button("Back")
                skill_choices.append(back_button)
                
                skill_choice = self._wait_for_choice(player, skill_choices)
                if skill_choice == back_button:
                    continue  # Go back to main menu
                    
                return {"type": "attack", "skill": skill_choice.thing}
                
            else:  # Swap chosen
                available_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
                if not available_creatures:
                    continue  # No valid swaps, return to main menu
                    
                creature_choices = [SelectThing(c) for c in available_creatures]
                back_button = Button("Back")
                creature_choices.append(back_button)
                
                creature_choice = self._wait_for_choice(player, creature_choices)
                if creature_choice == back_button:
                    continue  # Go back to main menu
                    
                player.active_creature = creature_choice.thing
                return {"type": "swap", "creature": creature_choice.thing}

    def _resolve_actions(self, player_action, bot_action):
        # Handle swaps first
        if player_action["type"] == "swap":
            self._show_text(self.player, f"You switched to {player_action['creature'].display_name}!")
        if bot_action["type"] == "swap":
            self._show_text(self.player, f"Foe switched to {bot_action['creature'].display_name}!")
            
        # Then handle attacks
        actions = []
        if player_action["type"] == "attack":
            actions.append((self.player, player_action["skill"], self.bot))
        if bot_action["type"] == "attack":
            actions.append((self.bot, bot_action["skill"], self.player))
            
        # Sort by speed with randomization for ties
        def get_speed_key(action):
            return action[0].active_creature.speed
            
        if len(actions) == 2:
            speed1 = get_speed_key(actions[0])
            speed2 = get_speed_key(actions[1])
            if speed1 == speed2:
                # Randomize order for equal speeds
                random.shuffle(actions)
            else:
                # Sort by speed if different
                actions.sort(key=get_speed_key, reverse=True)
        
        for attacker, skill, defender in actions:
            damage = self._calculate_damage(attacker.active_creature, skill, defender.active_creature)
            defender.active_creature.hp -= damage
            self._show_text(self.player, 
                f"{attacker.active_creature.display_name} used {skill.display_name}! "
                f"Dealt {damage} damage to {defender.active_creature.display_name}!")

    def _calculate_damage(self, attacker, skill, defender):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Apply type effectiveness
        effectiveness = self._get_type_effectiveness(skill.skill_type, defender.creature_type)
        
        return int(raw_damage * effectiveness)

    def _get_type_effectiveness(self, skill_type, defender_type):
        if skill_type == "normal":
            return 1.0
            
        effectiveness_chart = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness_chart.get(skill_type, {}).get(defender_type, 1.0)

    def _check_battle_end(self):
        player_has_creatures = any(c.hp > 0 for c in self.player.creatures)
        bot_has_creatures = any(c.hp > 0 for c in self.bot.creatures)
        
        if not player_has_creatures:
            self._show_text(self.player, "You lost the battle!")
            return True
        elif not bot_has_creatures:
            self._show_text(self.player, "You won the battle!")
            return True
            
        return False
```

Key changes:
1. Added "Back" button and handling in both Attack and Swap menus
2. Implemented nested menu system with main loop
3. Added randomization for speed ties in _resolve_actions
4. Maintained all existing battle mechanics

The implementation now fully matches the architecture documentation while staying within the engine's capabilities.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
