Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
I understand the issues raised during QA/testing. I'll address each of the problems and rewrite the MainGameScene to fix these discrepancies. Here's how I plan to fix the issues:

1. Add a 'Back' option in the Player Choice Phase.
2. Implement explicit float calculations for damage.
3. Reset the player's creatures' state when leaving the scene.
4. Ensure all logic described in the architecture is properly implemented.

I'll rewrite the main_game_scene.py file to address these issues:

# Excerpt ID: 678fad6b-9a82-4e6b-9476-f38f584a853a
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing, DictionaryChoice
from main_game.models import Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.turn_queue = []

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        return f"""===Battle===
{self.player.display_name}'s {player_creature.display_name}: HP {player_creature.hp}/{player_creature.max_hp}
{self.opponent.display_name}'s {opponent_creature.display_name}: HP {opponent_creature.hp}/{opponent_creature.max_hp}

> Attack
> Swap
"""

    def run(self):
        self._show_text(self.player, "Battle Start!")
        self._show_text(self.opponent, "Battle Start!")

        while True:
            self.player_turn()
            self.opponent_turn()
            self.resolve_turn()

            if self.check_battle_end():
                break

        self.reset_creatures_state()
        self._transition_to_scene("MainMenuScene")

    def player_turn(self):
        while True:
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choices = [attack_button, swap_button]
            choice = self._wait_for_choice(self.player, choices)

            if choice == attack_button:
                skill_choice = self.choose_skill()
                if skill_choice:
                    self.turn_queue.append(("attack", self.player, skill_choice))
                    break
            elif choice == swap_button:
                creature_choice = self.choose_creature()
                if creature_choice:
                    self.turn_queue.append(("swap", self.player, creature_choice))
                    break

    def choose_skill(self):
        while True:
            skill_choices = [SelectThing(skill) for skill in self.player.active_creature.skills]
            back_button = Button("Back")
            choices = skill_choices + [back_button]
            choice = self._wait_for_choice(self.player, choices)

            if choice == back_button:
                return None
            else:
                return choice.thing

    def choose_creature(self):
        creature_choices = [SelectThing(creature) for creature in self.player.creatures if creature.hp > 0 and creature != self.player.active_creature]
        if not creature_choices:
            self._show_text(self.player, "No other creatures available to swap!")
            return None

        back_button = Button("Back")
        choices = creature_choices + [back_button]
        choice = self._wait_for_choice(self.player, choices)

        if choice == back_button:
            return None
        else:
            return choice.thing

    def opponent_turn(self):
        choices = ["attack", "swap"]
        choice = random.choice(choices)

        if choice == "attack":
            skill = random.choice(self.opponent.active_creature.skills)
            self.turn_queue.append(("attack", self.opponent, skill))
        elif choice == "swap":
            available_creatures = [c for c in self.opponent.creatures if c.hp > 0 and c != self.opponent.active_creature]
            if available_creatures:
                creature = random.choice(available_creatures)
                self.turn_queue.append(("swap", self.opponent, creature))
            else:
                skill = random.choice(self.opponent.active_creature.skills)
                self.turn_queue.append(("attack", self.opponent, skill))

    def resolve_turn(self):
        self.turn_queue.sort(key=lambda x: (-1 if x[0] == "swap" else x[1].active_creature.speed), reverse=True)

        for action, player, target in self.turn_queue:
            if action == "swap":
                player.active_creature = target
                self._show_text(self.player, f"{player.display_name} swapped to {target.display_name}!")
                self._show_text(self.opponent, f"{player.display_name} swapped to {target.display_name}!")
            elif action == "attack":
                attacker = player.active_creature
                defender = self.opponent.active_creature if player == self.player else self.player.active_creature
                damage = self.calculate_damage(attacker, defender, target)
                defender.hp = max(0, defender.hp - damage)
                self._show_text(self.player, f"{attacker.display_name} used {target.display_name} and dealt {damage} damage to {defender.display_name}!")
                self._show_text(self.opponent, f"{attacker.display_name} used {target.display_name} and dealt {damage} damage to {defender.display_name}!")

                if defender.hp == 0:
                    self._show_text(self.player, f"{defender.display_name} fainted!")
                    self._show_text(self.opponent, f"{defender.display_name} fainted!")
                    self.force_swap(self.player if defender == self.player.active_creature else self.opponent)

        self.turn_queue.clear()

    def calculate_damage(self, attacker: Creature, defender: Creature, skill: Skill) -> int:
        if skill.is_physical:
            raw_damage = float(attacker.attack + skill.base_damage - defender.defense)
        else:
            raw_damage = float(attacker.sp_attack) / float(defender.sp_defense) * float(skill.base_damage)

        type_effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_effectiveness)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def get_type_effectiveness(self, skill_type: str, defender_type: str) -> float:
        effectiveness = {
            ("fire", "leaf"): 2.0,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2.0,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2.0,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1.0)

    def force_swap(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
        if available_creatures:
            creature_choices = [SelectThing(creature) for creature in available_creatures]
            choice = self._wait_for_choice(player, creature_choices)
            player.active_creature = choice.thing
            self._show_text(self.player, f"{player.display_name} swapped to {choice.thing.display_name}!")
            self._show_text(self.opponent, f"{player.display_name} swapped to {choice.thing.display_name}!")

    def check_battle_end(self) -> bool:
        player_creatures_alive = any(c.hp > 0 for c in self.player.creatures)
        opponent_creatures_alive = any(c.hp > 0 for c in self.opponent.creatures)

        if not player_creatures_alive:
            self._show_text(self.player, "You lost the battle!")
            self._show_text(self.opponent, "You won the battle!")
            return True
        elif not opponent_creatures_alive:
            self._show_text(self.player, "You won the battle!")
            self._show_text(self.opponent, "You lost the battle!")
            return True
        return False

    def reset_creatures_state(self):
        for creature in self.player.creatures + self.opponent.creatures:
            creature.hp = creature.max_hp
```

These changes address the issues raised:

1. Added a 'Back' option in both the skill selection and creature swap phases.
2. Implemented explicit float calculations for damage in the `calculate_damage` method.
3. Added a `reset_creatures_state` method that is called before transitioning back to the MainMenuScene.
4. Ensured that the logic described in the architecture is properly implemented, including the correct order of operations in the turn resolution.

These changes should resolve the discrepancies between the implementation and the described architecture while staying within the capabilities of the engine.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "678fad6b-9a82-4e6b-9476-f38f584a853a", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
