timestamp,run_id,agent_id,ladder,run,status,error,traceback,logs,project_directory,commit_url,branch_name,project_type,override_model,strong_completion_model,base_chat_completion_model,fast_chat_completion_model,strong_coding_completion_model
2024-11-10 14:16:42,c470612e-f349-4fe2-8d08-e271243e6666,OneShotCoreAgent,creature_battler_01,2,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_01_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:16:52,3d3c3c1d-4bfa-440d-b726-387397d0abf6,OneShotCoreAgent,creature_battler_01,1,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_01_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:18:25,e0e7046f-0567-4c74-aee4-9329e073f34c,OneShotCoreAgent,creature_battler_01,4,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_01_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:18:51,d0614e03-3adc-4447-aeb8-d502b9c60f4c,OneShotCoreAgent,creature_battler_01,3,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_01_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:19:58,15712195-50c4-44c7-8469-b92e716ea0ed,OneShotCoreAgent,creature_battler_01,5,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_01_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:20:23,164bb9f2-1971-4d74-9186-cb1481a2a669,OneShotCoreAgent,creature_battler_01,6,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_01_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:21:21,3cd275e5-9763-4250-a03f-2dc7568b1a6b,OneShotCoreAgent,creature_battler_01,7,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_01_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:22:27,9fe76454-aba7-4209-ac1b-5b1f483d8a24,OneShotCoreAgent,creature_battler_02,1,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_02_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:23:02,df0aaaa4-c8f7-4a2c-98d2-d300472da8fc,OneShotCoreAgent,creature_battler_02,2,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_02_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:25:08,6534fd00-51bf-4c17-b400-c651d6059642,OneShotCoreAgent,creature_battler_02,3,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_02_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:25:09,69545115-ad79-44a4-b770-23453e96a739,OneShotCoreAgent,creature_battler_02,4,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_02_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:26:45,63b24a62-c56b-445e-aaa2-f72acce1d5d1,OneShotCoreAgent,creature_battler_02,5,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_02_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:26:55,d0061ff7-8057-4e4f-84a5-78722103787e,OneShotCoreAgent,creature_battler_02,6,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_02_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:28:21,32b4fc35-e306-43bb-8bd1-ca3878ef2ed9,OneShotCoreAgent,creature_battler_02,7,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_02_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:29:06,46eb31a0-3fce-4a89-ab6e-70bdac307025,OneShotCoreAgent,creature_battler_03,1,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_03_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:31:04,47a219bb-d5ee-4d45-b421-c3bb7e00a90b,OneShotCoreAgent,creature_battler_03,3,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_03_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:32:13,61e15089-242b-402d-b399-3cd075144121,OneShotCoreAgent,creature_battler_03,2,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_03_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:33:11,17fa2161-4a37-48e1-9724-d6ecde8ec31c,OneShotCoreAgent,creature_battler_03,4,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_03_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:34:36,143bc8be-6cbd-4761-b99b-39659541f16e,OneShotCoreAgent,creature_battler_03,5,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_03_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:35:07,2870e106-ad5c-4b3e-ad30-149f340f8c23,OneShotCoreAgent,creature_battler_03,6,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_03_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:37:00,4544876b-6503-4827-b5c2-f72040ee0e57,OneShotCoreAgent,creature_battler_04,1,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_04_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:37:14,31ffd0b9-4ea8-44e7-9e32-1d9af8385c25,OneShotCoreAgent,creature_battler_03,7,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_03_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:38:34,8b85817f-23f9-480e-bc2f-1cb315c81d28,OneShotCoreAgent,creature_battler_04,2,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_04_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:40:19,43d0cddb-4a2d-4236-925c-adb44da0d678,OneShotCoreAgent,creature_battler_04,4,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_04_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:40:30,e34439b6-7d4a-453b-9970-6d3adbdac578,OneShotCoreAgent,creature_battler_04,3,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_04_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:42:04,36c4c83d-99be-41e1-87bb-372d1c37eb92,OneShotCoreAgent,creature_battler_04,5,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_04_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:42:15,b01a194f-dbff-40fc-af7a-36f79133475d,OneShotCoreAgent,creature_battler_04,6,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_04_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:43:55,f5dcd8b3-8731-4b64-ae70-673aca0ee4ae,OneShotCoreAgent,creature_battler_04,7,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_04_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:46:18,79935e9b-6c32-43cb-910a-06c6c11d17f6,OneShotCoreAgent,creature_battler_05,1,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_05_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:46:28,b1f1ec21-06f9-4170-9136-e7f6f9faa7a8,OneShotCoreAgent,creature_battler_05,2,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_05_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:49:18,9aefdd28-8bc6-4cb6-ade9-c572d020e221,OneShotCoreAgent,creature_battler_05,4,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_05_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:50:41,2fd2a8e3-223d-400d-85e1-e8495043e80f,OneShotCoreAgent,creature_battler_05,3,failure,"After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-7.3.1, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: metadata-3.1.1, anyio-4.6.2.post1, Faker-30.8.2, timeout-2.3.1, time-machine-2.16.0, html-3.2.0, asyncio-0.23.8, sugar-0.9.7, cov-4.1.0
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # More moves needed for complex battle scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
>               main_game_scene.run()

main_game/tests/test_main_game_scene.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        while True:
            # Keep asking for choice until a valid action is selected (not Back)
            while True:
                player_choice = self.get_player_choice(self.player)
                if player_choice is not None:
                    player_action = self.create_action(player_choice, self.player)
                    break
    
>           bot_action = self.create_action(self.get_player_choice(self.bot), self.bot)

main_game/scenes/main_game_scene.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
choice = None, player = Basic Opponent

    def create_action(self, choice: SelectThing, player: Player) -> Action:
        return Action(
            display_name=f""{player.display_name}'s action"",
            description=""A battle action"",
            prototype_id=f""action_{player.uid}"",
            acting_player=player,
>           target_thing=choice.thing
        )
E       AttributeError: 'NoneType' object has no attribute 'thing'

main_game/scenes/main_game_scene.py:76: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # More moves needed for complex battle scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
                main_game_scene.run()
            except RandomModeGracefulExit:
                print(f""`random_mode_counter` reached 0 and the game did not crash. Ending run {i} gracefully"")
            except AbstractApp._QuitWholeGame:
                print(f""Game quit gracefully during run {i}"")
            except Exception as e:
>               pytest.fail(f""Unexpected exception during run {i}: {e}"")
E               Failed: Unexpected exception during run 0: 'NoneType' object has no attribute 'thing'

main_game/tests/test_main_game_scene.py:33: Failed
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:629: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:23: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:462: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:38: in run
    bot_action = self.create_action(self.get_player_choice(self.bot), self.bot)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
choice = None, player = Basic Opponent

    def create_action(self, choice: SelectThing, player: Player) -> Action:
        return Action(
            display_name=f""{player.display_name}'s action"",
            description=""A battle action"",
            prototype_id=f""action_{player.uid}"",
            acting_player=player,
>           target_thing=choice.thing
        )
E       AttributeError: 'NoneType' object has no attribute 'thing'

main_game/scenes/main_game_scene.py:76: AttributeError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run - Failed: Unexpected exception during run 0: 'NoneType' object has no attribute 'thing'
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots - AttributeError: 'NoneType' object has no attribute 'thing'
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1
","Traceback (most recent call last):
  File ""/home/runner/work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py"", line 72, in execute
    await self.sdk.execute_as_task(PytestRunnerAgent, verbose=False)
  File ""/home/runner/work/volter-monorepo/volter-monorepo/volter-monorepo/packages/volter-common/common/sdk/SDK.py"", line 274, in execute_as_task
    response = await agent.execute()
               ^^^^^^^^^^^^^^^^^^^^^
  File ""/home/runner/work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_agents/internal/game/pytest_runner_agent/logic.py"", line 30, in execute
    output = run_pytest(test_file_path, project_root=self.sdk.project_directory, verbose=self.verbose)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/runner/work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-std-agents/agent_lib/random_run_utils.py"", line 141, in run_pytest
    raise AssertionError(f""Pytest failed with exit code {exit_code}. Output:\n{output}"")
AssertionError: Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-7.3.1, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: metadata-3.1.1, anyio-4.6.2.post1, Faker-30.8.2, timeout-2.3.1, time-machine-2.16.0, html-3.2.0, asyncio-0.23.8, sugar-0.9.7, cov-4.1.0
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # More moves needed for complex battle scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
>               main_game_scene.run()

main_game/tests/test_main_game_scene.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        while True:
            # Keep asking for choice until a valid action is selected (not Back)
            while True:
                player_choice = self.get_player_choice(self.player)
                if player_choice is not None:
                    player_action = self.create_action(player_choice, self.player)
                    break
    
>           bot_action = self.create_action(self.get_player_choice(self.bot), self.bot)

main_game/scenes/main_game_scene.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
choice = None, player = Basic Opponent

    def create_action(self, choice: SelectThing, player: Player) -> Action:
        return Action(
            display_name=f""{player.display_name}'s action"",
            description=""A battle action"",
            prototype_id=f""action_{player.uid}"",
            acting_player=player,
>           target_thing=choice.thing
        )
E       AttributeError: 'NoneType' object has no attribute 'thing'

main_game/scenes/main_game_scene.py:76: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # More moves needed for complex battle scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
                main_game_scene.run()
            except RandomModeGracefulExit:
                print(f""`random_mode_counter` reached 0 and the game did not crash. Ending run {i} gracefully"")
            except AbstractApp._QuitWholeGame:
                print(f""Game quit gracefully during run {i}"")
            except Exception as e:
>               pytest.fail(f""Unexpected exception during run {i}: {e}"")
E               Failed: Unexpected exception during run 0: 'NoneType' object has no attribute 'thing'

main_game/tests/test_main_game_scene.py:33: Failed
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:629: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:23: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:462: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:38: in run
    bot_action = self.create_action(self.get_player_choice(self.bot), self.bot)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
choice = None, player = Basic Opponent

    def create_action(self, choice: SelectThing, player: Player) -> Action:
        return Action(
            display_name=f""{player.display_name}'s action"",
            description=""A battle action"",
            prototype_id=f""action_{player.uid}"",
            acting_player=player,
>           target_thing=choice.thing
        )
E       AttributeError: 'NoneType' object has no attribute 'thing'

main_game/scenes/main_game_scene.py:76: AttributeError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run - Failed: Unexpected exception during run 0: 'NoneType' object has no attribute 'thing'
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots - AttributeError: 'NoneType' object has no attribute 'thing'
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1


During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/home/runner/work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_bench/bench_utils.py"", line 93, in execute_agent
    asyncio.run(agent.execute())
  File ""/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/asyncio/runners.py"", line 190, in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
  File ""/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/asyncio/runners.py"", line 118, in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/asyncio/base_events.py"", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File ""/home/runner/work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py"", line 79, in execute
    raise FixableException(
common.exceptions.FixableException: After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-7.3.1, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: metadata-3.1.1, anyio-4.6.2.post1, Faker-30.8.2, timeout-2.3.1, time-machine-2.16.0, html-3.2.0, asyncio-0.23.8, sugar-0.9.7, cov-4.1.0
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # More moves needed for complex battle scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
>               main_game_scene.run()

main_game/tests/test_main_game_scene.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        while True:
            # Keep asking for choice until a valid action is selected (not Back)
            while True:
                player_choice = self.get_player_choice(self.player)
                if player_choice is not None:
                    player_action = self.create_action(player_choice, self.player)
                    break
    
>           bot_action = self.create_action(self.get_player_choice(self.bot), self.bot)

main_game/scenes/main_game_scene.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
choice = None, player = Basic Opponent

    def create_action(self, choice: SelectThing, player: Player) -> Action:
        return Action(
            display_name=f""{player.display_name}'s action"",
            description=""A battle action"",
            prototype_id=f""action_{player.uid}"",
            acting_player=player,
>           target_thing=choice.thing
        )
E       AttributeError: 'NoneType' object has no attribute 'thing'

main_game/scenes/main_game_scene.py:76: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # More moves needed for complex battle scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            try:
                main_game_scene.run()
            except RandomModeGracefulExit:
                print(f""`random_mode_counter` reached 0 and the game did not crash. Ending run {i} gracefully"")
            except AbstractApp._QuitWholeGame:
                print(f""Game quit gracefully during run {i}"")
            except Exception as e:
>               pytest.fail(f""Unexpected exception during run {i}: {e}"")
E               Failed: Unexpected exception during run 0: 'NoneType' object has no attribute 'thing'

main_game/tests/test_main_game_scene.py:33: Failed
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:629: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:23: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:462: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:38: in run
    bot_action = self.create_action(self.get_player_choice(self.bot), self.bot)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
choice = None, player = Basic Opponent

    def create_action(self, choice: SelectThing, player: Player) -> Action:
        return Action(
            display_name=f""{player.display_name}'s action"",
            description=""A battle action"",
            prototype_id=f""action_{player.uid}"",
            acting_player=player,
>           target_thing=choice.thing
        )
E       AttributeError: 'NoneType' object has no attribute 'thing'

main_game/scenes/main_game_scene.py:76: AttributeError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run - Failed: Unexpected exception during run 0: 'NoneType' object has no attribute 'thing'
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots - AttributeError: 'NoneType' object has no attribute 'thing'
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1

",['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_05_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:52:33,eb4b3070-6986-4dff-ae41-a43f466e7d0f,OneShotCoreAgent,creature_battler_05,5,success,,,['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_05_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:55:36,e922d682-7c74-409d-8028-0b9ddeacc58e,OneShotCoreAgent,creature_battler_05,7,failure,"After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-7.3.1, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: metadata-3.1.1, anyio-4.6.2.post1, Faker-30.8.2, timeout-2.3.1, time-machine-2.16.0, html-3.2.0, asyncio-0.23.8, sugar-0.9.7, cov-4.1.0
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
>               player_action = self.get_player_action(self.player)

main_game/scenes/main_game_scene.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Default Player

    def get_player_action(self, player: Player):
        available_choices = []
    
        # Check if Attack is valid
        if player.active_creature and player.active_creature.skills:
            available_choices.append(Button(""Attack""))
    
        # Check if Swap is valid
        valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
        if valid_creatures:
            available_choices.append(Button(""Swap""))
    
        # If no choices available, return None to indicate no valid moves
        if not available_choices:
            return None
    
>       choice = self._wait_for_choice(player, available_choices)

main_game/scenes/main_game_scene.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Default Player, choices = [Button(Attack)]

    def _wait_for_choice(self, player: AbstractPlayer, choices: List[AbstractChoice]) -> AbstractChoice:
        assert len(choices) > 0, ""`_wait_for_choice` was called with no choices""
        # hidden
        self._app._show_changes()
        # hidden
        if isinstance(self, AbstractMultiplayerScene):
            for p in self.players:
                if p != player:
                    p._listener.on_show_event(event_type=""OnGamePending"",
                                              event_data=OnGamePending(text=f""Waiting for {player}..."").model_dump()
                                              )
    
        # hidden
        if self._app.persistence_client:
            self._app.persistence_client.store(
                # TODO: optimize; there is no need to serialize the entire stack most of the time:
                deep_serialize(self._app._scene_stack), next_scene_name="""", checkpoint=""choice""
            )
        else:
            pass
        # print(f""{self.__class__.__name__}:_wait_for_choice({player.display_name}, {str(choices)})"")
>       choice = player._listener.on_wait_for_choice(self, choices)

../../../../mge2/mini_game_engine/engine/lib.py:444: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <mini_game_engine.engine.lib.HumanListener object at 0x[REDACTED]>
scene = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
choices = [Button(Attack)]

    def on_wait_for_choice(self, scene: ""AbstractGameScene"", choices: List[AbstractChoice]) -> AbstractChoice:
        if HumanListener.random_mode or self.random_mode:
            assert str(scene)
            self.random_mode_counter -= 1
            if self.random_mode_counter <= 0:
>               raise RandomModeGracefulExit()
E               mini_game_engine.engine.lib.RandomModeGracefulExit: HumanListener is in random mode and the current run is now over. This is exception is expected

../../../../mge2/mini_game_engine/engine/lib.py:342: RandomModeGracefulExit

During handling of the above exception, another exception occurred:

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # More moves needed for battle scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            # Patch the transition method to prevent actual scene transition
            with patch.object(MainGameScene, '_transition_to_scene') as mock_transition:
                try:
>                   main_game_scene.run()

main_game/tests/test_main_game_scene.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
                    self._transition_to_scene(""MainMenuScene"")
                    return
>       except RandomModeGracefulExit:
E       NameError: name 'RandomModeGracefulExit' is not defined

main_game/scenes/main_game_scene.py:56: NameError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
You lost!
starting random run iteration 1
You lost!
starting random run iteration 2
_____________________ test_full_game_flow_random_with_bots _____________________

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
>                   self._transition_to_scene(""MainMenuScene"")

main_game/scenes/main_game_scene.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
scene_name = 'MainMenuScene'

    def _transition_to_scene(self, scene_name: str):
>       self._app.transition_to_scene(scene_name, player=self.player)

../../../../mge2/mini_game_engine/engine/lib.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>, scene_id = 'MainMenuScene'
transition_to_scene = None, kwargs = {'player': Default Player}
settings = Settings(env='LOCAL', redis_host='localhost', redis_port=6379, redis_secure_auth='', enable_persistence=False, enable_... enable_leaderboard_persistence=False, supabase_url='', supabase_key='', supabase_jwt_secret='', game_id='volter-game')

    def transition_to_scene(self, scene_id: str, transition_to_scene: Optional[AbstractGameScene] = None, **kwargs):
        try:
            settings = get_settings()
            if settings.enable_persistence:
                saved_data = self.persistence_client.retrieve(kwargs.get('player'))
                if saved_data:
                    print(""---> Fetching data"", saved_data)
                    dehydrated_scene_stack, next_scene_name = saved_data
                    if next_scene_name:
                        new_scene_stack = []
                        for dehydrated_scene in dehydrated_scene_stack:
                            scene_kwargs = {**dehydrated_scene}
                            del scene_kwargs[""__type""]
                            new_scene = self.scene_registry.get(dehydrated_scene[""__type""]).model_validate({
                                **scene_kwargs,
                                **kwargs
                            })
                            new_scene_stack.append(new_scene)
                        self._scene_stack = new_scene_stack
                        for _scene in self._scene_stack:
                            _scene.player = kwargs.get('player')
                        scene_id = next_scene_name
    
            scene_factory = self.scene_registry[scene_id]
        except KeyError as e:
            raise Exception(f""The scene {scene_id} is not registered, ""
                            f""all scenes should be registered using `register_scene` before `app.run()`"") from e
    
        if issubclass(scene_factory, AbstractMultiplayerScene):
            if kwargs.get(""player"") is not None:
                raise Exception(""player argument cannot be used on a multiplayer scene, you must use 'players'"")
            if kwargs.get(""players"") is None:
                raise Exception(""players argument must be set on a multiplayer scene"")
        scene = transition_to_scene
    
        if not scene:
            scene: AbstractGameScene = scene_factory(app=self, **kwargs)
    
>       self.__run_scene(scene)

../../../../mge2/mini_game_engine/engine/lib.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>
scene = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def __run_scene(self, scene: AbstractGameScene):
        # hidden
        settings = get_settings()
        # hidden
        if settings.enable_persistence:
            if self._scene_stack:
                self._persist_scene_stack(scene.__class__.__name__)
        # hidden
        AbstractApp._thread_to_app[threading.current_thread().ident] = self
        # hidden
        self._scene_stack.append(scene)
        if len(self._scene_stack) == 1:
            AbstractApp.broadcast_event(OnGameStart())
    
        self._show_changes()
    
>       scene.run()

../../../../mge2/mini_game_engine/engine/lib.py:789: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def run(self):
        play_button = Button(""Play"")
        quit_button = Button(""Quit"")
    
        choice = self._wait_for_choice(self.player, [play_button, quit_button])
    
        if choice == play_button:
            self._transition_to_scene(""MainGameScene"")
        else:
>           self._quit_whole_game()

main_game/scenes/main_menu_scene.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def _quit_whole_game(self):
        # hidden
        if os.environ.get('SIMULATION_SCENE_TARGET'):
            return
>       self._app.quit_whole_game()

../../../../mge2/mini_game_engine/engine/lib.py:459: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>

    def quit_whole_game(self):
        self.terminated = True
>       raise AbstractApp._QuitWholeGame()
E       mini_game_engine.engine.lib.AbstractApp._QuitWholeGame: Game terminated gracefully. If you intended to quit the game, this exception is expected and should be caught

../../../../mge2/mini_game_engine/engine/lib.py:625: _QuitWholeGame

During handling of the above exception, another exception occurred:

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
>                   self._transition_to_scene(""MainMenuScene"")

main_game/scenes/main_game_scene.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
scene_name = 'MainMenuScene'

    def _transition_to_scene(self, scene_name: str):
>       self._app.transition_to_scene(scene_name, player=self.player)

../../../../mge2/mini_game_engine/engine/lib.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>, scene_id = 'MainMenuScene'
transition_to_scene = None, kwargs = {'player': Default Player}
settings = Settings(env='LOCAL', redis_host='localhost', redis_port=6379, redis_secure_auth='', enable_persistence=False, enable_... enable_leaderboard_persistence=False, supabase_url='', supabase_key='', supabase_jwt_secret='', game_id='volter-game')

    def transition_to_scene(self, scene_id: str, transition_to_scene: Optional[AbstractGameScene] = None, **kwargs):
        try:
            settings = get_settings()
            if settings.enable_persistence:
                saved_data = self.persistence_client.retrieve(kwargs.get('player'))
                if saved_data:
                    print(""---> Fetching data"", saved_data)
                    dehydrated_scene_stack, next_scene_name = saved_data
                    if next_scene_name:
                        new_scene_stack = []
                        for dehydrated_scene in dehydrated_scene_stack:
                            scene_kwargs = {**dehydrated_scene}
                            del scene_kwargs[""__type""]
                            new_scene = self.scene_registry.get(dehydrated_scene[""__type""]).model_validate({
                                **scene_kwargs,
                                **kwargs
                            })
                            new_scene_stack.append(new_scene)
                        self._scene_stack = new_scene_stack
                        for _scene in self._scene_stack:
                            _scene.player = kwargs.get('player')
                        scene_id = next_scene_name
    
            scene_factory = self.scene_registry[scene_id]
        except KeyError as e:
            raise Exception(f""The scene {scene_id} is not registered, ""
                            f""all scenes should be registered using `register_scene` before `app.run()`"") from e
    
        if issubclass(scene_factory, AbstractMultiplayerScene):
            if kwargs.get(""player"") is not None:
                raise Exception(""player argument cannot be used on a multiplayer scene, you must use 'players'"")
            if kwargs.get(""players"") is None:
                raise Exception(""players argument must be set on a multiplayer scene"")
        scene = transition_to_scene
    
        if not scene:
            scene: AbstractGameScene = scene_factory(app=self, **kwargs)
    
>       self.__run_scene(scene)

../../../../mge2/mini_game_engine/engine/lib.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>
scene = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def __run_scene(self, scene: AbstractGameScene):
        # hidden
        settings = get_settings()
        # hidden
        if settings.enable_persistence:
            if self._scene_stack:
                self._persist_scene_stack(scene.__class__.__name__)
        # hidden
        AbstractApp._thread_to_app[threading.current_thread().ident] = self
        # hidden
        self._scene_stack.append(scene)
        if len(self._scene_stack) == 1:
            AbstractApp.broadcast_event(OnGameStart())
    
        self._show_changes()
    
>       scene.run()

../../../../mge2/mini_game_engine/engine/lib.py:789: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def run(self):
        play_button = Button(""Play"")
        quit_button = Button(""Quit"")
    
        choice = self._wait_for_choice(self.player, [play_button, quit_button])
    
        if choice == play_button:
>           self._transition_to_scene(""MainGameScene"")

main_game/scenes/main_menu_scene.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>
scene_name = 'MainGameScene'

    def _transition_to_scene(self, scene_name: str):
>       self._app.transition_to_scene(scene_name, player=self.player)

../../../../mge2/mini_game_engine/engine/lib.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>, scene_id = 'MainGameScene'
transition_to_scene = None, kwargs = {'player': Default Player}
settings = Settings(env='LOCAL', redis_host='localhost', redis_port=6379, redis_secure_auth='', enable_persistence=False, enable_... enable_leaderboard_persistence=False, supabase_url='', supabase_key='', supabase_jwt_secret='', game_id='volter-game')

    def transition_to_scene(self, scene_id: str, transition_to_scene: Optional[AbstractGameScene] = None, **kwargs):
        try:
            settings = get_settings()
            if settings.enable_persistence:
                saved_data = self.persistence_client.retrieve(kwargs.get('player'))
                if saved_data:
                    print(""---> Fetching data"", saved_data)
                    dehydrated_scene_stack, next_scene_name = saved_data
                    if next_scene_name:
                        new_scene_stack = []
                        for dehydrated_scene in dehydrated_scene_stack:
                            scene_kwargs = {**dehydrated_scene}
                            del scene_kwargs[""__type""]
                            new_scene = self.scene_registry.get(dehydrated_scene[""__type""]).model_validate({
                                **scene_kwargs,
                                **kwargs
                            })
                            new_scene_stack.append(new_scene)
                        self._scene_stack = new_scene_stack
                        for _scene in self._scene_stack:
                            _scene.player = kwargs.get('player')
                        scene_id = next_scene_name
    
            scene_factory = self.scene_registry[scene_id]
        except KeyError as e:
            raise Exception(f""The scene {scene_id} is not registered, ""
                            f""all scenes should be registered using `register_scene` before `app.run()`"") from e
    
        if issubclass(scene_factory, AbstractMultiplayerScene):
            if kwargs.get(""player"") is not None:
                raise Exception(""player argument cannot be used on a multiplayer scene, you must use 'players'"")
            if kwargs.get(""players"") is None:
                raise Exception(""players argument must be set on a multiplayer scene"")
        scene = transition_to_scene
    
        if not scene:
            scene: AbstractGameScene = scene_factory(app=self, **kwargs)
    
>       self.__run_scene(scene)

../../../../mge2/mini_game_engine/engine/lib.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>
scene = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def __run_scene(self, scene: AbstractGameScene):
        # hidden
        settings = get_settings()
        # hidden
        if settings.enable_persistence:
            if self._scene_stack:
                self._persist_scene_stack(scene.__class__.__name__)
        # hidden
        AbstractApp._thread_to_app[threading.current_thread().ident] = self
        # hidden
        self._scene_stack.append(scene)
        if len(self._scene_stack) == 1:
            AbstractApp.broadcast_event(OnGameStart())
    
        self._show_changes()
    
>       scene.run()

../../../../mge2/mini_game_engine/engine/lib.py:789: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
                    self._transition_to_scene(""MainMenuScene"")
                    return
>       except RandomModeGracefulExit:
E       NameError: name 'RandomModeGracefulExit' is not defined

main_game/scenes/main_game_scene.py:56: NameError

During handling of the above exception, another exception occurred:

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:629: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:21: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:462: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
                    self._transition_to_scene(""MainMenuScene"")
                    return
>       except RandomModeGracefulExit:
E       NameError: name 'RandomModeGracefulExit' is not defined

main_game/scenes/main_game_scene.py:56: NameError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
You lost!
You lost!
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run - NameError: name 'RandomModeGracefulExit' is not defined
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots - NameError: name 'RandomModeGracefulExit' is not defined
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1
","Traceback (most recent call last):
  File ""/home/runner/work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py"", line 72, in execute
    await self.sdk.execute_as_task(PytestRunnerAgent, verbose=False)
  File ""/home/runner/work/volter-monorepo/volter-monorepo/volter-monorepo/packages/volter-common/common/sdk/SDK.py"", line 274, in execute_as_task
    response = await agent.execute()
               ^^^^^^^^^^^^^^^^^^^^^
  File ""/home/runner/work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_agents/internal/game/pytest_runner_agent/logic.py"", line 30, in execute
    output = run_pytest(test_file_path, project_root=self.sdk.project_directory, verbose=self.verbose)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/runner/work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-std-agents/agent_lib/random_run_utils.py"", line 141, in run_pytest
    raise AssertionError(f""Pytest failed with exit code {exit_code}. Output:\n{output}"")
AssertionError: Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-7.3.1, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: metadata-3.1.1, anyio-4.6.2.post1, Faker-30.8.2, timeout-2.3.1, time-machine-2.16.0, html-3.2.0, asyncio-0.23.8, sugar-0.9.7, cov-4.1.0
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
>               player_action = self.get_player_action(self.player)

main_game/scenes/main_game_scene.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Default Player

    def get_player_action(self, player: Player):
        available_choices = []
    
        # Check if Attack is valid
        if player.active_creature and player.active_creature.skills:
            available_choices.append(Button(""Attack""))
    
        # Check if Swap is valid
        valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
        if valid_creatures:
            available_choices.append(Button(""Swap""))
    
        # If no choices available, return None to indicate no valid moves
        if not available_choices:
            return None
    
>       choice = self._wait_for_choice(player, available_choices)

main_game/scenes/main_game_scene.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Default Player, choices = [Button(Attack)]

    def _wait_for_choice(self, player: AbstractPlayer, choices: List[AbstractChoice]) -> AbstractChoice:
        assert len(choices) > 0, ""`_wait_for_choice` was called with no choices""
        # hidden
        self._app._show_changes()
        # hidden
        if isinstance(self, AbstractMultiplayerScene):
            for p in self.players:
                if p != player:
                    p._listener.on_show_event(event_type=""OnGamePending"",
                                              event_data=OnGamePending(text=f""Waiting for {player}..."").model_dump()
                                              )
    
        # hidden
        if self._app.persistence_client:
            self._app.persistence_client.store(
                # TODO: optimize; there is no need to serialize the entire stack most of the time:
                deep_serialize(self._app._scene_stack), next_scene_name="""", checkpoint=""choice""
            )
        else:
            pass
        # print(f""{self.__class__.__name__}:_wait_for_choice({player.display_name}, {str(choices)})"")
>       choice = player._listener.on_wait_for_choice(self, choices)

../../../../mge2/mini_game_engine/engine/lib.py:444: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <mini_game_engine.engine.lib.HumanListener object at 0x[REDACTED]>
scene = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
choices = [Button(Attack)]

    def on_wait_for_choice(self, scene: ""AbstractGameScene"", choices: List[AbstractChoice]) -> AbstractChoice:
        if HumanListener.random_mode or self.random_mode:
            assert str(scene)
            self.random_mode_counter -= 1
            if self.random_mode_counter <= 0:
>               raise RandomModeGracefulExit()
E               mini_game_engine.engine.lib.RandomModeGracefulExit: HumanListener is in random mode and the current run is now over. This is exception is expected

../../../../mge2/mini_game_engine/engine/lib.py:342: RandomModeGracefulExit

During handling of the above exception, another exception occurred:

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # More moves needed for battle scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            # Patch the transition method to prevent actual scene transition
            with patch.object(MainGameScene, '_transition_to_scene') as mock_transition:
                try:
>                   main_game_scene.run()

main_game/tests/test_main_game_scene.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
                    self._transition_to_scene(""MainMenuScene"")
                    return
>       except RandomModeGracefulExit:
E       NameError: name 'RandomModeGracefulExit' is not defined

main_game/scenes/main_game_scene.py:56: NameError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
You lost!
starting random run iteration 1
You lost!
starting random run iteration 2
_____________________ test_full_game_flow_random_with_bots _____________________

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
>                   self._transition_to_scene(""MainMenuScene"")

main_game/scenes/main_game_scene.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
scene_name = 'MainMenuScene'

    def _transition_to_scene(self, scene_name: str):
>       self._app.transition_to_scene(scene_name, player=self.player)

../../../../mge2/mini_game_engine/engine/lib.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>, scene_id = 'MainMenuScene'
transition_to_scene = None, kwargs = {'player': Default Player}
settings = Settings(env='LOCAL', redis_host='localhost', redis_port=6379, redis_secure_auth='', enable_persistence=False, enable_... enable_leaderboard_persistence=False, supabase_url='', supabase_key='', supabase_jwt_secret='', game_id='volter-game')

    def transition_to_scene(self, scene_id: str, transition_to_scene: Optional[AbstractGameScene] = None, **kwargs):
        try:
            settings = get_settings()
            if settings.enable_persistence:
                saved_data = self.persistence_client.retrieve(kwargs.get('player'))
                if saved_data:
                    print(""---> Fetching data"", saved_data)
                    dehydrated_scene_stack, next_scene_name = saved_data
                    if next_scene_name:
                        new_scene_stack = []
                        for dehydrated_scene in dehydrated_scene_stack:
                            scene_kwargs = {**dehydrated_scene}
                            del scene_kwargs[""__type""]
                            new_scene = self.scene_registry.get(dehydrated_scene[""__type""]).model_validate({
                                **scene_kwargs,
                                **kwargs
                            })
                            new_scene_stack.append(new_scene)
                        self._scene_stack = new_scene_stack
                        for _scene in self._scene_stack:
                            _scene.player = kwargs.get('player')
                        scene_id = next_scene_name
    
            scene_factory = self.scene_registry[scene_id]
        except KeyError as e:
            raise Exception(f""The scene {scene_id} is not registered, ""
                            f""all scenes should be registered using `register_scene` before `app.run()`"") from e
    
        if issubclass(scene_factory, AbstractMultiplayerScene):
            if kwargs.get(""player"") is not None:
                raise Exception(""player argument cannot be used on a multiplayer scene, you must use 'players'"")
            if kwargs.get(""players"") is None:
                raise Exception(""players argument must be set on a multiplayer scene"")
        scene = transition_to_scene
    
        if not scene:
            scene: AbstractGameScene = scene_factory(app=self, **kwargs)
    
>       self.__run_scene(scene)

../../../../mge2/mini_game_engine/engine/lib.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>
scene = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def __run_scene(self, scene: AbstractGameScene):
        # hidden
        settings = get_settings()
        # hidden
        if settings.enable_persistence:
            if self._scene_stack:
                self._persist_scene_stack(scene.__class__.__name__)
        # hidden
        AbstractApp._thread_to_app[threading.current_thread().ident] = self
        # hidden
        self._scene_stack.append(scene)
        if len(self._scene_stack) == 1:
            AbstractApp.broadcast_event(OnGameStart())
    
        self._show_changes()
    
>       scene.run()

../../../../mge2/mini_game_engine/engine/lib.py:789: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def run(self):
        play_button = Button(""Play"")
        quit_button = Button(""Quit"")
    
        choice = self._wait_for_choice(self.player, [play_button, quit_button])
    
        if choice == play_button:
            self._transition_to_scene(""MainGameScene"")
        else:
>           self._quit_whole_game()

main_game/scenes/main_menu_scene.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def _quit_whole_game(self):
        # hidden
        if os.environ.get('SIMULATION_SCENE_TARGET'):
            return
>       self._app.quit_whole_game()

../../../../mge2/mini_game_engine/engine/lib.py:459: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>

    def quit_whole_game(self):
        self.terminated = True
>       raise AbstractApp._QuitWholeGame()
E       mini_game_engine.engine.lib.AbstractApp._QuitWholeGame: Game terminated gracefully. If you intended to quit the game, this exception is expected and should be caught

../../../../mge2/mini_game_engine/engine/lib.py:625: _QuitWholeGame

During handling of the above exception, another exception occurred:

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
>                   self._transition_to_scene(""MainMenuScene"")

main_game/scenes/main_game_scene.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
scene_name = 'MainMenuScene'

    def _transition_to_scene(self, scene_name: str):
>       self._app.transition_to_scene(scene_name, player=self.player)

../../../../mge2/mini_game_engine/engine/lib.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>, scene_id = 'MainMenuScene'
transition_to_scene = None, kwargs = {'player': Default Player}
settings = Settings(env='LOCAL', redis_host='localhost', redis_port=6379, redis_secure_auth='', enable_persistence=False, enable_... enable_leaderboard_persistence=False, supabase_url='', supabase_key='', supabase_jwt_secret='', game_id='volter-game')

    def transition_to_scene(self, scene_id: str, transition_to_scene: Optional[AbstractGameScene] = None, **kwargs):
        try:
            settings = get_settings()
            if settings.enable_persistence:
                saved_data = self.persistence_client.retrieve(kwargs.get('player'))
                if saved_data:
                    print(""---> Fetching data"", saved_data)
                    dehydrated_scene_stack, next_scene_name = saved_data
                    if next_scene_name:
                        new_scene_stack = []
                        for dehydrated_scene in dehydrated_scene_stack:
                            scene_kwargs = {**dehydrated_scene}
                            del scene_kwargs[""__type""]
                            new_scene = self.scene_registry.get(dehydrated_scene[""__type""]).model_validate({
                                **scene_kwargs,
                                **kwargs
                            })
                            new_scene_stack.append(new_scene)
                        self._scene_stack = new_scene_stack
                        for _scene in self._scene_stack:
                            _scene.player = kwargs.get('player')
                        scene_id = next_scene_name
    
            scene_factory = self.scene_registry[scene_id]
        except KeyError as e:
            raise Exception(f""The scene {scene_id} is not registered, ""
                            f""all scenes should be registered using `register_scene` before `app.run()`"") from e
    
        if issubclass(scene_factory, AbstractMultiplayerScene):
            if kwargs.get(""player"") is not None:
                raise Exception(""player argument cannot be used on a multiplayer scene, you must use 'players'"")
            if kwargs.get(""players"") is None:
                raise Exception(""players argument must be set on a multiplayer scene"")
        scene = transition_to_scene
    
        if not scene:
            scene: AbstractGameScene = scene_factory(app=self, **kwargs)
    
>       self.__run_scene(scene)

../../../../mge2/mini_game_engine/engine/lib.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>
scene = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def __run_scene(self, scene: AbstractGameScene):
        # hidden
        settings = get_settings()
        # hidden
        if settings.enable_persistence:
            if self._scene_stack:
                self._persist_scene_stack(scene.__class__.__name__)
        # hidden
        AbstractApp._thread_to_app[threading.current_thread().ident] = self
        # hidden
        self._scene_stack.append(scene)
        if len(self._scene_stack) == 1:
            AbstractApp.broadcast_event(OnGameStart())
    
        self._show_changes()
    
>       scene.run()

../../../../mge2/mini_game_engine/engine/lib.py:789: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def run(self):
        play_button = Button(""Play"")
        quit_button = Button(""Quit"")
    
        choice = self._wait_for_choice(self.player, [play_button, quit_button])
    
        if choice == play_button:
>           self._transition_to_scene(""MainGameScene"")

main_game/scenes/main_menu_scene.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>
scene_name = 'MainGameScene'

    def _transition_to_scene(self, scene_name: str):
>       self._app.transition_to_scene(scene_name, player=self.player)

../../../../mge2/mini_game_engine/engine/lib.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>, scene_id = 'MainGameScene'
transition_to_scene = None, kwargs = {'player': Default Player}
settings = Settings(env='LOCAL', redis_host='localhost', redis_port=6379, redis_secure_auth='', enable_persistence=False, enable_... enable_leaderboard_persistence=False, supabase_url='', supabase_key='', supabase_jwt_secret='', game_id='volter-game')

    def transition_to_scene(self, scene_id: str, transition_to_scene: Optional[AbstractGameScene] = None, **kwargs):
        try:
            settings = get_settings()
            if settings.enable_persistence:
                saved_data = self.persistence_client.retrieve(kwargs.get('player'))
                if saved_data:
                    print(""---> Fetching data"", saved_data)
                    dehydrated_scene_stack, next_scene_name = saved_data
                    if next_scene_name:
                        new_scene_stack = []
                        for dehydrated_scene in dehydrated_scene_stack:
                            scene_kwargs = {**dehydrated_scene}
                            del scene_kwargs[""__type""]
                            new_scene = self.scene_registry.get(dehydrated_scene[""__type""]).model_validate({
                                **scene_kwargs,
                                **kwargs
                            })
                            new_scene_stack.append(new_scene)
                        self._scene_stack = new_scene_stack
                        for _scene in self._scene_stack:
                            _scene.player = kwargs.get('player')
                        scene_id = next_scene_name
    
            scene_factory = self.scene_registry[scene_id]
        except KeyError as e:
            raise Exception(f""The scene {scene_id} is not registered, ""
                            f""all scenes should be registered using `register_scene` before `app.run()`"") from e
    
        if issubclass(scene_factory, AbstractMultiplayerScene):
            if kwargs.get(""player"") is not None:
                raise Exception(""player argument cannot be used on a multiplayer scene, you must use 'players'"")
            if kwargs.get(""players"") is None:
                raise Exception(""players argument must be set on a multiplayer scene"")
        scene = transition_to_scene
    
        if not scene:
            scene: AbstractGameScene = scene_factory(app=self, **kwargs)
    
>       self.__run_scene(scene)

../../../../mge2/mini_game_engine/engine/lib.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>
scene = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def __run_scene(self, scene: AbstractGameScene):
        # hidden
        settings = get_settings()
        # hidden
        if settings.enable_persistence:
            if self._scene_stack:
                self._persist_scene_stack(scene.__class__.__name__)
        # hidden
        AbstractApp._thread_to_app[threading.current_thread().ident] = self
        # hidden
        self._scene_stack.append(scene)
        if len(self._scene_stack) == 1:
            AbstractApp.broadcast_event(OnGameStart())
    
        self._show_changes()
    
>       scene.run()

../../../../mge2/mini_game_engine/engine/lib.py:789: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
                    self._transition_to_scene(""MainMenuScene"")
                    return
>       except RandomModeGracefulExit:
E       NameError: name 'RandomModeGracefulExit' is not defined

main_game/scenes/main_game_scene.py:56: NameError

During handling of the above exception, another exception occurred:

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:629: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:21: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:462: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
                    self._transition_to_scene(""MainMenuScene"")
                    return
>       except RandomModeGracefulExit:
E       NameError: name 'RandomModeGracefulExit' is not defined

main_game/scenes/main_game_scene.py:56: NameError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
You lost!
You lost!
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run - NameError: name 'RandomModeGracefulExit' is not defined
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots - NameError: name 'RandomModeGracefulExit' is not defined
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1


During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/home/runner/work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_bench/bench_utils.py"", line 93, in execute_agent
    asyncio.run(agent.execute())
  File ""/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/asyncio/runners.py"", line 190, in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
  File ""/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/asyncio/runners.py"", line 118, in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/asyncio/base_events.py"", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File ""/home/runner/work/volter-monorepo/volter-monorepo/volter-monorepo/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py"", line 79, in execute
    raise FixableException(
common.exceptions.FixableException: After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-7.3.1, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: metadata-3.1.1, anyio-4.6.2.post1, Faker-30.8.2, timeout-2.3.1, time-machine-2.16.0, html-3.2.0, asyncio-0.23.8, sugar-0.9.7, cov-4.1.0
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
>               player_action = self.get_player_action(self.player)

main_game/scenes/main_game_scene.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Default Player

    def get_player_action(self, player: Player):
        available_choices = []
    
        # Check if Attack is valid
        if player.active_creature and player.active_creature.skills:
            available_choices.append(Button(""Attack""))
    
        # Check if Swap is valid
        valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
        if valid_creatures:
            available_choices.append(Button(""Swap""))
    
        # If no choices available, return None to indicate no valid moves
        if not available_choices:
            return None
    
>       choice = self._wait_for_choice(player, available_choices)

main_game/scenes/main_game_scene.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
player = Default Player, choices = [Button(Attack)]

    def _wait_for_choice(self, player: AbstractPlayer, choices: List[AbstractChoice]) -> AbstractChoice:
        assert len(choices) > 0, ""`_wait_for_choice` was called with no choices""
        # hidden
        self._app._show_changes()
        # hidden
        if isinstance(self, AbstractMultiplayerScene):
            for p in self.players:
                if p != player:
                    p._listener.on_show_event(event_type=""OnGamePending"",
                                              event_data=OnGamePending(text=f""Waiting for {player}..."").model_dump()
                                              )
    
        # hidden
        if self._app.persistence_client:
            self._app.persistence_client.store(
                # TODO: optimize; there is no need to serialize the entire stack most of the time:
                deep_serialize(self._app._scene_stack), next_scene_name="""", checkpoint=""choice""
            )
        else:
            pass
        # print(f""{self.__class__.__name__}:_wait_for_choice({player.display_name}, {str(choices)})"")
>       choice = player._listener.on_wait_for_choice(self, choices)

../../../../mge2/mini_game_engine/engine/lib.py:444: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <mini_game_engine.engine.lib.HumanListener object at 0x[REDACTED]>
scene = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
choices = [Button(Attack)]

    def on_wait_for_choice(self, scene: ""AbstractGameScene"", choices: List[AbstractChoice]) -> AbstractChoice:
        if HumanListener.random_mode or self.random_mode:
            assert str(scene)
            self.random_mode_counter -= 1
            if self.random_mode_counter <= 0:
>               raise RandomModeGracefulExit()
E               mini_game_engine.engine.lib.RandomModeGracefulExit: HumanListener is in random mode and the current run is now over. This is exception is expected

../../../../mge2/mini_game_engine/engine/lib.py:342: RandomModeGracefulExit

During handling of the above exception, another exception occurred:

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # More moves needed for battle scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            # Patch the transition method to prevent actual scene transition
            with patch.object(MainGameScene, '_transition_to_scene') as mock_transition:
                try:
>                   main_game_scene.run()

main_game/tests/test_main_game_scene.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
                    self._transition_to_scene(""MainMenuScene"")
                    return
>       except RandomModeGracefulExit:
E       NameError: name 'RandomModeGracefulExit' is not defined

main_game/scenes/main_game_scene.py:56: NameError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
You lost!
starting random run iteration 1
You lost!
starting random run iteration 2
_____________________ test_full_game_flow_random_with_bots _____________________

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
>                   self._transition_to_scene(""MainMenuScene"")

main_game/scenes/main_game_scene.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
scene_name = 'MainMenuScene'

    def _transition_to_scene(self, scene_name: str):
>       self._app.transition_to_scene(scene_name, player=self.player)

../../../../mge2/mini_game_engine/engine/lib.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>, scene_id = 'MainMenuScene'
transition_to_scene = None, kwargs = {'player': Default Player}
settings = Settings(env='LOCAL', redis_host='localhost', redis_port=6379, redis_secure_auth='', enable_persistence=False, enable_... enable_leaderboard_persistence=False, supabase_url='', supabase_key='', supabase_jwt_secret='', game_id='volter-game')

    def transition_to_scene(self, scene_id: str, transition_to_scene: Optional[AbstractGameScene] = None, **kwargs):
        try:
            settings = get_settings()
            if settings.enable_persistence:
                saved_data = self.persistence_client.retrieve(kwargs.get('player'))
                if saved_data:
                    print(""---> Fetching data"", saved_data)
                    dehydrated_scene_stack, next_scene_name = saved_data
                    if next_scene_name:
                        new_scene_stack = []
                        for dehydrated_scene in dehydrated_scene_stack:
                            scene_kwargs = {**dehydrated_scene}
                            del scene_kwargs[""__type""]
                            new_scene = self.scene_registry.get(dehydrated_scene[""__type""]).model_validate({
                                **scene_kwargs,
                                **kwargs
                            })
                            new_scene_stack.append(new_scene)
                        self._scene_stack = new_scene_stack
                        for _scene in self._scene_stack:
                            _scene.player = kwargs.get('player')
                        scene_id = next_scene_name
    
            scene_factory = self.scene_registry[scene_id]
        except KeyError as e:
            raise Exception(f""The scene {scene_id} is not registered, ""
                            f""all scenes should be registered using `register_scene` before `app.run()`"") from e
    
        if issubclass(scene_factory, AbstractMultiplayerScene):
            if kwargs.get(""player"") is not None:
                raise Exception(""player argument cannot be used on a multiplayer scene, you must use 'players'"")
            if kwargs.get(""players"") is None:
                raise Exception(""players argument must be set on a multiplayer scene"")
        scene = transition_to_scene
    
        if not scene:
            scene: AbstractGameScene = scene_factory(app=self, **kwargs)
    
>       self.__run_scene(scene)

../../../../mge2/mini_game_engine/engine/lib.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>
scene = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def __run_scene(self, scene: AbstractGameScene):
        # hidden
        settings = get_settings()
        # hidden
        if settings.enable_persistence:
            if self._scene_stack:
                self._persist_scene_stack(scene.__class__.__name__)
        # hidden
        AbstractApp._thread_to_app[threading.current_thread().ident] = self
        # hidden
        self._scene_stack.append(scene)
        if len(self._scene_stack) == 1:
            AbstractApp.broadcast_event(OnGameStart())
    
        self._show_changes()
    
>       scene.run()

../../../../mge2/mini_game_engine/engine/lib.py:789: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def run(self):
        play_button = Button(""Play"")
        quit_button = Button(""Quit"")
    
        choice = self._wait_for_choice(self.player, [play_button, quit_button])
    
        if choice == play_button:
            self._transition_to_scene(""MainGameScene"")
        else:
>           self._quit_whole_game()

main_game/scenes/main_menu_scene.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def _quit_whole_game(self):
        # hidden
        if os.environ.get('SIMULATION_SCENE_TARGET'):
            return
>       self._app.quit_whole_game()

../../../../mge2/mini_game_engine/engine/lib.py:459: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>

    def quit_whole_game(self):
        self.terminated = True
>       raise AbstractApp._QuitWholeGame()
E       mini_game_engine.engine.lib.AbstractApp._QuitWholeGame: Game terminated gracefully. If you intended to quit the game, this exception is expected and should be caught

../../../../mge2/mini_game_engine/engine/lib.py:625: _QuitWholeGame

During handling of the above exception, another exception occurred:

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
>                   self._transition_to_scene(""MainMenuScene"")

main_game/scenes/main_game_scene.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>
scene_name = 'MainMenuScene'

    def _transition_to_scene(self, scene_name: str):
>       self._app.transition_to_scene(scene_name, player=self.player)

../../../../mge2/mini_game_engine/engine/lib.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>, scene_id = 'MainMenuScene'
transition_to_scene = None, kwargs = {'player': Default Player}
settings = Settings(env='LOCAL', redis_host='localhost', redis_port=6379, redis_secure_auth='', enable_persistence=False, enable_... enable_leaderboard_persistence=False, supabase_url='', supabase_key='', supabase_jwt_secret='', game_id='volter-game')

    def transition_to_scene(self, scene_id: str, transition_to_scene: Optional[AbstractGameScene] = None, **kwargs):
        try:
            settings = get_settings()
            if settings.enable_persistence:
                saved_data = self.persistence_client.retrieve(kwargs.get('player'))
                if saved_data:
                    print(""---> Fetching data"", saved_data)
                    dehydrated_scene_stack, next_scene_name = saved_data
                    if next_scene_name:
                        new_scene_stack = []
                        for dehydrated_scene in dehydrated_scene_stack:
                            scene_kwargs = {**dehydrated_scene}
                            del scene_kwargs[""__type""]
                            new_scene = self.scene_registry.get(dehydrated_scene[""__type""]).model_validate({
                                **scene_kwargs,
                                **kwargs
                            })
                            new_scene_stack.append(new_scene)
                        self._scene_stack = new_scene_stack
                        for _scene in self._scene_stack:
                            _scene.player = kwargs.get('player')
                        scene_id = next_scene_name
    
            scene_factory = self.scene_registry[scene_id]
        except KeyError as e:
            raise Exception(f""The scene {scene_id} is not registered, ""
                            f""all scenes should be registered using `register_scene` before `app.run()`"") from e
    
        if issubclass(scene_factory, AbstractMultiplayerScene):
            if kwargs.get(""player"") is not None:
                raise Exception(""player argument cannot be used on a multiplayer scene, you must use 'players'"")
            if kwargs.get(""players"") is None:
                raise Exception(""players argument must be set on a multiplayer scene"")
        scene = transition_to_scene
    
        if not scene:
            scene: AbstractGameScene = scene_factory(app=self, **kwargs)
    
>       self.__run_scene(scene)

../../../../mge2/mini_game_engine/engine/lib.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>
scene = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def __run_scene(self, scene: AbstractGameScene):
        # hidden
        settings = get_settings()
        # hidden
        if settings.enable_persistence:
            if self._scene_stack:
                self._persist_scene_stack(scene.__class__.__name__)
        # hidden
        AbstractApp._thread_to_app[threading.current_thread().ident] = self
        # hidden
        self._scene_stack.append(scene)
        if len(self._scene_stack) == 1:
            AbstractApp.broadcast_event(OnGameStart())
    
        self._show_changes()
    
>       scene.run()

../../../../mge2/mini_game_engine/engine/lib.py:789: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>

    def run(self):
        play_button = Button(""Play"")
        quit_button = Button(""Quit"")
    
        choice = self._wait_for_choice(self.player, [play_button, quit_button])
    
        if choice == play_button:
>           self._transition_to_scene(""MainGameScene"")

main_game/scenes/main_menu_scene.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_menu_scene.MainMenuScene object at 0x[REDACTED]>
scene_name = 'MainGameScene'

    def _transition_to_scene(self, scene_name: str):
>       self._app.transition_to_scene(scene_name, player=self.player)

../../../../mge2/mini_game_engine/engine/lib.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>, scene_id = 'MainGameScene'
transition_to_scene = None, kwargs = {'player': Default Player}
settings = Settings(env='LOCAL', redis_host='localhost', redis_port=6379, redis_secure_auth='', enable_persistence=False, enable_... enable_leaderboard_persistence=False, supabase_url='', supabase_key='', supabase_jwt_secret='', game_id='volter-game')

    def transition_to_scene(self, scene_id: str, transition_to_scene: Optional[AbstractGameScene] = None, **kwargs):
        try:
            settings = get_settings()
            if settings.enable_persistence:
                saved_data = self.persistence_client.retrieve(kwargs.get('player'))
                if saved_data:
                    print(""---> Fetching data"", saved_data)
                    dehydrated_scene_stack, next_scene_name = saved_data
                    if next_scene_name:
                        new_scene_stack = []
                        for dehydrated_scene in dehydrated_scene_stack:
                            scene_kwargs = {**dehydrated_scene}
                            del scene_kwargs[""__type""]
                            new_scene = self.scene_registry.get(dehydrated_scene[""__type""]).model_validate({
                                **scene_kwargs,
                                **kwargs
                            })
                            new_scene_stack.append(new_scene)
                        self._scene_stack = new_scene_stack
                        for _scene in self._scene_stack:
                            _scene.player = kwargs.get('player')
                        scene_id = next_scene_name
    
            scene_factory = self.scene_registry[scene_id]
        except KeyError as e:
            raise Exception(f""The scene {scene_id} is not registered, ""
                            f""all scenes should be registered using `register_scene` before `app.run()`"") from e
    
        if issubclass(scene_factory, AbstractMultiplayerScene):
            if kwargs.get(""player"") is not None:
                raise Exception(""player argument cannot be used on a multiplayer scene, you must use 'players'"")
            if kwargs.get(""players"") is None:
                raise Exception(""players argument must be set on a multiplayer scene"")
        scene = transition_to_scene
    
        if not scene:
            scene: AbstractGameScene = scene_factory(app=self, **kwargs)
    
>       self.__run_scene(scene)

../../../../mge2/mini_game_engine/engine/lib.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.main.App object at 0x[REDACTED]>
scene = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def __run_scene(self, scene: AbstractGameScene):
        # hidden
        settings = get_settings()
        # hidden
        if settings.enable_persistence:
            if self._scene_stack:
                self._persist_scene_stack(scene.__class__.__name__)
        # hidden
        AbstractApp._thread_to_app[threading.current_thread().ident] = self
        # hidden
        self._scene_stack.append(scene)
        if len(self._scene_stack) == 1:
            AbstractApp.broadcast_event(OnGameStart())
    
        self._show_changes()
    
>       scene.run()

../../../../mge2/mini_game_engine/engine/lib.py:789: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
                    self._transition_to_scene(""MainMenuScene"")
                    return
>       except RandomModeGracefulExit:
E       NameError: name 'RandomModeGracefulExit' is not defined

main_game/scenes/main_game_scene.py:56: NameError

During handling of the above exception, another exception occurred:

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:629: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:21: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:462: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:745: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:789: in __run_scene
    scene.run()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    # No valid actions means this player has lost
                    self._show_text(self.player, ""You have no valid moves!"")
                    self._show_text(self.player, ""You lost!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                bot_action = self.get_player_action(self.bot)
                if not bot_action:
                    # No valid actions means the bot has lost
                    self._show_text(self.player, ""The opponent has no valid moves!"")
                    self._show_text(self.player, ""You won!"")
                    self._transition_to_scene(""MainMenuScene"")
                    return
    
                # Execute actions
                self.resolve_turn(player_action, bot_action)
    
                # Check for battle end
                if self.check_battle_end():
                    self._transition_to_scene(""MainMenuScene"")
                    return
>       except RandomModeGracefulExit:
E       NameError: name 'RandomModeGracefulExit' is not defined

main_game/scenes/main_game_scene.py:56: NameError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
You lost!
You lost!
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run - NameError: name 'RandomModeGracefulExit' is not defined
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots - NameError: name 'RandomModeGracefulExit' is not defined
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1

",['new_prompt_logs/999999_167455_OneShotCoreAgent'],ladder/creature_battler_05_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
2024-11-10 14:55:40,12f000a2-f39a-4bc2-b453-05bd03d5e03a,OneShotCoreAgent,creature_battler_05,6,success,,,['new_prompt_logs/999999_821687_OneShotCoreAgent'],ladder/creature_battler_05_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/7ce8710d68bf467ba38776b81e6d5b9310b6c992/packages/lib-volter-mge2/mge_agents/internal/one_shot_gen/one_shot_core.py,main,mge2_game,,gpt-4o,gpt-4o,gpt-4o-mini,claude-3-5-sonnet-20241022
