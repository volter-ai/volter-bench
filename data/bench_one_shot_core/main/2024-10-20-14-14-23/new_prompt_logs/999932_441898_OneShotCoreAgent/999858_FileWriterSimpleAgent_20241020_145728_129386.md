Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
I understand the issue now. The current implementation doesn't include the random turn order when creatures have the same speed, which is a required feature according to the documentation. I'll describe how to fix this and then provide the updated `main_game_scene.py` file.

1. How to fix the issue:

We need to modify the `resolution_phase` method in the `MainGameScene` class to implement random turn order when creatures have the same speed. Here's how we'll do it:

a. Instead of using a simple sort based on speed, we'll create a custom sorting function.
b. This function will compare the speeds of the creatures. If they're equal, it will return a random choice between -1 and 1.
c. We'll use Python's `functools.cmp_to_key` to convert this comparison function into a key function for sorting.
d. We'll apply this sorting to determine the order of actions in the resolution phase.

This solution stays within the capabilities of the engine and doesn't require changes to the models.

2. Here's the rewritten `main_game_scene.py` file with the proposed solution:

# Excerpt ID: da6bdc03-4f10-4eda-8b59-438756b89eca
```python main_game/scenes/main_game_scene.py
import random
from functools import cmp_to_key
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.turn_counter = 0

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        return f"""===Battle===
Turn: {self.turn_counter}

{self.player.display_name}'s {player_creature.display_name}:
HP: {player_creature.hp}/{player_creature.max_hp}

{self.opponent.display_name}'s {opponent_creature.display_name}:
HP: {opponent_creature.hp}/{opponent_creature.max_hp}

> Attack
> Swap
"""

    def run(self):
        self._show_text(self.player, "Battle start!")
        self._show_text(self.opponent, "Battle start!")
        while True:
            self.turn_counter += 1
            player_action = self.player_choice_phase(self.player)
            opponent_action = self.player_choice_phase(self.opponent)
            
            if player_action and opponent_action:
                self.resolution_phase(player_action, opponent_action)
            
            if self.check_battle_end():
                break

    def player_choice_phase(self, current_player):
        while True:
            attack_button = Button("Attack")
            choices = [attack_button]
            
            if self.has_available_creatures_to_swap(current_player):
                swap_button = Button("Swap")
                choices.append(swap_button)
            
            choice = self._wait_for_choice(current_player, choices)

            if attack_button == choice:
                action = self.choose_attack(current_player)
            elif swap_button == choice:
                action = self.choose_swap(current_player)
            
            if action:
                return action

    def has_available_creatures_to_swap(self, player):
        return any(c for c in player.creatures if c.hp > 0 and c != player.active_creature)

    def choose_attack(self, current_player):
        back_button = Button("Back")
        choices = [SelectThing(skill) for skill in current_player.active_creature.skills] + [back_button]
        choice = self._wait_for_choice(current_player, choices)
        if choice == back_button:
            return None
        return choice

    def choose_swap(self, current_player):
        available_creatures = [c for c in current_player.creatures if c.hp > 0 and c != current_player.active_creature]
        if not available_creatures:
            return None
        back_button = Button("Back")
        choices = [SelectThing(creature) for creature in available_creatures] + [back_button]
        choice = self._wait_for_choice(current_player, choices)
        if choice == back_button:
            return None
        return choice

    def resolution_phase(self, player_action, opponent_action):
        actions = [
            (self.player, player_action),
            (self.opponent, opponent_action)
        ]

        def speed_compare(a, b):
            speed_a = a[0].active_creature.speed
            speed_b = b[0].active_creature.speed
            if speed_a > speed_b:
                return -1
            elif speed_a < speed_b:
                return 1
            else:
                return random.choice([-1, 1])

        actions.sort(key=cmp_to_key(speed_compare))

        for current_player, action in actions:
            if action is None:
                continue
            other_player = self.opponent if current_player == self.player else self.player
            if isinstance(action.thing, Creature):
                self.perform_swap(current_player, action.thing)
            elif isinstance(action.thing, Skill):
                self.perform_attack(current_player, other_player, action.thing)

    def perform_swap(self, player, new_creature):
        player.active_creature = new_creature
        self._show_text(self.player, f"{player.display_name} swapped to {new_creature.display_name}!")
        self._show_text(self.opponent, f"{player.display_name} swapped to {new_creature.display_name}!")

    def perform_attack(self, attacker, defender, skill):
        damage = self.calculate_damage(attacker.active_creature, defender.active_creature, skill)
        defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
        self._show_text(self.player, f"{attacker.display_name}'s {attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(self.opponent, f"{attacker.display_name}'s {attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender.display_name}'s {defender.active_creature.display_name} took {damage} damage!")
        self._show_text(the.opponent, f"{defender.display_name}'s {defender.active_creature.display_name} took {damage} damage!")

        if defender.active_creature.hp == 0:
            self._show_text(self.player, f"{defender.display_name}'s {defender.active_creature.display_name} fainted!")
            self._show_text(self.opponent, f"{defender.display_name}'s {defender.active_creature.display_name} fainted!")
            self.force_swap(defender)

    def calculate_damage(self, attacker, defender, skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_effectiveness)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def get_type_effectiveness(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def force_swap(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if not available_creatures:
            return

        choices = [SelectThing(creature) for creature in available_creatures]
        new_creature = self._wait_for_choice(player, choices).thing
        self.perform_swap(player, new_creature)

    def reset_creature_states(self):
        for player in [self.player, self.opponent]:
            for creature in player.creatures:
                creature.hp = creature.max_hp

    def check_battle_end(self):
        player_creatures_alive = any(c.hp > 0 for c in self.player.creatures)
        opponent_creatures_alive = any(c.hp > 0 for c in self.opponent.creatures)

        if not player_creatures_alive:
            self._show_text(self.player, "You lost the battle!")
            self._show_text(self.opponent, "You won the battle!")
            self.reset_creature_states()
            self._transition_to_scene("MainMenuScene")
            return True
        elif not opponent_creatures_alive:
            self._show_text(self.player, "You won the battle!")
            self._show_text(self.opponent, "You lost the battle!")
            self.reset_creature_states()
            self._transition_to_scene("MainMenuScene")
            return True
        return False
```

This updated implementation includes the random turn order when creatures have the same speed, as required by the documentation. The `resolution_phase` method now uses a custom comparison function `speed_compare` that introduces randomness when speeds are equal. This should resolve the issue while maintaining the existing architecture and staying within the capabilities of the engine.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "da6bdc03-4f10-4eda-8b59-438756b89eca", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
