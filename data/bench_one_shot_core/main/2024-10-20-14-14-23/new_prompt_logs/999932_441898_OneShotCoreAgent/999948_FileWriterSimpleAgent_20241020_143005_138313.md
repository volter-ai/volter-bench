Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To address the issue of not implementing the speed-based turn order logic in the MainGameScene, I'll make the following changes:

1. Modify the MainGameScene to implement the speed-based turn order logic.
2. Refactor the battle loop to determine the order of actions based on the creatures' speed stats.
3. Implement a tie-breaker mechanism for when creatures have the same speed.

Here's the proposed solution for the MainGameScene:

# Excerpt ID: eb120895-95d9-4a7b-a56a-e4baffd9fd3f
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.turn_counter = 0
        self.max_turns = 20  # Set a maximum number of turns for the battle

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp}, Speed: {self.player_creature.speed})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp}, Speed: {self.opponent_creature.speed})

Your skills:
{self._format_skills(self.player_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name}" for skill in skills])

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appears!")
        while True:
            self.turn_counter += 1
            if self.turn_counter > self.max_turns:
                self._show_text(self.player, "The battle has gone on for too long. It's a draw!")
                self._quit_whole_game()
                return

            if self._check_battle_end():
                self._transition_to_scene("MainMenuScene")
                return

            player_skill = self._player_choose_skill()
            opponent_skill = self._opponent_choose_skill()

            self._resolve_turn(player_skill, opponent_skill)

            if self._check_battle_end():
                self._transition_to_scene("MainMenuScene")
                return

    def _player_choose_skill(self) -> Skill:
        self._show_text(self.player, "Your turn to choose a skill!")
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def _opponent_choose_skill(self) -> Skill:
        return random.choice(self.opponent_creature.skills)

    def _resolve_turn(self, player_skill: Skill, opponent_skill: Skill):
        if self.player_creature.speed > self.opponent_creature.speed:
            self._execute_skill(self.player_creature, self.opponent_creature, player_skill)
            if not self._check_battle_end():
                self._execute_skill(self.opponent_creature, self.player_creature, opponent_skill)
        elif self.player_creature.speed < self.opponent_creature.speed:
            self._execute_skill(self.opponent_creature, self.player_creature, opponent_skill)
            if not self._check_battle_end():
                self._execute_skill(self.player_creature, self.opponent_creature, player_skill)
        else:
            # If speeds are equal, randomly decide who goes first
            if random.choice([True, False]):
                self._execute_skill(self.player_creature, self.opponent_creature, player_skill)
                if not self._check_battle_end():
                    self._execute_skill(self.opponent_creature, self.player_creature, opponent_skill)
            else:
                self._execute_skill(self.opponent_creature, self.player_creature, opponent_skill)
                if not self._check_battle_end():
                    self._execute_skill(self.player_creature, self.opponent_creature, player_skill)

    def _execute_skill(self, attacker: Creature, defender: Creature, skill: Skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        type_factor = self._get_type_factor(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_factor)
        defender.hp = max(0, defender.hp - final_damage)

        self._show_text(self.player, f"{attacker.display_name} uses {skill.display_name}!")
        self._show_text(self.player, f"It deals {final_damage} damage to {defender.display_name}!")

    def _get_type_factor(self, skill_type: str, defender_type: str) -> float:
        if skill_type == "normal":
            return 1.0
        elif skill_type == "fire" and defender_type == "leaf":
            return 2.0
        elif skill_type == "water" and defender_type == "fire":
            return 2.0
        elif skill_type == "leaf" and defender_type == "water":
            return 2.0
        elif skill_type == "fire" and defender_type == "water":
            return 0.5
        elif skill_type == "water" and defender_type == "leaf":
            return 0.5
        elif skill_type == "leaf" and defender_type == "fire":
            return 0.5
        else:
            return 1.0

    def _check_battle_end(self) -> bool:
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player_creature.display_name} fainted! You lose!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"{self.opponent_creature.display_name} fainted! You win!")
            return True
        return False
```

This implementation addresses the speed-based turn order logic as follows:

1. The `run` method now calls `_player_choose_skill` and `_opponent_choose_skill` to get the skills for both creatures before resolving the turn.

2. The `_resolve_turn` method implements the speed-based logic:
   - If the player's creature is faster, it acts first.
   - If the opponent's creature is faster, it acts first.
   - If their speeds are equal, a random choice is made to determine who goes first.

3. The turn resolution checks for battle end conditions after each skill execution, ensuring that a knocked-out creature doesn't get to use its skill.

4. The `__str__` method now includes the speed of both creatures for better visibility of the battle state.

These changes implement the speed-based turn order logic as described in the architecture documents while staying within the capabilities of the engine and maintaining the existing model structure.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "eb120895-95d9-4a7b-a56a-e4baffd9fd3f", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
