Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To address the issue raised during QA/testing, we need to reset the state of the player's creatures after the battle ends. This is an important step to ensure that creatures are ready for the next battle with their full HP. Here's how we'll fix this issue:

1. We'll add a method in the MainGameScene to reset the creatures' HP to their max_hp value.
2. We'll call this method just before transitioning back to the MainMenuScene.

This approach aligns with the architecture and stays within the capabilities of the engine. It doesn't require changes to the models, keeping them as pure data schemas.

Here's the updated MainGameScene with the proposed solution:

# Excerpt ID: ac6fcdcf-57c4-4f3e-bf7c-a32997730f91
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Available skills:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        while True:
            # Player Choice Phase
            player_skill = self.player_turn()
            
            # Foe Choice Phase
            opponent_skill = self.opponent_turn()
            
            # Resolution Phase
            self.resolve_turn(player_skill, opponent_skill)
            
            if self.check_battle_end():
                break

        # Reset creatures' state before transitioning
        self.reset_creatures()

        # Transition back to the main menu after the battle ends
        self._transition_to_scene("MainMenuScene")

    def player_turn(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def opponent_turn(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def resolve_turn(self, player_skill, opponent_skill):
        first, second = self.determine_order(self.player_creature, self.opponent_creature)
        
        if first == self.player_creature:
            self.execute_skill(self.player_creature, self.opponent_creature, player_skill)
            if not self.check_battle_end():
                self.execute_skill(self.opponent_creature, self.player_creature, opponent_skill)
        else:
            self.execute_skill(self.opponent_creature, self.player_creature, opponent_skill)
            if not self.check_battle_end():
                self.execute_skill(self.player_creature, self.opponent_creature, player_skill)

    def determine_order(self, creature1, creature2):
        if creature1.speed > creature2.speed:
            return creature1, creature2
        elif creature2.speed > creature1.speed:
            return creature2, creature1
        else:
            return random.sample([creature1, creature2], 2)

    def execute_skill(self, attacker, defender, skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        weakness_factor = self.calculate_weakness_factor(skill.skill_type, defender.creature_type)
        final_damage = int(weakness_factor * raw_damage)
        
        defender.hp = max(0, defender.hp - final_damage)
        
        self._show_text(self.player, f"{attacker.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender.display_name} took {final_damage} damage!")

    def calculate_weakness_factor(self, skill_type, defender_type):
        effectiveness = {
            "fire": {"leaf": 2, "water": 0.5},
            "water": {"fire": 2, "leaf": 0.5},
            "leaf": {"water": 2, "fire": 0.5}
        }
        return effectiveness.get(skill_type, {}).get(defender_type, 1)

    def check_battle_end(self):
        if self.player_creature.hp == 0:
            self._show_text(self.player, "You lost the battle!")
            return True
        elif self.opponent_creature.hp == 0:
            self._show_text(self.player, "You won the battle!")
            return True
        return False

    def reset_creatures(self):
        for creature in self.player.creatures + self.opponent.creatures:
            creature.hp = creature.max_hp
        self._show_text(self.player, "All creatures have been restored to full health.")
```

This updated implementation addresses the issue by adding the `reset_creatures` method and calling it before transitioning back to the MainMenuScene. This ensures that all creatures (both the player's and the opponent's) are restored to full health after each battle, aligning with the architecture documentation.

The `reset_creatures` method iterates through all creatures of both the player and the opponent, resetting their HP to their maximum value. A message is also shown to the player to inform them that all creatures have been restored to full health.

This solution maintains the separation of concerns, keeping the models as pure data schemas and handling the game logic within the scene. It also stays within the capabilities of the engine by using the provided methods for scene transitions and text display.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "ac6fcdcf-57c4-4f3e-bf7c-a32997730f91", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
