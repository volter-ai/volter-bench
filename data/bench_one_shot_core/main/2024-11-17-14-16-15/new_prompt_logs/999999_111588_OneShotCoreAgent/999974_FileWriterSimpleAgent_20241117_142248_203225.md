Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation carefully:

1. First, I'll create the data models in `models.py`:
- Skill (base damage, type, physical/special)
- Creature (stats, type, skills collection)
- Player (creatures collection, active creature)

2. Create JSON files in content/ for each model:
- skill.json (Tackle, Fireball, Lick)
- creature.json (Bubwool, Scizard, Dumbird)
- player.json (Default Player, Basic Opponent)

3. Create the scenes:
- MainMenuScene (already exists but needs updating)
- MainGameScene (complex battle logic)

4. Create tests for both scenes using random mode testing

Let me implement each file:

# Excerpt ID: ba3791ac-d6df-481e-b83e-6096e44f7c63
```python main_game/models.py
from __future__ import annotations
from typing import List, Optional
from mini_game_engine.engine.lib import AbstractThing, AbstractPlayer, Collection

class Skill(AbstractThing):
    category: str = "Skill"
    skill_type: str  # normal, fire, water, leaf
    is_physical: bool
    base_damage: int

class Creature(AbstractThing):
    category: str = "Creature"
    creature_type: str  # normal, fire, water, leaf
    hp: int
    max_hp: int 
    attack: int
    defense: int
    sp_attack: int
    sp_defense: int
    speed: int
    skills: List[Skill]

class Player(AbstractPlayer):
    category: str = "Player"
    creatures: List[Creature]
    active_creature: Optional[Creature] = None
```

# Excerpt ID: 05b6653b-0b26-4f62-a21f-891b483efa6e
```json main_game/content/skill.json
{
  "prototypes": {
    "tackle": {
      "display_name": "Tackle",
      "description": "Throw yourself at a foe, dealing damage.",
      "skill_type": "normal",
      "is_physical": true,
      "base_damage": 7
    },
    "fireball": {
      "display_name": "Fireball", 
      "description": "Throw fire at a foe, dealing damage.",
      "skill_type": "fire",
      "is_physical": false,
      "base_damage": 5
    },
    "lick": {
      "display_name": "Lick",
      "description": "Lick a foe with a wet tongue, dealing damage.",
      "skill_type": "water", 
      "is_physical": true,
      "base_damage": 5
    }
  }
}
```

# Excerpt ID: 2bc30139-c2f6-4b6c-91f3-7bb186d89abf
```json main_game/content/creature.json
{
  "prototypes": {
    "bubwool": {
      "display_name": "Bubwool",
      "description": "A water creature",
      "creature_type": "water",
      "hp": 32,
      "max_hp": 32,
      "attack": 11,
      "defense": 10,
      "sp_attack": 12,
      "sp_defense": 12,
      "speed": 13,
      "skills": ["tackle", "lick"]
    },
    "scizard": {
      "display_name": "Scizard",
      "description": "A fire creature",
      "creature_type": "fire", 
      "hp": 40,
      "max_hp": 40,
      "attack": 11,
      "defense": 13,
      "sp_attack": 11,
      "sp_defense": 13,
      "speed": 11,
      "skills": ["tackle", "fireball"]
    },
    "dumbird": {
      "display_name": "Dumbird",
      "description": "A normal creature",
      "creature_type": "normal",
      "hp": 17,
      "max_hp": 17,
      "attack": 7,
      "defense": 9,
      "sp_attack": 7,
      "sp_defense": 4,
      "speed": 17,
      "skills": ["tackle"]
    }
  }
}
```

# Excerpt ID: c91c6eb2-e802-4767-a041-80385b112e46
```json main_game/content/player.json
{
  "prototypes": {
    "default_player": {
      "display_name": "Default Player",
      "description": "The human player",
      "creatures": ["bubwool", "dumbird"]
    },
    "basic_opponent": {
      "display_name": "Basic Opponent",
      "description": "A basic bot opponent",
      "creatures": ["scizard", "dumbird"]
    }
  }
}
```

# Excerpt ID: 8445c3e2-9c7e-4049-9888-5aedc943a832
```python main_game/scenes/main_menu_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button
from main_game.scenes.main_game_scene import MainGameScene

class MainMenuScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self._app.register_scene("MainGameScene", MainGameScene)

    def __str__(self):
        return """=== Creature Battler ===
Welcome! Choose an option:
> Play
> Quit
"""

    def run(self):
        play_button = Button("Play")
        quit_button = Button("Quit")
        
        choice = self._wait_for_choice(self.player, [play_button, quit_button])
        
        if choice == play_button:
            self._transition_to_scene("MainGameScene")
        else:
            self._quit_whole_game()
```

# Excerpt ID: 9ca68f9f-3b1d-4b15-b6c8-6a7620c2f274
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Creature
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = self._app.create_bot("basic_opponent")
        
        # Initialize creatures
        for p in [self.player, self.bot]:
            for c in p.creatures:
                c.hp = c.max_hp
            p.active_creature = p.creatures[0]

    def __str__(self):
        p_creature = self.player.active_creature
        b_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {p_creature.display_name}: {p_creature.hp}/{p_creature.max_hp} HP
Foe's {b_creature.display_name}: {b_creature.hp}/{b_creature.max_hp} HP

Your creatures: {[c.display_name for c in self.player.creatures]}
Foe's creatures: {[c.display_name for c in self.bot.creatures]}
"""

    def run(self):
        while True:
            # Show current state
            self._show_text(self.player, str(self))
            
            # Get player action
            player_action = self.get_player_action(self.player)
            if not player_action:
                return
                
            # Get bot action
            bot_action = self.get_player_action(self.bot)
            if not bot_action:
                return
                
            # Resolve actions
            self.resolve_actions(player_action, bot_action)
            
            # Check for battle end
            if self.check_battle_end():
                return

    def get_player_action(self, player):
        # First level menu
        attack = Button("Attack")
        swap = Button("Swap")
        choice = self._wait_for_choice(player, [attack, swap])
        
        if choice == attack:
            # Show skills
            skills = [SelectThing(s) for s in player.active_creature.skills]
            return self._wait_for_choice(player, skills)
        else:
            # Show available creatures
            available = [c for c in player.creatures if c != player.active_creature and c.hp > 0]
            if not available:
                return None
            creatures = [SelectThing(c) for c in available]
            return self._wait_for_choice(player, creatures)

    def resolve_actions(self, p_action, b_action):
        # Determine order
        first = self.player
        second = self.bot
        first_action = p_action
        second_action = b_action
        
        if isinstance(p_action.thing, Creature) and isinstance(b_action.thing, Creature):
            # Both swapping
            self.execute_swap(self.player, p_action.thing)
            self.execute_swap(self.bot, b_action.thing)
            return
            
        if isinstance(b_action.thing, Creature):
            # Bot swapping
            self.execute_swap(self.bot, b_action.thing)
            self.execute_attack(self.player, p_action.thing, self.bot)
            return
            
        if isinstance(p_action.thing, Creature):
            # Player swapping
            self.execute_swap(self.player, p_action.thing)
            self.execute_attack(self.bot, b_action.thing, self.player)
            return
            
        # Both attacking - check speed
        if self.bot.active_creature.speed > self.player.active_creature.speed:
            first, second = self.bot, self.player
            first_action, second_action = b_action, p_action
        elif self.bot.active_creature.speed < self.player.active_creature.speed:
            first, second = self.player, self.bot
            first_action, second_action = p_action, b_action
        else:
            # Random on speed tie
            if random.random() < 0.5:
                first, second = self.bot, self.player
                first_action, second_action = b_action, p_action
                
        self.execute_attack(first, first_action.thing, second)
        if second.active_creature.hp > 0:
            self.execute_attack(second, second_action.thing, first)

    def execute_attack(self, attacker, skill, defender):
        # Calculate damage
        raw_damage = 0
        if skill.is_physical:
            raw_damage = attacker.active_creature.attack + skill.base_damage - defender.active_creature.defense
        else:
            raw_damage = (attacker.active_creature.sp_attack / defender.active_creature.sp_defense) * skill.base_damage
            
        # Type effectiveness
        factor = self.get_type_factor(skill.skill_type, defender.active_creature.creature_type)
        
        # Apply damage
        final_damage = int(raw_damage * factor)
        defender.active_creature.hp = max(0, defender.active_creature.hp - final_damage)
        
        self._show_text(self.player, 
            f"{attacker.active_creature.display_name} used {skill.display_name}! "
            f"Dealt {final_damage} damage to {defender.active_creature.display_name}")
        
        # Force swap if knocked out
        if defender.active_creature.hp == 0:
            self.force_swap(defender)

    def execute_swap(self, player, new_creature):
        old = player.active_creature
        player.active_creature = new_creature
        self._show_text(self.player, f"{player.display_name} swapped {old.display_name} for {new_creature.display_name}!")

    def force_swap(self, player):
        available = [c for c in player.creatures if c.hp > 0]
        if not available:
            return False
            
        if len(available) == 1:
            self.execute_swap(player, available[0])
        else:
            choices = [SelectThing(c) for c in available]
            choice = self._wait_for_choice(player, choices)
            self.execute_swap(player, choice.thing)
        return True

    def check_battle_end(self):
        p_alive = any(c.hp > 0 for c in self.player.creatures)
        b_alive = any(c.hp > 0 for c in self.bot.creatures)
        
        if not p_alive or not b_alive:
            winner = self.player if p_alive else self.bot
            self._show_text(self.player, f"{winner.display_name} wins!")
            return True
        return False

    def get_type_factor(self, skill_type, creature_type):
        if skill_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(skill_type, {}).get(creature_type, 1.0)
```

# Excerpt ID: fbd3ed96-82a7-410d-86d5-649a3d484a39
```python main_game/tests/test_main_game_scene.py
import pytest
from unittest.mock import patch
from mini_game_engine.engine.lib import HumanListener, RandomModeGracefulExit
from main_game.scenes.main_game_scene import MainGameScene
from main_game.main import App

class TestMainGameSceneRandomRun:
    @pytest.fixture
    def app(self):
        return App()

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f"starting random run iteration {i}")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # Need more moves for complex battle scene

            player = app.create_player(f"player_{i}")
            scene = MainGameScene(app, player)

            class TransitionFromScene(Exception):
                pass

            def exit_scene(*args, **kwargs):
                raise TransitionFromScene()

            with patch.object(MainGameScene, '_transition_to_scene', side_effect=exit_scene) as mock_transition:
                try:
                    scene.run()
                except TransitionFromScene:
                    print(f"exiting target scene `MainGameScene` so ending run {i}")
                except RandomModeGracefulExit:
                    print(f"`random_mode_counter` reached 0 and the game did not crash. Ending run {i} gracefully")
                finally:
                    mock_transition.reset_mock()
```

This implementation follows all guidelines:
1. Models are pure data schemas inheriting from AbstractThing/AbstractPlayer
2. JSON files define all prototypes
3. Scenes handle all game logic
4. Tests use random mode testing
5. Scene strings show all relevant information
6. Models reference other models directly
7. Models are in dependency order
8. All entity creation uses from_prototype_id
9. Bot and player are treated identically

The game implements the full creature battle system with:
- Turn-based combat
- Physical/Special attacks
- Type effectiveness
- Speed-based turn order
- Creature swapping
- HP tracking and battle end conditions

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
