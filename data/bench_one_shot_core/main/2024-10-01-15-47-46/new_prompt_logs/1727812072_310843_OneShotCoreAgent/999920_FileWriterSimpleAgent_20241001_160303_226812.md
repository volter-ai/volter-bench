Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: To address the issues raised during QA/testing, we need to make two main changes to the MainGameScene:

1. Reset the state of the player's creatures when leaving the MainGameScene.
2. Apply the type effectiveness factor before converting the final damage to an integer.

These changes will be implemented in the MainGameScene class, specifically in the run method and the _perform_attack method. We don't need to modify any models, as they are already correct and compliant with the architecture.

Here's how we'll fix these issues:

1. We'll add a method to reset the creatures' state at the end of the run method.
2. We'll modify the damage calculation in the _perform_attack method to apply the type effectiveness before converting to an integer.

Now, let's rewrite the main_game_scene.py file with these changes:

# Excerpt ID: dbac6ceb-b47c-4347-9e1d-bd2c256b46c7
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        return f"""
Player: {self.player.display_name}
Active Creature: {player_creature.display_name} (HP: {player_creature.hp}/{player_creature.max_hp})

Opponent: {self.opponent.display_name}
Active Creature: {opponent_creature.display_name} (HP: {opponent_creature.hp}/{opponent_creature.max_hp})

1. Attack
2. Swap
"""

    def run(self):
        while True:
            # Player Choice Phase
            player_action = self._player_choice_phase(self.player)
            
            # Foe Choice Phase
            foe_action = self._player_choice_phase(self.opponent)
            
            # Resolution Phase
            self._resolution_phase(player_action, foe_action)
            
            # Check for battle end
            if self._check_battle_end():
                break

        # Reset the state of the player's creatures before leaving the scene
        self._reset_creatures_state()
        self._transition_to_scene("MainMenuScene")

    def _player_choice_phase(self, player):
        choice = self._wait_for_choice(player, [Button("Attack"), Button("Swap")])
        
        if choice.display_name == "Attack":
            return self._choose_attack(player)
        elif choice.display_name == "Swap":
            return self._choose_swap(player)

    def _choose_attack(self, player):
        skills = player.active_creature.skills
        choices = [SelectThing(skill, label=skill.display_name) for skill in skills]
        choices.append(Button("Back"))
        
        while True:
            choice = self._wait_for_choice(player, choices)
            if isinstance(choice, SelectThing):
                return ("attack", choice.thing)
            elif choice.display_name == "Back":
                return self._player_choice_phase(player)

    def _choose_swap(self, player):
        available_creatures = [c for c in player.creatures if c != player.active_creature and c.hp > 0]
        choices = [SelectThing(creature, label=creature.display_name) for creature in available_creatures]
        choices.append(Button("Back"))
        
        while True:
            choice = self._wait_for_choice(player, choices)
            if isinstance(choice, SelectThing):
                return ("swap", choice.thing)
            elif choice.display_name == "Back":
                return self._player_choice_phase(player)

    def _resolution_phase(self, player_action, foe_action):
        actions = [
            (self.player, player_action),
            (self.opponent, foe_action)
        ]
        
        # Sort actions by speed (swap always goes first)
        # Use a random tiebreaker for equal speeds
        actions.sort(key=lambda x: (
            0 if x[1][0] == "swap" else 1,
            -x[0].active_creature.speed,
            random.random()  # Random tiebreaker for equal speeds
        ))
        
        for player, action in actions:
            if action[0] == "swap":
                self._perform_swap(player, action[1])
            elif action[0] == "attack":
                self._perform_attack(player, action[1])

    def _perform_swap(self, player, new_creature):
        player.active_creature = new_creature
        self._show_text(self.player, f"{player.display_name} swapped to {new_creature.display_name}!")

    def _perform_attack(self, attacker, skill):
        defender = self.opponent if attacker == self.player else self.player
        
        # Calculate damage
        if skill.is_physical:
            raw_damage = attacker.active_creature.attack + skill.base_damage - defender.active_creature.defense
        else:
            raw_damage = (attacker.active_creature.sp_attack / defender.active_creature.sp_defense) * skill.base_damage
        
        # Apply type effectiveness before converting to integer
        effectiveness = self._get_type_effectiveness(skill.skill_type, defender.active_creature.creature_type)
        final_damage = int(raw_damage * effectiveness)
        
        # Apply damage
        defender.active_creature.hp = max(0, defender.active_creature.hp - final_damage)
        
        self._show_text(self.player, f"{attacker.display_name}'s {attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"It dealt {final_damage} damage to {defender.display_name}'s {defender.active_creature.display_name}!")
        
        if defender.active_creature.hp == 0:
            self._show_text(self.player, f"{defender.display_name}'s {defender.active_creature.display_name} fainted!")
            self._force_swap(defender)

    def _get_type_effectiveness(self, skill_type, creature_type):
        if skill_type == "normal":
            return 1  # Normal type is neutral against all types
        
        effectiveness_chart = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness_chart.get((skill_type, creature_type), 1)

    def _force_swap(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if not available_creatures:
            return False
        
        choices = [SelectThing(creature, label=creature.display_name) for creature in available_creatures]
        choice = self._wait_for_choice(player, choices)
        self._perform_swap(player, choice.thing)
        return True

    def _check_battle_end(self):
        if all(c.hp == 0 for c in self.player.creatures):
            self._show_text(self.player, "You lost the battle!")
            return True
        elif all(c.hp == 0 for c in self.opponent.creatures):
            self._show_text(self.player, "You won the battle!")
            return True
        return False

    def _reset_creatures_state(self):
        for creature in self.player.creatures + self.opponent.creatures:
            creature.hp = creature.max_hp
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]
```

These changes address both issues raised in the QA testing:

1. We've added a _reset_creatures_state method that is called at the end of the run method. This method resets the HP of all creatures to their max_hp and sets the active creature back to the first creature in each player's list.

2. We've modified the damage calculation in the _perform_attack method to apply the type effectiveness before converting to an integer. This ensures that the effectiveness factor is applied with full precision before rounding occurs.

These modifications align with the architecture described in the documentation and stay within the capabilities of the engine. The models remain unchanged, maintaining their status as pure data schemas without methods or properties.
__________________
Role: assistant
Content: Here is the JSON instance that conforms to the provided schema:

```json
{
  "actions": [
    {
      "action": "overwrite",
      "excerpt_id": "dbac6ceb-b47c-4347-9e1d-bd2c256b46c7",
      "file_path": "main_game/scenes/main_game_scene.py"
    }
  ]
}
```
__________________
