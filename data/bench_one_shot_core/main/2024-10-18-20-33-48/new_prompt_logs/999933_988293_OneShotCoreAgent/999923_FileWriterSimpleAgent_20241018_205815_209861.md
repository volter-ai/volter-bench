Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for bringing this issue to my attention. You're right that I missed implementing the speed-based turn order in the resolution phase. I'll address this issue as follows:

1. Description of the fix:
   We'll modify the `MainGameScene` to implement the speed-based turn order in the resolution phase. Instead of having separate player and opponent turns, we'll create a single turn method that determines the order based on the creatures' speed stats. If the speeds are equal, we'll randomly decide who goes first.

2. Rewriting the `main_game/scenes/main_game_scene.py` file:

# Excerpt ID: c17775a0-3027-41bd-a7ca-169603661a7b
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Available skills:
{self._format_skills(self.player_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name}" for skill in skills])

    def run(self):
        self._show_text(self.player, "A wild opponent appears!")
        while True:
            if self._is_battle_over():
                self._handle_battle_end()
                break
            self._execute_turn()

    def _execute_turn(self):
        player_skill = self._get_player_skill()
        opponent_skill = self._get_opponent_skill()

        first, second = self._determine_turn_order(
            (self.player_creature, player_skill),
            (self.opponent_creature, opponent_skill)
        )

        self._execute_skill(*first)
        if not self._is_battle_over():
            self._execute_skill(*second)

    def _get_player_skill(self):
        self._show_text(self.player, "Your turn to choose a skill!")
        skill_choices = [SelectThing(skill) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, skill_choices)
        return choice.thing

    def _get_opponent_skill(self):
        self._show_text(self.player, f"{self.opponent.display_name}'s turn to choose a skill!")
        skill_choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, skill_choices)
        return choice.thing

    def _determine_turn_order(self, player_tuple, opponent_tuple):
        player_creature, player_skill = player_tuple
        opponent_creature, opponent_skill = opponent_tuple

        if player_creature.speed > opponent_creature.speed:
            return player_tuple, opponent_tuple
        elif player_creature.speed < opponent_creature.speed:
            return opponent_tuple, player_tuple
        else:
            return random.sample([player_tuple, opponent_tuple], 2)

    def _execute_skill(self, attacker: Creature, skill: Skill):
        defender = self.opponent_creature if attacker == self.player_creature else self.player_creature
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        type_factor = self._get_type_factor(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_factor)
        defender.hp = max(0, defender.hp - final_damage)

        self._show_text(self.player, f"{attacker.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender.display_name} took {final_damage} damage!")

    def _get_type_factor(self, skill_type: str, defender_type: str) -> float:
        if skill_type == "normal":
            return 1.0
        elif skill_type == "fire" and defender_type == "leaf":
            return 2.0
        elif skill_type == "water" and defender_type == "fire":
            return 2.0
        elif skill_type == "leaf" and defender_type == "water":
            return 2.0
        elif skill_type == "fire" and defender_type == "water":
            return 0.5
        elif skill_type == "water" and defender_type == "leaf":
            return 0.5
        elif skill_type == "leaf" and defender_type == "fire":
            return 0.5
        else:
            return 1.0

    def _is_battle_over(self) -> bool:
        return self.player_creature.hp <= 0 or self.opponent_creature.hp <= 0

    def _handle_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, "You lost the battle!")
        else:
            self._show_text(self.player, "You won the battle!")
        
        self._show_text(self.player, "Returning to main menu...")
        self._transition_to_scene("MainMenuScene")
```

This implementation now correctly handles the speed-based turn order as described in the architecture. The main changes are:

1. Replaced separate player and opponent turns with a single `_execute_turn` method.
2. Added `_determine_turn_order` method to decide which creature acts first based on speed.
3. Modified the battle loop to use the new turn execution method.

These changes ensure that the creature with the higher speed stat acts first, and in case of a tie, the order is randomly determined. This aligns with the specified architecture while maintaining the existing game flow and logic.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "c17775a0-3027-41bd-a7ca-169603661a7b", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
