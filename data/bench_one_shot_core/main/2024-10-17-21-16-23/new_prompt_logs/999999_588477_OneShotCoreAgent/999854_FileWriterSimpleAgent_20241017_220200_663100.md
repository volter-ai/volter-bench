Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issues raised during QA/testing, we need to address two main problems:

1. The `MainGameScene` is not exiting properly when the game ends.
2. The scene is not transitioning or quitting the game when all creatures have fainted.

Here's how we'll fix these issues:

1. We'll modify the `MainGameScene` to call `self._quit_whole_game()` when the battle ends (i.e., when all creatures of either player have fainted).
2. We'll update the `run` method to include a loop that continues until the battle ends.
3. We'll modify the `check_battle_end` method to return a boolean indicating whether the battle has ended, and if so, whether the player won or lost.

These changes will ensure that the scene exits properly and follows the engine's architecture. Here's the rewritten `main_game_scene.py` file with the proposed solution:

# Excerpt ID: e7a830d3-5d11-497a-bd9d-7758e948d2a0
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.initialize_battle()

    def initialize_battle(self):
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}: {self.player.active_creature.display_name} (HP: {self.player.active_creature.hp}/{self.player.active_creature.max_hp})
{self.opponent.display_name}: {self.opponent.active_creature.display_name} (HP: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp})

> Attack
> Swap
"""

    def run(self):
        while True:
            self.player_turn()
            battle_end, player_won = self.check_battle_end()
            if battle_end:
                self.end_battle(player_won)
                return

            self.opponent_turn()
            battle_end, player_won = self.check_battle_end()
            if battle_end:
                self.end_battle(player_won)
                return

    def player_turn(self):
        self._show_text(self.player, f"It's your turn, {self.player.display_name}!")
        action = self.get_player_action(self.player)
        if action:
            self.execute_action(self.player, self.opponent, action)

    def opponent_turn(self):
        self._show_text(self.player, f"It's {self.opponent.display_name}'s turn!")
        action = self.get_player_action(self.opponent)
        if action:
            self.execute_action(self.opponent, self.player, action)

    def get_player_action(self, acting_player):
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        choices = [attack_button, swap_button]
        choice = self._wait_for_choice(acting_player, choices)

        if choice == attack_button:
            return self.get_attack_action(acting_player)
        elif choice == swap_button:
            return self.get_swap_action(acting_player)

    def get_attack_action(self, acting_player):
        skill_choices = [SelectThing(skill) for skill in acting_player.active_creature.skills]
        return self._wait_for_choice(acting_player, skill_choices)

    def get_swap_action(self, acting_player):
        available_creatures = [creature for creature in acting_player.creatures if creature != acting_player.active_creature and creature.hp > 0]
        if not available_creatures:
            self._show_text(acting_player, f"No available creatures to swap to!")
            return None
        creature_choices = [SelectThing(creature) for creature in available_creatures]
        return self._wait_for_choice(acting_player, creature_choices)

    def execute_action(self, acting_player, defending_player, action):
        if isinstance(action.thing, Skill):
            self.execute_attack(acting_player, defending_player, action.thing)
        elif isinstance(action.thing, Creature):
            self.execute_swap(acting_player, action.thing)

    def execute_attack(self, attacker, defender, skill):
        damage = self.calculate_damage(attacker.active_creature, defender.active_creature, skill)
        defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
        self._show_text(self.player, f"{attacker.active_creature.display_name} used {skill.display_name} and dealt {damage} damage to {defender.active_creature.display_name}!")

    def execute_swap(self, player, new_creature):
        player.active_creature = new_creature
        self._show_text(self.player, f"{player.display_name} swapped to {new_creature.display_name}!")

    def calculate_damage(self, attacker, defender, skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_effectiveness)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def get_type_effectiveness(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def check_battle_end(self):
        if all(creature.hp == 0 for creature in self.player.creatures):
            self._show_text(self.player, f"All your creatures have fainted. {self.opponent.display_name} wins!")
            return True, False
        elif all(creature.hp == 0 for creature in self.opponent.creatures):
            self._show_text(self.player, f"All opponent's creatures have fainted. You win!")
            return True, True
        elif self.player.active_creature.hp == 0:
            self.force_swap(self.player)
        elif self.opponent.active_creature.hp == 0:
            self.force_swap(self.opponent)
        return False, False

    def force_swap(self, player):
        available_creatures = [creature for creature in player.creatures if creature.hp > 0]
        if available_creatures:
            creature_choices = [SelectThing(creature) for creature in available_creatures]
            new_creature = self._wait_for_choice(player, creature_choices).thing
            player.active_creature = new_creature
            self._show_text(self.player, f"{player.display_name} was forced to swap to {new_creature.display_name}!")
        else:
            self._show_text(self.player, f"{player.display_name} has no more creatures available!")

    def end_battle(self, player_won):
        if player_won:
            self._show_text(self.player, "Congratulations! You've won the battle!")
        else:
            self._show_text(self.player, "You've lost the battle. Better luck next time!")
        self._quit_whole_game()
```

These changes address the issues by:

1. Modifying the `run` method to include a loop that continues until the battle ends.
2. Updating the `check_battle_end` method to return a tuple indicating whether the battle has ended and if the player won.
3. Adding an `end_battle` method that displays the final result and calls `self._quit_whole_game()` to properly exit the scene and end the game.

These modifications ensure that the scene exits properly when the battle ends, either by winning or losing, and follows the engine's architecture by using the `_quit_whole_game()` method to signal the end of the game. This should resolve the issues raised during QA/testing while staying within the capabilities of the engine and maintaining the existing model structure.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "e7a830d3-5d11-497a-bd9d-7758e948d2a0", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
