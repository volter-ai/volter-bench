Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The error occurs because MainGameScene's run() method ends without properly transitioning to another scene or quitting the game. When the battle ends (win or lose), we need to either:
- Transition back to MainMenuScene, or 
- Call quit_whole_game()

The fix should:
- Modify check_battle_end() to not just return True/False
- After showing the win/loss message, properly exit using the engine's transition methods
- Keep all game logic in scenes
- Maintain pure data models

2. Here's the fixed MainGameScene:

# Excerpt ID: a1c673c0-38fe-460a-afc4-674857f14702
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random

TYPE_EFFECTIVENESS = {
    "fire": {"leaf": 2.0, "water": 0.5},
    "water": {"fire": 2.0, "leaf": 0.5},
    "leaf": {"water": 2.0, "fire": 0.5},
    "normal": {}
}

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        
        # Initialize creatures
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]
        
        for creature in self.player.creatures + self.opponent.creatures:
            creature.hp = creature.max_hp

    def __str__(self):
        return f"""=== Battle ===
{self.player.display_name}'s {self.player.active_creature.display_name}: {self.player.active_creature.hp}/{self.player.active_creature.max_hp} HP
{self.opponent.display_name}'s {self.opponent.active_creature.display_name}: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp} HP

> Attack
{"> Swap" if self.has_valid_swap_targets(self.player) else ""}"""

    def run(self):
        while True:
            # Player turn
            player_action = self.get_player_action(self.player)
            opponent_action = self.get_player_action(self.opponent)
            
            # Resolve actions
            self.resolve_turn(player_action, opponent_action)
            
            # Check for battle end
            if self.check_battle_end():
                # After showing win/loss message, return to main menu
                self._transition_to_scene("MainMenuScene")
                return

    def has_valid_swap_targets(self, player):
        return any(c.hp > 0 and c != player.active_creature for c in player.creatures)

    def get_player_action(self, player):
        choices = [Button("Attack")]
        if self.has_valid_swap_targets(player):
            choices.append(Button("Swap"))
        
        choice = self._wait_for_choice(player, choices)
        
        if choice.display_name == "Attack":
            choices = [SelectThing(skill) for skill in player.active_creature.skills]
            return ("attack", self._wait_for_choice(player, choices).thing)
        else:
            valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
            choices = [SelectThing(creature) for creature in valid_creatures]
            return ("swap", self._wait_for_choice(player, choices).thing)

    def resolve_turn(self, player_action, opponent_action):
        # Handle swaps first
        if player_action[0] == "swap":
            self.player.active_creature = player_action[1]
        if opponent_action[0] == "swap":
            self.opponent.active_creature = opponent_action[1]
            
        # Determine order for attacks
        if player_action[0] == "attack" and opponent_action[0] == "attack":
            if self.player.active_creature.speed > self.opponent.active_creature.speed:
                first, second = (self.player, player_action[1]), (self.opponent, opponent_action[1])
            elif self.player.active_creature.speed < self.opponent.active_creature.speed:
                first, second = (self.opponent, opponent_action[1]), (self.player, player_action[1])
            else:
                actors = [(self.player, player_action[1]), (self.opponent, opponent_action[1])]
                random.shuffle(actors)
                first, second = actors
                
            self.execute_attack(first[0], first[1])
            if self.opponent.active_creature.hp > 0:
                self.execute_attack(second[0], second[1])

    def execute_attack(self, attacker, skill):
        if attacker == self.player:
            defender = self.opponent
        else:
            defender = self.player
            
        # Calculate damage
        if skill.is_physical:
            raw_damage = attacker.active_creature.attack + skill.base_damage - defender.active_creature.defense
        else:
            raw_damage = (attacker.active_creature.sp_attack / defender.active_creature.sp_defense) * skill.base_damage
            
        # Apply type effectiveness
        effectiveness = TYPE_EFFECTIVENESS.get(skill.skill_type, {}).get(defender.active_creature.creature_type, 1.0)
        final_damage = int(raw_damage * effectiveness)
        
        defender.active_creature.hp = max(0, defender.active_creature.hp - final_damage)
        
        self._show_text(self.player, f"{attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"Dealt {final_damage} damage!")

        # Force swap if active creature is knocked out
        if defender.active_creature.hp == 0:
            valid_creatures = [c for c in defender.creatures if c.hp > 0]
            if valid_creatures:
                choices = [SelectThing(creature) for creature in valid_creatures]
                new_creature = self._wait_for_choice(defender, choices).thing
                defender.active_creature = new_creature
                self._show_text(self.player, f"{defender.display_name} sent out {new_creature.display_name}!")

    def check_battle_end(self):
        def has_available_creatures(player):
            return any(c.hp > 0 for c in player.creatures)
            
        if not has_available_creatures(self.player):
            self._show_text(self.player, "You lost the battle!")
            return True
        elif not has_available_creatures(self.opponent):
            self._show_text(self.player, "You won the battle!")
            return True
            
        return False
```

The key changes are:
1. Added proper scene transition after battle ends
2. When check_battle_end() returns True, we now transition back to MainMenuScene
3. Maintained all game logic within the scene
4. Kept models as pure data schemas
5. Used proper engine transition methods to handle scene flow

This should resolve the scene termination error while maintaining proper architecture and game mechanics.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
