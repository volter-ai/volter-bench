Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issue, we need to modify the `MainGameScene` class in the `main_game_scene.py` file. The problem is that the scene is terminating without calling `_transition_to_scene` or `_quit_whole_game`. We'll update the `run` method to properly end the game and transition back to the main menu when the battle is over.

Here's how we'll fix it:

1. After the battle ends (when one player loses all their creatures), we'll show the result message to both players.
2. We'll add a short delay to allow players to see the result.
3. We'll reset the creatures' HP to their max values.
4. Finally, we'll transition back to the `MainMenuScene`.

Here's the rewritten `main_game_scene.py` file with the proposed solution:

# Excerpt ID: 003bceb3-9fd8-4f21-81c9-70a99e77d694
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random
import time

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.turn_queue = []

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        return f"""===Battle===
{self.player.display_name}'s {player_creature.display_name}: HP {player_creature.hp}/{player_creature.max_hp}
{self.opponent.display_name}'s {opponent_creature.display_name}: HP {opponent_creature.hp}/{opponent_creature.max_hp}

> Attack
> Swap
"""

    def run(self):
        self._show_text(self.player, "Battle Start!")
        self._show_text(self.opponent, "Battle Start!")
        
        while True:
            self.player_turn()
            self.opponent_turn()
            self.resolve_turn()
            
            if self.check_battle_end():
                break

        # Show the final result
        if all(creature.hp == 0 for creature in self.player.creatures):
            self._show_text(self.player, "You lost the battle!")
            self._show_text(self.opponent, "You won the battle!")
        else:
            self._show_text(self.player, "You won the battle!")
            self._show_text(self.opponent, "You lost the battle!")

        # Add a short delay to allow players to see the result
        time.sleep(2)

        # Reset creatures' HP
        self.reset_creatures()

        # Transition back to the main menu
        self._transition_to_scene("MainMenuScene")

    def player_turn(self):
        while True:
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choice = self._wait_for_choice(self.player, [attack_button, swap_button])

            if choice == attack_button:
                skill_choices = [SelectThing(skill) for skill in self.player.active_creature.skills]
                skill_choice = self._wait_for_choice(self.player, skill_choices)
                self.turn_queue.append(("attack", self.player, skill_choice.thing))
                break
            elif choice == swap_button:
                creature_choices = [SelectThing(creature) for creature in self.player.creatures if creature != self.player.active_creature and creature.hp > 0]
                if creature_choices:
                    creature_choice = self._wait_for_choice(self.player, creature_choices)
                    self.turn_queue.append(("swap", self.player, creature_choice.thing))
                    break
                else:
                    self._show_text(self.player, "No other creatures available to swap!")

    def opponent_turn(self):
        choices = ["attack", "swap"]
        choice = random.choice(choices)

        if choice == "attack":
            skill = random.choice(self.opponent.active_creature.skills)
            self.turn_queue.append(("attack", self.opponent, skill))
        elif choice == "swap":
            available_creatures = [c for c in self.opponent.creatures if c != self.opponent.active_creature and c.hp > 0]
            if available_creatures:
                creature = random.choice(available_creatures)
                self.turn_queue.append(("swap", self.opponent, creature))
            else:
                skill = random.choice(self.opponent.active_creature.skills)
                self.turn_queue.append(("attack", self.opponent, skill))

    def resolve_turn(self):
        self.turn_queue.sort(key=lambda x: (-1 if x[0] == "swap" else x[1].active_creature.speed), reverse=True)

        for action, player, target in self.turn_queue:
            opponent = self.opponent if player == self.player else self.player
            if action == "swap":
                player.active_creature = target
                self._show_text(player, f"Swapped to {target.display_name}!")
                self._show_text(opponent, f"Opponent swapped to {target.display_name}!")
            elif action == "attack":
                damage = self.calculate_damage(player.active_creature, opponent.active_creature, target)
                opponent.active_creature.hp = max(0, opponent.active_creature.hp - damage)
                self._show_text(player, f"{player.active_creature.display_name} used {target.display_name}!")
                self._show_text(opponent, f"Opponent's {player.active_creature.display_name} used {target.display_name}!")
                self._show_text(player, f"Dealt {damage} damage!")
                self._show_text(opponent, f"Took {damage} damage!")

                if opponent.active_creature.hp == 0:
                    self._show_text(player, f"Opponent's {opponent.active_creature.display_name} fainted!")
                    self._show_text(opponent, f"{opponent.active_creature.display_name} fainted!")
                    self.force_swap(opponent)

        self.turn_queue.clear()

    def calculate_damage(self, attacker: Creature, defender: Creature, skill: Skill) -> int:
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_effectiveness)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def get_type_effectiveness(self, skill_type: str, defender_type: str) -> float:
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def force_swap(self, player: Player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if available_creatures:
            choices = [SelectThing(creature) for creature in available_creatures]
            choice = self._wait_for_choice(player, choices)
            player.active_creature = choice.thing
            self._show_text(player, f"Swapped to {player.active_creature.display_name}!")
            self._show_text(self.opponent if player == self.player else self.player, f"Opponent swapped to {player.active_creature.display_name}!")

    def check_battle_end(self) -> bool:
        return all(creature.hp == 0 for creature in self.player.creatures) or all(creature.hp == 0 for creature in self.opponent.creatures)

    def reset_creatures(self):
        for player in [self.player, self.opponent]:
            for creature in player.creatures:
                creature.hp = creature.max_hp
```

This solution addresses the issue by properly ending the game and transitioning back to the main menu. It also resets the creatures' HP to their maximum values, ensuring that the game can be played multiple times without issues. The `time.sleep(2)` call adds a short delay to allow players to see the battle result before transitioning back to the main menu.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "003bceb3-9fd8-4f21-81c9-70a99e77d694", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
