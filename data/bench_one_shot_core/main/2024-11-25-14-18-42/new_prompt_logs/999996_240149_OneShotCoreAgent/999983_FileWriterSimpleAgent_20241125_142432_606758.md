Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The error occurs because MainGameScene ends without properly transitioning or quitting. When the battle ends (either win or lose), we just break from the loop instead of properly ending the scene.

According to the engine requirements, a scene must either:
- Transition to another scene using `_transition_to_scene()`
- End the game using `_quit_whole_game()`

Solution:
I'll modify MainGameScene to properly end the game when the battle is over by calling `_quit_whole_game()` after showing the win/lose message. This makes sense architecturally since this is a simple game where one battle is the complete game experience.

2. Here's the fixed MainGameScene:

# Excerpt ID: cbb856cb-2d87-4f81-95ec-fb106f8eec4e
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""=== Battle ===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available Skills:
{chr(10).join([f"> {skill.display_name} ({skill.skill_type} type)" for skill in self.player_creature.skills])}
"""

    def run(self):
        while True:
            # Player phase
            player_skill = self._handle_player_turn()
            
            # Opponent phase  
            opponent_skill = self._handle_opponent_turn()

            # Resolution phase
            self._resolve_turn(player_skill, opponent_skill)

            # Check win condition
            if self._check_battle_end():
                self._quit_whole_game()  # Properly end the game after battle conclusion

    def _handle_player_turn(self):
        self._show_text(self.player, "Choose your skill!")
        choices = [SelectThing(skill) for skill in self.player_creature.skills]
        return self._wait_for_choice(self.player, choices).thing

    def _handle_opponent_turn(self):
        choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
        return self._wait_for_choice(self.opponent, choices).thing

    def _calculate_damage(self, attacker, defender, skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        
        # Type effectiveness
        multiplier = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf": multiplier = 2.0
            elif defender.creature_type == "water": multiplier = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire": multiplier = 2.0
            elif defender.creature_type == "leaf": multiplier = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water": multiplier = 2.0
            elif defender.creature_type == "fire": multiplier = 0.5

        return int(raw_damage * multiplier)

    def _resolve_turn(self, player_skill, opponent_skill):
        # Determine order
        first = self.player
        second = self.opponent
        first_skill = player_skill
        second_skill = opponent_skill
        
        if self.opponent_creature.speed > self.player_creature.speed:
            first, second = second, first
            first_skill, second_skill = second_skill, first_skill
        elif self.opponent_creature.speed == self.player_creature.speed:
            if random.random() < 0.5:
                first, second = second, first
                first_skill, second_skill = second_skill, first_skill

        # Execute skills
        for attacker, defender, skill in [(first, second, first_skill), (second, first, second_skill)]:
            if attacker == self.player:
                atk_creature = self.player_creature
                def_creature = self.opponent_creature
            else:
                atk_creature = self.opponent_creature
                def_creature = self.player_creature

            damage = self._calculate_damage(atk_creature, def_creature, skill)
            def_creature.hp = max(0, def_creature.hp - damage)
            
            self._show_text(self.player, f"{atk_creature.display_name} used {skill.display_name}!")
            self._show_text(self.player, f"It dealt {damage} damage!")

            if def_creature.hp == 0:
                break

    def _check_battle_end(self):
        if self.player_creature.hp == 0:
            self._show_text(self.player, f"{self.player_creature.display_name} fainted! You lose!")
            return True
        elif self.opponent_creature.hp == 0:
            self._show_text(self.player, f"{self.opponent_creature.display_name} fainted! You win!")
            return True
        return False
```

The key change is in the `run()` method where we now properly end the game with `self._quit_whole_game()` after the battle concludes. This ensures we follow the engine's requirements for scene termination.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
