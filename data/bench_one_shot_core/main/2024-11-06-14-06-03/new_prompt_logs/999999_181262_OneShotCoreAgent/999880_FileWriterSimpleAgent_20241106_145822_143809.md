Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
I understand the issues raised during QA/testing. I'll describe how to fix these issues and then provide the updated MainGameScene file.

1. Description of the fix:

To address the discrepancies identified in the QA pass, we need to make two main changes to the MainGameScene:

a) Implement random turn order for creatures with the same speed:
   - In the resolution_phase method, we'll modify the sorting key to include a random tiebreaker for creatures with the same speed.

b) Implement force_swap when a creature is knocked out:
   - After each attack in the resolution_phase, we'll check if the defender's HP has reached zero.
   - If so, we'll call the force_swap method for the appropriate player.
   - We'll also need to update the turn_queue to reflect the new active creature if a swap occurs.

These changes will align the implementation with the architecture documentation while staying within the engine's capabilities.

2. Rewritten MainGameScene file:

# Excerpt ID: dea2c494-8d90-465f-bbcf-fac1f213cffe
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.turn_queue = []

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        return f"""===Battle===
{self.player.display_name}'s {player_creature.display_name}: HP {player_creature.hp}/{player_creature.max_hp}
{self.opponent.display_name}'s {opponent_creature.display_name}: HP {opponent_creature.hp}/{opponent_creature.max_hp}

> Attack
> Swap (if available)
"""

    def run(self):
        self._show_text(self.player, "A wild opponent appeared!")
        while True:
            self.player_turn()
            if self.check_battle_end():
                break
            self.opponent_turn()
            if self.check_battle_end():
                break
            self.resolution_phase()
            if self.check_battle_end():
                break

    def player_turn(self):
        while True:
            attack_button = Button("Attack")
            choices = [attack_button]
            
            available_creatures = [c for c in self.player.creatures if c != self.player.active_creature and c.hp > 0]
            if available_creatures:
                swap_button = Button("Swap")
                choices.append(swap_button)
            
            choice = self._wait_for_choice(self.player, choices)

            if choice == attack_button:
                skill_choice = self.choose_skill()
                if skill_choice:
                    self.turn_queue.append(("attack", self.player, skill_choice))
                    break
            elif choice == swap_button:
                creature_choice = self.choose_creature(available_creatures)
                if creature_choice:
                    self.turn_queue.append(("swap", self.player, creature_choice))
                    break

    def choose_skill(self):
        while True:
            skill_choices = [SelectThing(skill) for skill in self.player.active_creature.skills]
            back_button = Button("Back")
            skill_choices.append(back_button)
            choice = self._wait_for_choice(self.player, skill_choices)
            if choice == back_button:
                return None
            return choice.thing

    def choose_creature(self, available_creatures):
        while True:
            creature_choices = [SelectThing(creature) for creature in available_creatures]
            back_button = Button("Back")
            creature_choices.append(back_button)
            choice = self._wait_for_choice(self.player, creature_choices)
            if choice == back_button:
                return None
            return choice.thing

    def opponent_turn(self):
        opponent_choice = self._wait_for_choice(self.opponent, [Button("Make Move")])
        if opponent_choice:
            available_creatures = [c for c in self.opponent.creatures if c != self.opponent.active_creature and c.hp > 0]
            if available_creatures and random.choice(["attack", "swap"]) == "swap":
                creature = random.choice(available_creatures)
                self.turn_queue.append(("swap", self.opponent, creature))
            else:
                skill = random.choice(self.opponent.active_creature.skills)
                self.turn_queue.append(("attack", self.opponent, skill))

    def resolution_phase(self):
        # Sort with random tiebreaker for same speed
        self.turn_queue.sort(key=lambda x: (-1 if x[0] == "swap" else x[1].active_creature.speed, random.random()), reverse=True)

        for i, (action, player, target) in enumerate(self.turn_queue):
            if action == "swap":
                player.active_creature = target
                self._show_text(self.player, f"{player.display_name} swapped to {target.display_name}!")
            elif action == "attack":
                attacker = player.active_creature
                defender = self.opponent.active_creature if player == self.player else self.player.active_creature
                damage = self.calculate_damage(attacker, defender, target)
                defender.hp = max(0, defender.hp - damage)
                self._show_text(self.player, f"{attacker.display_name} used {target.display_name} and dealt {damage} damage to {defender.display_name}!")
                
                if defender.hp == 0:
                    defender_player = self.opponent if player == self.player else self.player
                    self.force_swap(defender_player)
                    # Update turn_queue if the knocked-out creature had a pending action
                    for j in range(i+1, len(self.turn_queue)):
                        if self.turn_queue[j][1] == defender_player:
                            if self.turn_queue[j][0] == "attack":
                                self.turn_queue[j] = ("attack", defender_player, random.choice(defender_player.active_creature.skills))
                            elif self.turn_queue[j][0] == "swap":
                                self.turn_queue[j] = ("swap", defender_player, defender_player.active_creature)

        self.turn_queue.clear()

    def calculate_damage(self, attacker: Creature, defender: Creature, skill: Skill) -> int:
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_effectiveness)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def get_type_effectiveness(self, skill_type: str, defender_type: str) -> float:
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def check_battle_end(self) -> bool:
        if all(c.hp == 0 for c in self.player.creatures):
            self._show_text(self.player, "You lost the battle!")
            self.reset_creatures_state()
            self._transition_to_scene("MainMenuScene")
            return True
        elif all(c.hp == 0 for c in self.opponent.creatures):
            self._show_text(self.player, "You won the battle!")
            self.reset_creatures_state()
            self._transition_to_scene("MainMenuScene")
            return True
        return False

    def reset_creatures_state(self):
        for creature in self.player.creatures:
            creature.hp = creature.max_hp
        for creature in self.opponent.creatures:
            creature.hp = creature.max_hp

    def force_swap(self, player: Player):
        available_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
        if available_creatures:
            creature_choices = [SelectThing(creature) for creature in available_creatures]
            creature_choice = self._wait_for_choice(player, creature_choices)
            player.active_creature = creature_choice.thing
            self._show_text(self.player, f"{player.display_name} swapped to {player.active_creature.display_name}!")
        else:
            self._show_text(self.player, f"{player.display_name} has no more creatures able to battle!")
```

These changes address both issues raised in the QA pass:

1. Random turn order for creatures with the same speed is now implemented in the resolution_phase method by adding a random tiebreaker to the sorting key.
2. The force_swap method is now called when a creature is knocked out during the resolution phase. The turn_queue is also updated to reflect any changes in the active creature due to forced swaps.

These modifications align the implementation with the architecture documentation while maintaining the game's logic and adhering to the engine's capabilities.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
