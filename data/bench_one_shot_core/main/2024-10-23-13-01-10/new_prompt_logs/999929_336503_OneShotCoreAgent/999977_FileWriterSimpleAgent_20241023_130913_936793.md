Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issues raised during QA/testing, we need to address two main problems:

1. The MainGameScene is not exiting properly, either by transitioning to another scene or quitting the game.
2. The scene is not being exited in an expected manner during the random run test.

To resolve these issues, we'll make the following changes to the MainGameScene:

1. After the battle ends, we'll transition back to the MainMenuScene instead of just breaking the loop.
2. We'll add a "Return to Main Menu" option after the battle ends, allowing the player to choose to go back to the main menu.
3. We'll ensure that the scene always exits properly by using the appropriate transition or quit methods.

Here's the rewritten MainGameScene with the proposed solution:

# Excerpt ID: 2ee40684-cf35-4629-a49f-7b6fcbca1fcd
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("default_player")
        self.player_creature = player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.battle_ended = False

    def __str__(self):
        if self.battle_ended:
            return """===Battle Ended===
> Return to Main Menu
"""
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Your skills:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        while True:
            if self.battle_ended:
                self.post_battle_menu()
                break

            # Player Choice Phase
            player_skill = self.player_turn()
            
            # Foe Choice Phase
            foe_skill = self.opponent_turn()
            
            # Resolution Phase
            self.resolve_turn(player_skill, foe_skill)
            
            # Check for battle end
            if self.check_battle_end():
                self.battle_ended = True

        self.reset_creatures()

    def player_turn(self):
        self._show_text(self.player, "Choose your skill:")
        choices = [SelectThing(skill) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def opponent_turn(self):
        choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def resolve_turn(self, player_skill, foe_skill):
        self._show_text(self.player, f"You used {player_skill.display_name}!")
        self.opponent_creature.hp -= player_skill.damage
        self._show_text(self.player, f"Opponent's {self.opponent_creature.display_name} took {player_skill.damage} damage!")

        self._show_text(self.player, f"Opponent used {foe_skill.display_name}!")
        self.player_creature.hp -= foe_skill.damage
        self._show_text(self.player, f"Your {self.player_creature.display_name} took {foe_skill.damage} damage!")

    def check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, "You lost the battle!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, "You won the battle!")
            return True
        return False

    def reset_creatures(self):
        self.player_creature.hp = self.player_creature.max_hp
        self.opponent_creature.hp = self.opponent_creature.max_hp

    def post_battle_menu(self):
        self._show_text(self.player, "Battle has ended.")
        return_button = Button("Return to Main Menu")
        choice = self._wait_for_choice(self.player, [return_button])
        if choice == return_button:
            self._transition_to_scene("MainMenuScene")
```

This updated MainGameScene addresses the issues by:

1. Adding a `battle_ended` flag to track when the battle has ended.
2. Updating the `__str__` method to show different content based on whether the battle has ended or not.
3. Modifying the `run` method to include a post-battle menu when the battle ends.
4. Adding a `post_battle_menu` method that allows the player to return to the main menu after the battle.
5. Ensuring that the scene always exits properly by transitioning back to the MainMenuScene.

These changes should resolve both the issue of the scene not exiting properly and the random run test failing due to unexpected scene termination. The scene will now always transition back to the MainMenuScene after a battle ends, which should satisfy the requirements of the engine and fix the test failures.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "2ee40684-cf35-4629-a49f-7b6fcbca1fcd", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
