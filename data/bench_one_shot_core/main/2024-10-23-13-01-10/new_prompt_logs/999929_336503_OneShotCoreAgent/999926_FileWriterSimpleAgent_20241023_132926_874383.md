Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
I understand the issue, and I'll describe how to fix it and then provide the updated file.

1. Description of the fix:

The issue is in the `_resolution_phase` method of the `MainGameScene` class. Currently, it's not handling the case where both creatures have equal speed, which should result in a random decision for who goes first. To fix this, we'll modify the method to include a random choice when the speeds are equal.

Here's how we'll implement the fix:
- We'll use Python's `random.choice` function to randomly select which creature goes first when their speeds are equal.
- We'll restructure the method to have a single execution flow, regardless of which creature goes first.
- We'll maintain the existing logic for when one creature is clearly faster than the other.

This solution stays within the capabilities of the engine and doesn't require changes to the models or overall architecture.

2. Rewritten file with the proposed solution:

# Excerpt ID: d00e2df1-d611-4b3e-b2e9-5117a6931ab6
```python main_game/scenes/main_game_scene.py
import random
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Your skills:
{self._format_skills(self.player_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name}" for skill in skills])

    def run(self):
        self.game_loop()

    def game_loop(self):
        while True:
            # Player Choice Phase
            player_skill = self._player_choice_phase(self.player, self.player_creature)
            
            # Foe Choice Phase
            opponent_skill = self._player_choice_phase(self.opponent, self.opponent_creature)
            
            # Resolution Phase
            self._resolution_phase(player_skill, opponent_skill)
            
            # Check for battle end
            if self._check_battle_end():
                break

        self._reset_creatures()
        self._transition_to_scene("MainMenuScene")

    def _player_choice_phase(self, player: Player, creature: Creature) -> Skill:
        choices = [SelectThing(skill, label=skill.display_name) for skill in creature.skills]
        choice = self._wait_for_choice(player, choices)
        return choice.thing

    def _resolution_phase(self, player_skill: Skill, opponent_skill: Skill):
        if self.player_creature.speed > self.opponent_creature.speed:
            first_attacker, first_skill = self.player, player_skill
            second_attacker, second_skill = self.opponent, opponent_skill
        elif self.player_creature.speed < self.opponent_creature.speed:
            first_attacker, first_skill = self.opponent, opponent_skill
            second_attacker, second_skill = self.player, player_skill
        else:
            # Equal speed, randomly choose who goes first
            if random.choice([True, False]):
                first_attacker, first_skill = self.player, player_skill
                second_attacker, second_skill = self.opponent, opponent_skill
            else:
                first_attacker, first_skill = self.opponent, opponent_skill
                second_attacker, second_skill = self.player, player_skill

        # Execute skills in order
        self._execute_skill(first_attacker, 
                            first_attacker.creatures[0], 
                            first_skill, 
                            second_attacker.creatures[0])
        
        if second_attacker.creatures[0].hp > 0:
            self._execute_skill(second_attacker, 
                                second_attacker.creatures[0], 
                                second_skill, 
                                first_attacker.creatures[0])

    def _execute_skill(self, attacker: Player, attacker_creature: Creature, skill: Skill, defender_creature: Creature):
        if skill.is_physical:
            raw_damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        else:
            raw_damage = (attacker_creature.sp_attack / defender_creature.sp_defense) * skill.base_damage

        weakness_factor = self._calculate_weakness_factor(skill.skill_type, defender_creature.creature_type)
        final_damage = int(weakness_factor * raw_damage)
        defender_creature.hp = max(0, defender_creature.hp - final_damage)

        self._show_text(attacker, f"{attacker_creature.display_name} used {skill.display_name}!")
        self._show_text(attacker, f"It dealt {final_damage} damage to {defender_creature.display_name}!")

    def _calculate_weakness_factor(self, skill_type: str, defender_type: str) -> float:
        effectiveness = {
            "fire": {"leaf": 2, "water": 0.5},
            "water": {"fire": 2, "leaf": 0.5},
            "leaf": {"water": 2, "fire": 0.5}
        }
        return effectiveness.get(skill_type, {}).get(defender_type, 1)

    def _check_battle_end(self) -> bool:
        if self.player_creature.hp == 0:
            self._show_text(self.player, "You lost the battle!")
            return True
        elif self.opponent_creature.hp == 0:
            self._show_text(self.player, "You won the battle!")
            return True
        return False

    def _reset_creatures(self):
        for creature in self.player.creatures + self.opponent.creatures:
            creature.hp = creature.max_hp
```

This updated implementation of the `MainGameScene` class now correctly handles the case where both creatures have equal speed by randomly deciding which one goes first. The rest of the battle logic remains unchanged, ensuring that the game still follows the overall architecture and requirements.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "d00e2df1-d611-4b3e-b2e9-5117a6931ab6", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
