Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. The issue is that MainGameScene is breaking from its game loop without properly ending the game via `_quit_whole_game()`. According to the engine's requirements, scenes must either transition to another scene or quit the game - they can't just end.

Looking at the output, we can see the battle completed successfully (Default Player wins!) but then the scene just ended without properly signaling game completion to the engine.

The fix is simple: in MainGameScene, when we detect the battle is over, we should call `_quit_whole_game()` instead of just breaking from the loop.

2. Here's the fixed MainGameScene:

# Excerpt ID: e799a2d9-cc84-4bca-84fb-2547740c3dc5
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Creature
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        
        # Initialize creatures
        for p in [self.player, self.bot]:
            p.active_creature = p.creatures[0]
            for c in p.creatures:
                c.hp = c.max_hp

    def __str__(self):
        p_creature = self.player.active_creature
        b_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {p_creature.display_name}: {p_creature.hp}/{p_creature.max_hp} HP
Foe's {b_creature.display_name}: {b_creature.hp}/{b_creature.max_hp} HP

Available actions:
{'> Attack' if p_creature.hp > 0 else ''}
{'> Swap' if self.has_valid_swaps(self.player) else ''}"""

    def run(self):
        while True:
            # Player turn
            player_action = self.get_player_action(self.player)
            if player_action is None:  # No valid actions - player lost
                self._show_text(self.player, f"{self.bot.display_name} wins!")
                self._quit_whole_game()
                return
                
            bot_action = self.get_player_action(self.bot)
            if bot_action is None:  # No valid actions - bot lost
                self._show_text(self.player, f"{self.player.display_name} wins!")
                self._quit_whole_game()
                return
            
            # Execute actions
            self.resolve_turn(player_action, bot_action)
            
            # Check for battle end
            if self.check_battle_end():
                self._quit_whole_game()
                return

    def has_valid_swaps(self, player):
        return any(c != player.active_creature and c.hp > 0 for c in player.creatures)

    def get_player_action(self, player):
        choices = []
        
        # Only add Attack if creature isn't fainted
        if player.active_creature.hp > 0:
            choices.append(Button("Attack"))
            
        # Only add Swap if there are valid creatures to swap to
        if self.has_valid_swaps(player):
            choices.append(Button("Swap"))
            
        # If no choices available, player has lost
        if not choices:
            return None
            
        choice = self._wait_for_choice(player, choices)
        
        if choice.display_name == "Attack":
            choices = [SelectThing(skill) for skill in player.active_creature.skills]
            return self._wait_for_choice(player, choices)
        else:  # Swap
            valid_creatures = [c for c in player.creatures if c != player.active_creature and c.hp > 0]
            choices = [SelectThing(creature) for creature in valid_creatures]
            return self._wait_for_choice(player, choices)

    def resolve_turn(self, p1_action, p2_action):
        # Handle swaps first
        for action, player in [(p1_action, self.player), (p2_action, self.bot)]:
            if isinstance(action.thing, Creature):
                player.active_creature = action.thing
                self._show_text(player, f"{player.display_name} swapped to {action.thing.display_name}!")

        # Then handle attacks
        actions = [(p1_action, self.player, self.bot), (p2_action, self.bot, self.player)]
        actions.sort(key=lambda x: x[1].active_creature.speed, reverse=True)
        
        for action, attacker, defender in actions:
            if isinstance(action.thing, Creature):
                continue
                
            skill = action.thing
            damage = self.calculate_damage(skill, attacker.active_creature, defender.active_creature)
            defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
            
            self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
            self._show_text(defender, f"{defender.active_creature.display_name} took {damage} damage!")
            
            if defender.active_creature.hp == 0:
                self._show_text(defender, f"{defender.active_creature.display_name} fainted!")
                self.handle_faint(defender)

    def calculate_damage(self, skill, attacker, defender):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Calculate type effectiveness
        effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        
        return int(raw_damage * effectiveness)

    def get_type_effectiveness(self, attack_type, defend_type):
        if attack_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"water": 0.5, "leaf": 2.0},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(attack_type, {}).get(defend_type, 1.0)

    def handle_faint(self, player):
        valid_creatures = [c for c in player.creatures if c.hp > 0]
        if valid_creatures:
            choices = [SelectThing(c) for c in valid_creatures]
            choice = self._wait_for_choice(player, choices)
            player.active_creature = choice.thing
            self._show_text(player, f"Go, {choice.thing.display_name}!")

    def check_battle_end(self):
        for player in [self.player, self.bot]:
            if all(c.hp == 0 for c in player.creatures):
                winner = self.bot if player == self.player else self.player
                self._show_text(self.player, f"{winner.display_name} wins!")
                return True
        return False
```

Key changes:
1. Added `self._quit_whole_game()` calls in all places where the game can end:
   - When player has no valid actions (lost)
   - When bot has no valid actions (player won)
   - When check_battle_end() returns True (someone won)
2. Added `return` statements after `_quit_whole_game()` to ensure the scene properly terminates

This maintains the architecture and engine capabilities while properly signaling game completion to the engine.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
