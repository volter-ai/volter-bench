Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
The issue is in MainGameScene where we're not handling empty choice lists correctly. The error occurs when:

1. A player tries to swap but has no valid creatures to swap to (all other creatures are fainted or already active)
2. When trying to get choices for a fainted creature's skills

We need to modify MainGameScene to:
1. Only show the "Swap" button if there are valid creatures to swap to
2. Only show the "Attack" button if the active creature isn't fainted
3. Handle the case where no actions are possible (all creatures fainted)

Here's the fixed MainGameScene:

# Excerpt ID: 32e35bed-2ff0-443a-a12e-1769d6cd4cfc
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Creature
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        
        # Initialize creatures
        for p in [self.player, self.bot]:
            p.active_creature = p.creatures[0]
            for c in p.creatures:
                c.hp = c.max_hp

    def __str__(self):
        p_creature = self.player.active_creature
        b_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {p_creature.display_name}: {p_creature.hp}/{p_creature.max_hp} HP
Foe's {b_creature.display_name}: {b_creature.hp}/{b_creature.max_hp} HP

Available actions:
{'> Attack' if p_creature.hp > 0 else ''}
{'> Swap' if self.has_valid_swaps(self.player) else ''}"""

    def run(self):
        while True:
            # Player turn
            player_action = self.get_player_action(self.player)
            if player_action is None:  # No valid actions - player lost
                self._show_text(self.player, f"{self.bot.display_name} wins!")
                break
                
            bot_action = self.get_player_action(self.bot)
            if bot_action is None:  # No valid actions - bot lost
                self._show_text(self.player, f"{self.player.display_name} wins!")
                break
            
            # Execute actions
            self.resolve_turn(player_action, bot_action)
            
            # Check for battle end
            if self.check_battle_end():
                break

    def has_valid_swaps(self, player):
        return any(c != player.active_creature and c.hp > 0 for c in player.creatures)

    def get_player_action(self, player):
        choices = []
        
        # Only add Attack if creature isn't fainted
        if player.active_creature.hp > 0:
            choices.append(Button("Attack"))
            
        # Only add Swap if there are valid creatures to swap to
        if self.has_valid_swaps(player):
            choices.append(Button("Swap"))
            
        # If no choices available, player has lost
        if not choices:
            return None
            
        choice = self._wait_for_choice(player, choices)
        
        if choice.display_name == "Attack":
            choices = [SelectThing(skill) for skill in player.active_creature.skills]
            return self._wait_for_choice(player, choices)
        else:  # Swap
            valid_creatures = [c for c in player.creatures if c != player.active_creature and c.hp > 0]
            choices = [SelectThing(creature) for creature in valid_creatures]
            return self._wait_for_choice(player, choices)

    def resolve_turn(self, p1_action, p2_action):
        # Handle swaps first
        for action, player in [(p1_action, self.player), (p2_action, self.bot)]:
            if isinstance(action.thing, Creature):
                player.active_creature = action.thing
                self._show_text(player, f"{player.display_name} swapped to {action.thing.display_name}!")

        # Then handle attacks
        actions = [(p1_action, self.player, self.bot), (p2_action, self.bot, self.player)]
        actions.sort(key=lambda x: x[1].active_creature.speed, reverse=True)
        
        for action, attacker, defender in actions:
            if isinstance(action.thing, Creature):
                continue
                
            skill = action.thing
            damage = self.calculate_damage(skill, attacker.active_creature, defender.active_creature)
            defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
            
            self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
            self._show_text(defender, f"{defender.active_creature.display_name} took {damage} damage!")
            
            if defender.active_creature.hp == 0:
                self._show_text(defender, f"{defender.active_creature.display_name} fainted!")
                self.handle_faint(defender)

    def calculate_damage(self, skill, attacker, defender):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Calculate type effectiveness
        effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        
        return int(raw_damage * effectiveness)

    def get_type_effectiveness(self, attack_type, defend_type):
        if attack_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"water": 0.5, "leaf": 2.0},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(attack_type, {}).get(defend_type, 1.0)

    def handle_faint(self, player):
        valid_creatures = [c for c in player.creatures if c.hp > 0]
        if valid_creatures:
            choices = [SelectThing(c) for c in valid_creatures]
            choice = self._wait_for_choice(player, choices)
            player.active_creature = choice.thing
            self._show_text(player, f"Go, {choice.thing.display_name}!")

    def check_battle_end(self):
        for player in [self.player, self.bot]:
            if all(c.hp == 0 for c in player.creatures):
                winner = self.bot if player == self.player else self.player
                self._show_text(self.player, f"{winner.display_name} wins!")
                return True
        return False
```

Key changes:
1. Added `has_valid_swaps()` helper method to check if a player has creatures they can swap to
2. Modified `get_player_action()` to only show valid choices
3. Added handling for when a player has no valid actions (all creatures fainted)
4. Updated `__str__` to only show available actions
5. Modified battle end logic to handle when a player has no valid moves

This maintains the architecture and engine capabilities while fixing the empty choices issue.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
