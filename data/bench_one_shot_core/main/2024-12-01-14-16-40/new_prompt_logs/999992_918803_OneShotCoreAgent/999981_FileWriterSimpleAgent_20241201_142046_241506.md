Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis and Solution:
According to the requirements in main_game_scene.md:
> If the creatures have the same speed, then which creature goes first is decided randomly, with either creature having equal chance of being picked to go first.

The current implementation only handles when speeds are different. We need to modify the `_resolve_turn` method in MainGameScene to:
1. Compare speeds
2. If speeds are equal, use random.choice to select who goes first
3. Keep the rest of the logic intact

This change only requires modifying the scene logic, not the models, staying within engine capabilities.

2. Here's the fixed MainGameScene:

# Excerpt ID: 0f0b7706-4db6-4943-a9e0-7a2ef51c1dd2
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, SelectThing, Button
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""=== Battle ===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available Skills:
{[skill.display_name for skill in self.player_creature.skills]}
"""

    def run(self):
        while True:
            # Player Choice Phase
            player_skill = self._handle_player_turn()
            
            # Opponent Choice Phase  
            opponent_skill = self._handle_opponent_turn()

            # Resolution Phase
            self._resolve_turn(player_skill, opponent_skill)

            # Check for battle end
            if self.player_creature.hp <= 0:
                self._show_text(self.player, "You lost the battle!")
                self._transition_to_scene("MainMenuScene")
                return
            elif self.opponent_creature.hp <= 0:
                self._show_text(self.player, "You won the battle!")
                self._transition_to_scene("MainMenuScene")
                return

    def _handle_player_turn(self):
        self._show_text(self.player, "Choose your skill!")
        choices = [SelectThing(skill) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def _handle_opponent_turn(self):
        choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def _calculate_damage(self, attacker, defender, skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        
        # Type effectiveness
        multiplier = self._get_type_multiplier(skill.skill_type, defender.creature_type)
        
        return int(raw_damage * multiplier)

    def _get_type_multiplier(self, skill_type, defender_type):
        if skill_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(skill_type, {}).get(defender_type, 1.0)

    def _resolve_turn(self, player_skill, opponent_skill):
        # Determine order based on speed
        if self.player_creature.speed > self.opponent_creature.speed:
            first = self.player_creature
            second = self.opponent_creature
            first_skill = player_skill
            second_skill = opponent_skill
        elif self.player_creature.speed < self.opponent_creature.speed:
            first = self.opponent_creature
            second = self.player_creature
            first_skill = opponent_skill
            second_skill = player_skill
        else:
            # Equal speed - randomly choose who goes first
            if random.choice([True, False]):
                first = self.player_creature
                second = self.opponent_creature
                first_skill = player_skill
                second_skill = opponent_skill
            else:
                first = self.opponent_creature
                second = self.player_creature
                first_skill = opponent_skill
                second_skill = player_skill

        # Execute first attack
        self._execute_skill(first, second, first_skill)
        
        # Execute second attack only if second creature is still alive
        if second.hp > 0:
            self._execute_skill(second, first, second_skill)

    def _execute_skill(self, attacker, defender, skill):
        damage = self._calculate_damage(attacker, defender, skill)
        defender.hp = max(0, defender.hp - damage)
        self._show_text(self.player, f"{attacker.display_name} used {skill.display_name} for {damage} damage!")
```

Key changes:
1. Completely rewrote the `_resolve_turn` method to properly handle equal speeds
2. Added explicit random choice when speeds are equal using `random.choice([True, False])`
3. Simplified the execution logic by removing nested conditions
4. Maintained all the required battle mechanics and transitions

This implementation now fully matches the requirements document while staying within the engine's architecture.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
