Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
The issue is in the MainGameScene where we're trying to show creature swap choices when there are no valid creatures to swap to. This happens when a creature is knocked out but there are no other creatures with HP > 0 available to swap to.

The fix should:
1. Check if there are valid creatures before showing swap choices
2. If no valid creatures, skip showing choices and handle the game end condition
3. Keep all game logic in the scene, not in models
4. Maintain proper separation between data and logic

Here's the fixed MainGameScene:

# Excerpt ID: 843fab53-4ef9-4f0f-8965-14e74c7a6147
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random
from typing import List, Tuple, Optional
from main_game.models import Player, Creature, Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        
        # Initialize creatures
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]
        
        for creature in self.player.creatures + self.bot.creatures:
            creature.hp = creature.max_hp

    def __str__(self):
        player_creature = self.player.active_creature
        bot_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {player_creature.display_name}: {player_creature.hp}/{player_creature.max_hp} HP
Foe's {bot_creature.display_name}: {bot_creature.hp}/{bot_creature.max_hp} HP

Your other creatures: {[c.display_name for c in self.player.creatures if c != player_creature]}
Foe's other creatures: {[c.display_name for c in self.bot.creatures if c != bot_creature]}
"""

    def run(self):
        while True:
            # Player turn
            player_action = self.get_player_action(self.player)
            if player_action is None:
                if not self.has_valid_creatures(self.player):
                    self._show_text(self.player, "You lost the battle!")
                    self._transition_to_scene("MainMenuScene")
                    return
                    
            bot_action = self.get_player_action(self.bot)
            if bot_action is None:
                if not self.has_valid_creatures(self.bot):
                    self._show_text(self.player, "You won the battle!")
                    self._transition_to_scene("MainMenuScene")
                    return
            
            # Execute actions if both players could make a choice
            if player_action and bot_action:
                self.resolve_turn(player_action, bot_action)

    def get_player_action(self, player: Player) -> Optional[Tuple[str, Skill | Creature]]:
        if not self.has_valid_creatures(player):
            return None
            
        # Attack option
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        
        choice = self._wait_for_choice(player, [attack_button, swap_button])
        
        if choice == attack_button:
            # Show skills
            skill_choices = [SelectThing(skill) for skill in player.active_creature.skills]
            skill_choice = self._wait_for_choice(player, skill_choices)
            return ("attack", skill_choice.thing)
        else:
            # Show creatures
            valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
            if not valid_creatures:
                # If no valid creatures to swap to, force attack
                skill_choices = [SelectThing(skill) for skill in player.active_creature.skills]
                skill_choice = self._wait_for_choice(player, skill_choices)
                return ("attack", skill_choice.thing)
                
            creature_choices = [SelectThing(creature) for creature in valid_creatures]
            creature_choice = self._wait_for_choice(player, creature_choices)
            return ("swap", creature_choice.thing)

    def resolve_turn(self, player_action: Tuple[str, Skill | Creature], bot_action: Tuple[str, Skill | Creature]):
        # Handle swaps first
        if player_action[0] == "swap":
            self.player.active_creature = player_action[1]
        if bot_action[0] == "swap":
            self.bot.active_creature = bot_action[1]
            
        # Then handle attacks
        if player_action[0] == "attack" and bot_action[0] == "attack":
            # Determine order based on speed
            if self.player.active_creature.speed > self.bot.active_creature.speed:
                self.execute_attack(self.player, self.bot, player_action[1])
                if self.bot.active_creature.hp > 0:
                    self.execute_attack(self.bot, self.player, bot_action[1])
            else:
                self.execute_attack(self.bot, self.player, bot_action[1])
                if self.player.active_creature.hp > 0:
                    self.execute_attack(self.player, self.bot, player_action[1])

    def execute_attack(self, attacker: Player, defender: Player, skill: Skill):
        # Calculate damage
        if skill.is_physical:
            raw_damage = attacker.active_creature.attack + skill.base_damage - defender.active_creature.defense
        else:
            raw_damage = (attacker.active_creature.sp_attack / defender.active_creature.sp_defense) * skill.base_damage
            
        # Apply type effectiveness
        multiplier = self.get_type_multiplier(skill.skill_type, defender.active_creature.creature_type)
        final_damage = int(raw_damage * multiplier)
        
        # Apply damage
        defender.active_creature.hp = max(0, defender.active_creature.hp - final_damage)
        
        self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(defender, f"It dealt {final_damage} damage!")
        
        # Handle fainting
        if defender.active_creature.hp <= 0:
            self._show_text(defender, f"{defender.active_creature.display_name} was knocked out!")
            self.handle_fainted_creature(defender)

    def get_type_multiplier(self, skill_type: str, creature_type: str) -> float:
        if skill_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(skill_type, {}).get(creature_type, 1.0)

    def handle_fainted_creature(self, player: Player):
        valid_creatures = [c for c in player.creatures if c.hp > 0]
        if valid_creatures:
            creature_choices = [SelectThing(creature) for creature in valid_creatures]
            choice = self._wait_for_choice(player, creature_choices)
            player.active_creature = choice.thing

    def has_valid_creatures(self, player: Player) -> bool:
        return any(creature.hp > 0 for creature in player.creatures)
```

Key changes:
1. Made get_player_action return Optional[Tuple] to handle no-action case
2. Added check for valid creatures before showing swap choices
3. If no valid swap choices, force attack option
4. Added early returns in run() when a player has no valid actions
5. Check both actions exist before resolving turn

This maintains the architecture while fixing the empty choices issue by properly handling the case where a player has no valid creatures to swap to.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
