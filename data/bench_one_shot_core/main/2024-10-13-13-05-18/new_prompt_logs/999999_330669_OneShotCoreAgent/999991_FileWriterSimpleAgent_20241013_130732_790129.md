Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To address the issue raised during QA/testing, we need to implement an explicit queue management system for skills in the MainGameScene, as described in the architecture document. Here's how we'll fix this:

1. We'll add a queue to store the skills chosen by both the player and the bot.
2. We'll modify the turn phases to queue the skills instead of resolving them immediately.
3. We'll implement a separate resolution phase that processes the queued skills in order.

This approach will align with the architecture document while staying within the capabilities of the engine. Now, let's rewrite the MainGameScene with these changes:

# Excerpt ID: f086f297-c3d2-4a11-bbd5-451bb8019b05
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
from collections import deque

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("default_player")
        self.player_creature = self.player.creatures[0]
        self.bot_creature = self.bot.creatures[0]
        self.skill_queue = deque()

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.bot.display_name}'s {self.bot_creature.display_name}: HP {self.bot_creature.hp}/{self.bot_creature.max_hp}

Available skills:
{', '.join([skill.display_name for skill in self.player_creature.skills])}

Queued skills:
{', '.join([skill.display_name for skill in self.skill_queue])}
"""

    def run(self):
        self._show_text(self.player, "A wild creature appears!")
        self.battle_loop()

    def battle_loop(self):
        while True:
            # Player Choice Phase
            self.player_choice_phase()
            
            # Foe Choice Phase
            self.foe_choice_phase()
            
            # Resolution Phase
            self.resolution_phase()
            
            # Check for battle end
            if self.check_battle_end():
                break

        self.end_battle()

    def player_choice_phase(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        self.skill_queue.append((self.player, choice.thing))
        self._show_text(self.player, f"{self.player.display_name} queued {choice.thing.display_name}")

    def foe_choice_phase(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.bot_creature.skills]
        choice = self._wait_for_choice(self.bot, choices)
        self.skill_queue.append((self.bot, choice.thing))
        self._show_text(self.player, f"{self.bot.display_name} queued a skill")

    def resolution_phase(self):
        while self.skill_queue:
            acting_player, skill = self.skill_queue.popleft()
            if acting_player == self.player:
                target = self.bot_creature
                attacker = self.player_creature
            else:
                target = self.player_creature
                attacker = self.bot_creature
            
            self._show_text(self.player, f"{acting_player.display_name}'s {attacker.display_name} uses {skill.display_name}!")
            target.hp -= skill.damage
            self._show_text(self.player, f"{target.display_name} takes {skill.damage} damage!")

    def check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name}'s {self.player_creature.display_name} fainted! You lose!")
            return True
        elif self.bot_creature.hp <= 0:
            self._show_text(self.player, f"{self.bot.display_name}'s {self.bot_creature.display_name} fainted! You win!")
            return True
        return False

    def end_battle(self):
        self.reset_creatures()
        
        play_again_button = Button("Play Again")
        quit_button = Button("Quit")
        choices = [play_again_button, quit_button]
        
        choice = self._wait_for_choice(self.player, choices)
        
        if play_again_button == choice:
            self._transition_to_scene("MainMenuScene")
        elif quit_button == choice:
            self._quit_whole_game()

    def reset_creatures(self):
        self.player_creature.hp = self.player_creature.max_hp
        self.bot_creature.hp = self.bot_creature.max_hp
        self.skill_queue.clear()
```

This updated implementation addresses the issue by:

1. Introducing a `skill_queue` to manage the skills chosen by both the player and the bot.
2. Separating the choice phases (player_choice_phase and foe_choice_phase) from the resolution phase.
3. Implementing a dedicated resolution_phase method that processes the queued skills in order.
4. Updating the `__str__` method to display the queued skills, providing better visibility into the game state.

These changes align with the architecture document's description of distinct phases for player choice, foe choice, and resolution. The explicit queue management ensures that skills are resolved in the correct order, addressing the discrepancy noted in the QA feedback.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "f086f297-c3d2-4a11-bbd5-451bb8019b05", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
