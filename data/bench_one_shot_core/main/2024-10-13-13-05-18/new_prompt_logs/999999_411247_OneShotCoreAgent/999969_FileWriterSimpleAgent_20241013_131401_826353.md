Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
I understand the issue, and I'll describe how to fix it and then provide the updated file.

1. Description of the fix:
To implement the random order execution when creatures have the same speed during the resolution phase, we need to modify the `resolution_phase` method in the `MainGameScene` class. Instead of using a simple comparison of speeds, we'll introduce a random factor when the speeds are equal. Here's how we'll do it:

- We'll use Python's `random.choice()` function to randomly select which creature goes first when their speeds are equal.
- We'll keep the existing logic for when one creature is faster than the other.
- We'll refactor the skill execution into a separate method to avoid code duplication.

This change will ensure that when creatures have the same speed, the order of skill execution is randomized, as specified in the architecture documentation.

2. Updated file:

# Excerpt ID: 2a0834c9-f874-4196-9a1c-cb6f075767de
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available skills:
{self._format_skills(self.player_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name}" for skill in skills])

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appeared!")
        self.battle_loop()

    def battle_loop(self):
        while True:
            player_skill = self.player_choice_phase()
            opponent_skill = self.foe_choice_phase()
            self.resolution_phase(player_skill, opponent_skill)

            if self.check_battle_end():
                break

    def player_choice_phase(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def foe_choice_phase(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def resolution_phase(self, player_skill: Skill, opponent_skill: Skill):
        if self.player_creature.speed > self.opponent_creature.speed:
            self.execute_turn(self.player, self.player_creature, player_skill, self.opponent, self.opponent_creature, opponent_skill)
        elif self.player_creature.speed < self.opponent_creature.speed:
            self.execute_turn(self.opponent, self.opponent_creature, opponent_skill, self.player, self.player_creature, player_skill)
        else:
            # Random order when speeds are equal
            if random.choice([True, False]):
                self.execute_turn(self.player, self.player_creature, player_skill, self.opponent, self.opponent_creature, opponent_skill)
            else:
                self.execute_turn(self.opponent, self.opponent_creature, opponent_skill, self.player, self.player_creature, player_skill)

    def execute_turn(self, first_player: Player, first_creature: Creature, first_skill: Skill,
                     second_player: Player, second_creature: Creature, second_skill: Skill):
        self.execute_skill(first_player, first_creature, first_skill, second_creature)
        if not self.check_battle_end():
            self.execute_skill(second_player, second_creature, second_skill, first_creature)

    def execute_skill(self, attacker: Player, attacker_creature: Creature, skill: Skill, defender_creature: Creature):
        damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        damage = max(1, damage)  # Ensure at least 1 damage is dealt
        defender_creature.hp -= damage
        self._show_text(self.player, f"{attacker.display_name}'s {attacker_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender_creature.display_name} took {damage} damage!")

    def check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name}'s {self.player_creature.display_name} fainted! You lose!")
            self._transition_to_scene("MainMenuScene")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"{self.opponent.display_name}'s {self.opponent_creature.display_name} fainted! You win!")
            self._transition_to_scene("MainMenuScene")
            return True
        return False
```

This updated implementation addresses the issue by introducing randomness when creatures have the same speed, as specified in the architecture documentation. The `resolution_phase` method now uses `random.choice()` to determine the order of skill execution when speeds are equal. The rest of the battle logic remains intact, ensuring that the game functions as intended while adhering to the specified requirements.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "2a0834c9-f874-4196-9a1c-cb6f075767de", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
