Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issue, we need to modify the `MainGameScene` class in the `main_game_scene.py` file. The problem is that the scene is not properly exiting or transitioning to another scene after the battle ends. Here's how we'll fix it:

1. After the battle ends (when a creature's HP reaches 0), we'll add a prompt asking the player if they want to play again or quit.
2. Based on the player's choice, we'll either transition back to the `MainMenuScene` or quit the whole game.
3. We'll ensure that the game loop continues until the player makes a choice to exit the scene.

Here's the rewritten `main_game_scene.py` file with the proposed solution:

# Excerpt ID: 7818b7d8-2caa-409a-ab90-b8fc6db91b7d
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("default_player")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Your skills:
{self._format_skills(self.player_creature.skills)}

Opponent's skills:
{self._format_skills(self.opponent_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name}" for skill in skills])

    def run(self):
        while True:
            self._show_text(self.player, "A wild opponent appears!")
            while True:
                player_skill = self._player_choice_phase()
                opponent_skill = self._foe_choice_phase()
                self._resolution_phase(player_skill, opponent_skill)
                
                if self._check_battle_end():
                    break

            self._reset_creatures()
            
            # Ask the player if they want to play again or quit
            play_again_button = Button("Play Again")
            quit_button = Button("Quit")
            choices = [play_again_button, quit_button]
            choice = self._wait_for_choice(self.player, choices)

            if choice == play_again_button:
                continue
            elif choice == quit_button:
                self._transition_to_scene("MainMenuScene")
                return

    def _player_choice_phase(self):
        self._show_text(self.player, "Choose your skill:")
        choices = [SelectThing(skill) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def _foe_choice_phase(self):
        choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def _resolution_phase(self, player_skill, opponent_skill):
        self._show_text(self.player, f"You used {player_skill.display_name}!")
        self._show_text(self.opponent, f"Opponent used {opponent_skill.display_name}!")
        
        self.opponent_creature.hp -= player_skill.damage
        self.player_creature.hp -= opponent_skill.damage
        
        self._show_text(self.player, f"You dealt {player_skill.damage} damage!")
        self._show_text(self.player, f"You received {opponent_skill.damage} damage!")

    def _check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, "You lost the battle!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, "You won the battle!")
            return True
        return False

    def _reset_creatures(self):
        self.player_creature.hp = self.player_creature.max_hp
        self.opponent_creature.hp = self.opponent_creature.max_hp
```

This solution addresses the issue by:

1. Wrapping the entire battle sequence in an outer `while True` loop, allowing for multiple battles.
2. After each battle ends, asking the player if they want to play again or quit.
3. If the player chooses to play again, the loop continues, resetting the creatures and starting a new battle.
4. If the player chooses to quit, the scene transitions back to the `MainMenuScene` using `self._transition_to_scene("MainMenuScene")`.

These changes ensure that the scene always exits properly, either by transitioning to another scene or by allowing the player to play multiple battles before deciding to quit. This should resolve the "Scene terminated without calling `quit_whole_game` or `transition_to_scene` again" error and make the random test runs pass successfully.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "7818b7d8-2caa-409a-ab90-b8fc6db91b7d", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
