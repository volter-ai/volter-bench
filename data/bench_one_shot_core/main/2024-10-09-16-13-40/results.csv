timestamp,run_id,agent_id,ladder,run,status,error,traceback,logs,project_directory,commit_url
2024-10-09 16:15:20,7264911f-f571-4d17-a59c-4eefe3298a9e,OneShotCoreAgent,creature_battler_01,7,success,,,['new_prompt_logs/999755_808369_OneShotCoreAgent'],ladder/creature_battler_01_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:15:55,71c9aaf4-6fe1-4a60-98b3-2cb1b5f46fda,OneShotCoreAgent,creature_battler_02,2,success,,,['new_prompt_logs/999753_684352_OneShotCoreAgent'],ladder/creature_battler_02_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:15:57,08991949-724d-4336-b35b-73c25f7ef5d5,OneShotCoreAgent,creature_battler_01,5,success,,,['new_prompt_logs/999754_950160_OneShotCoreAgent'],ladder/creature_battler_01_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:16:27,ea4e39b1-3155-4e40-a017-f74a550ac949,OneShotCoreAgent,creature_battler_01,4,success,,,['new_prompt_logs/999761_911568_OneShotCoreAgent'],ladder/creature_battler_01_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:16:28,49f13007-1473-45d1-a598-144728d079f8,OneShotCoreAgent,creature_battler_02,3,success,,,['new_prompt_logs/999758_389092_OneShotCoreAgent'],ladder/creature_battler_02_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:16:31,5d2ffcdc-0435-47e4-b372-c4aeacb3360f,OneShotCoreAgent,creature_battler_02,5,success,,,['new_prompt_logs/999752_458358_OneShotCoreAgent'],ladder/creature_battler_02_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:16:33,6e9535e2-110e-4c2b-b31f-0b0ebd20ebf3,OneShotCoreAgent,creature_battler_02,1,success,,,['new_prompt_logs/999757_119827_OneShotCoreAgent'],ladder/creature_battler_02_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:16:53,2973bd4f-e557-467d-bc9c-88f4dbe7e750,OneShotCoreAgent,creature_battler_02,4,success,,,['new_prompt_logs/999752_125630_OneShotCoreAgent'],ladder/creature_battler_02_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:17:24,13a89f29-a64f-4f74-995c-225c9cd10b23,OneShotCoreAgent,creature_battler_01,3,success,,,['new_prompt_logs/999759_211049_OneShotCoreAgent'],ladder/creature_battler_01_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:17:31,e6a8e264-ab47-4448-98a9-a7ffb641105b,OneShotCoreAgent,creature_battler_02,6,success,,,['new_prompt_logs/999755_808369_OneShotCoreAgent'],ladder/creature_battler_02_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:17:41,941afa96-aa0c-43e0-aca7-f91aed5e3496,OneShotCoreAgent,creature_battler_01,2,success,,,['new_prompt_logs/999760_678496_OneShotCoreAgent'],ladder/creature_battler_01_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:18:00,4c83a866-3350-4a69-9c8b-f08be27fb642,OneShotCoreAgent,creature_battler_02,7,success,,,['new_prompt_logs/999753_684352_OneShotCoreAgent'],ladder/creature_battler_02_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:18:31,9e1481d1-c8ab-4304-9b9e-7df13924255f,OneShotCoreAgent,creature_battler_01,6,success,,,['new_prompt_logs/999756_245881_OneShotCoreAgent'],ladder/creature_battler_01_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:18:35,4303b93f-bf1d-40af-9d3c-8e6233400ddb,OneShotCoreAgent,creature_battler_01,1,success,,,['new_prompt_logs/999755_107198_OneShotCoreAgent'],ladder/creature_battler_01_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:19:23,00c70b48-9120-4a3a-88f2-f7f63ed318a2,OneShotCoreAgent,creature_battler_03,1,success,,,['new_prompt_logs/999754_950160_OneShotCoreAgent'],ladder/creature_battler_03_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:20:03,1c16744d-c447-41e0-ac1d-47c303040af9,OneShotCoreAgent,creature_battler_03,3,success,,,['new_prompt_logs/999758_389092_OneShotCoreAgent'],ladder/creature_battler_03_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:20:04,a5642a2b-4bba-4b2a-a2d2-d0d4c6c3dd5f,OneShotCoreAgent,creature_battler_03,4,success,,,['new_prompt_logs/999752_458358_OneShotCoreAgent'],ladder/creature_battler_03_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:20:06,ebfc16ca-322b-4fe0-8fd9-79ca057d7314,OneShotCoreAgent,creature_battler_03,5,success,,,['new_prompt_logs/999757_119827_OneShotCoreAgent'],ladder/creature_battler_03_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:20:13,99ab822c-05ee-4879-8830-72602843dd23,OneShotCoreAgent,creature_battler_03,2,success,,,['new_prompt_logs/999761_911568_OneShotCoreAgent'],ladder/creature_battler_03_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:21:06,abf287f4-8667-4a52-95c8-4a83b8ae6060,OneShotCoreAgent,creature_battler_04,2,success,,,['new_prompt_logs/999760_678496_OneShotCoreAgent'],ladder/creature_battler_04_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:21:06,93701bb4-dc67-4982-ae34-a625fb4965c0,OneShotCoreAgent,creature_battler_03,7,success,,,['new_prompt_logs/999759_211049_OneShotCoreAgent'],ladder/creature_battler_03_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:21:30,45e9a238-03db-46d2-b86e-147b5c1f2060,OneShotCoreAgent,creature_battler_04,5,success,,,['new_prompt_logs/999755_107198_OneShotCoreAgent'],ladder/creature_battler_04_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:21:46,d2a8a2d5-3b46-4141-9c8b-f2addc19cf49,OneShotCoreAgent,creature_battler_03,6,success,,,['new_prompt_logs/999752_125630_OneShotCoreAgent'],ladder/creature_battler_03_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:21:52,f577ed4c-242b-4a82-95b8-2e34aae8505c,OneShotCoreAgent,creature_battler_04,6,success,,,['new_prompt_logs/999754_950160_OneShotCoreAgent'],ladder/creature_battler_04_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:23:04,85a2f50f-ccd9-4218-a058-73d5f60c3a09,OneShotCoreAgent,creature_battler_04,3,success,,,['new_prompt_logs/999753_684352_OneShotCoreAgent'],ladder/creature_battler_04_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:24:43,77c129f0-6525-4f39-b267-08219480887b,OneShotCoreAgent,creature_battler_05,3,success,,,['new_prompt_logs/999761_911568_OneShotCoreAgent'],ladder/creature_battler_05_3/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:25:09,f7b68455-b962-41e0-861d-59cbb4767c77,OneShotCoreAgent,creature_battler_04,1,success,,,['new_prompt_logs/999755_808369_OneShotCoreAgent'],ladder/creature_battler_04_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:26:04,74a96601-e10b-469a-995d-9bf70dbf9ebd,OneShotCoreAgent,creature_battler_04,4,success,,,['new_prompt_logs/999756_245881_OneShotCoreAgent'],ladder/creature_battler_04_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:27:09,f4d5fec6-d512-4b8c-b31a-995a4624c918,OneShotCoreAgent,creature_battler_05,6,failure,"After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform darwin -- Python 3.11.9, pytest-7.4.4, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: asyncio-0.23.8, html-3.2.0, Faker-30.1.0, env-1.1.3, metadata-3.1.1, cov-4.1.0, anyio-4.4.0, timeout-2.3.1, sugar-0.9.7
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # Increased to 30 for more complex scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            class TransitionFromScene(Exception):
                pass
    
            def exit_scene(*args, **kwargs):
                raise TransitionFromScene()
    
            with patch.object(MainGameScene, '_transition_to_scene', side_effect=exit_scene) as mock_transition, \
                    patch.object(MainGameScene, '_quit_whole_game') as mock_quit:
    
                try:
>                   main_game_scene.run()

main_game/tests/test_main_game_scene.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/scenes/main_game_scene.py:30: in run
    self._resolution_phase(player_action, bot_action)
main_game/scenes/main_game_scene.py:85: in _resolution_phase
    swapped_creatures[player] = self._perform_swap(player, action[1])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Basic Opponent

    def __hash__(self):
>       raise FixableException(
            ""Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id"")
E       common.exceptions.FixableException: Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id

../../../../mge2/mini_game_engine/engine/lib.py:136: FixableException
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
BotListener:on_show_event:show_text: {'text': 'Basic Opponent swapped Scizard for Dumbird!'}
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:552: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:668: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:712: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:24: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:422: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:668: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:712: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:30: in run
    self._resolution_phase(player_action, bot_action)
main_game/scenes/main_game_scene.py:85: in _resolution_phase
    swapped_creatures[player] = self._perform_swap(player, action[1])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Default Player

    def __hash__(self):
>       raise FixableException(
            ""Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id"")
E       common.exceptions.FixableException: Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id

../../../../mge2/mini_game_engine/engine/lib.py:136: FixableException
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
Default Player swapped Bubwool for Dumbird!
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1
","Traceback (most recent call last):
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py"", line 69, in execute
    await self.sdk.execute_as_task(PytestRunnerAgent, verbose=False)
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/volter-common/common/sdk/SDK.py"", line 274, in execute_as_task
    response = await agent.execute()
               ^^^^^^^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/game/pytest_runner_agent/logic.py"", line 27, in execute
    output = run_pytest(test_file_path, project_root=self.sdk.project_directory, verbose=self.verbose)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-std-agents/agent_lib/random_run_utils.py"", line 119, in run_pytest
    raise AssertionError(f""Pytest failed with exit code {exit_code}. Output:\n{output}"")
AssertionError: Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform darwin -- Python 3.11.9, pytest-7.4.4, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: asyncio-0.23.8, html-3.2.0, Faker-30.1.0, env-1.1.3, metadata-3.1.1, cov-4.1.0, anyio-4.4.0, timeout-2.3.1, sugar-0.9.7
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # Increased to 30 for more complex scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            class TransitionFromScene(Exception):
                pass
    
            def exit_scene(*args, **kwargs):
                raise TransitionFromScene()
    
            with patch.object(MainGameScene, '_transition_to_scene', side_effect=exit_scene) as mock_transition, \
                    patch.object(MainGameScene, '_quit_whole_game') as mock_quit:
    
                try:
>                   main_game_scene.run()

main_game/tests/test_main_game_scene.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/scenes/main_game_scene.py:30: in run
    self._resolution_phase(player_action, bot_action)
main_game/scenes/main_game_scene.py:85: in _resolution_phase
    swapped_creatures[player] = self._perform_swap(player, action[1])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Basic Opponent

    def __hash__(self):
>       raise FixableException(
            ""Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id"")
E       common.exceptions.FixableException: Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id

../../../../mge2/mini_game_engine/engine/lib.py:136: FixableException
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
BotListener:on_show_event:show_text: {'text': 'Basic Opponent swapped Scizard for Dumbird!'}
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:552: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:668: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:712: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:24: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:422: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:668: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:712: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:30: in run
    self._resolution_phase(player_action, bot_action)
main_game/scenes/main_game_scene.py:85: in _resolution_phase
    swapped_creatures[player] = self._perform_swap(player, action[1])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Default Player

    def __hash__(self):
>       raise FixableException(
            ""Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id"")
E       common.exceptions.FixableException: Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id

../../../../mge2/mini_game_engine/engine/lib.py:136: FixableException
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
Default Player swapped Bubwool for Dumbird!
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1


During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_bench/bench_utils.py"", line 92, in execute_agent
    asyncio.run(agent.execute())
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py"", line 190, in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py"", line 118, in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/base_events.py"", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py"", line 76, in execute
    raise FixableException(
common.exceptions.FixableException: After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform darwin -- Python 3.11.9, pytest-7.4.4, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: asyncio-0.23.8, html-3.2.0, Faker-30.1.0, env-1.1.3, metadata-3.1.1, cov-4.1.0, anyio-4.4.0, timeout-2.3.1, sugar-0.9.7
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # Increased to 30 for more complex scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            class TransitionFromScene(Exception):
                pass
    
            def exit_scene(*args, **kwargs):
                raise TransitionFromScene()
    
            with patch.object(MainGameScene, '_transition_to_scene', side_effect=exit_scene) as mock_transition, \
                    patch.object(MainGameScene, '_quit_whole_game') as mock_quit:
    
                try:
>                   main_game_scene.run()

main_game/tests/test_main_game_scene.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/scenes/main_game_scene.py:30: in run
    self._resolution_phase(player_action, bot_action)
main_game/scenes/main_game_scene.py:85: in _resolution_phase
    swapped_creatures[player] = self._perform_swap(player, action[1])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Basic Opponent

    def __hash__(self):
>       raise FixableException(
            ""Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id"")
E       common.exceptions.FixableException: Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id

../../../../mge2/mini_game_engine/engine/lib.py:136: FixableException
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
BotListener:on_show_event:show_text: {'text': 'Basic Opponent swapped Scizard for Dumbird!'}
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:552: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:668: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:712: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:24: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:422: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:668: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:712: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:30: in run
    self._resolution_phase(player_action, bot_action)
main_game/scenes/main_game_scene.py:85: in _resolution_phase
    swapped_creatures[player] = self._perform_swap(player, action[1])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Default Player

    def __hash__(self):
>       raise FixableException(
            ""Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id"")
E       common.exceptions.FixableException: Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id

../../../../mge2/mini_game_engine/engine/lib.py:136: FixableException
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
Default Player swapped Bubwool for Dumbird!
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1

",['new_prompt_logs/999755_107198_OneShotCoreAgent'],ladder/creature_battler_05_6/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:27:15,461fbae8-7299-4737-b394-23d1dd772d49,OneShotCoreAgent,creature_battler_05,7,failure,"After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform darwin -- Python 3.11.9, pytest-7.4.4, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: asyncio-0.23.8, html-3.2.0, Faker-30.1.0, env-1.1.3, metadata-3.1.1, cov-4.1.0, anyio-4.4.0, timeout-2.3.1, sugar-0.9.7
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # Increased to 30 for more complex scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            class TransitionFromScene(Exception):
                pass
    
            def exit_scene(*args, **kwargs):
                raise TransitionFromScene()
    
            with patch.object(MainGameScene, '_transition_to_scene', side_effect=exit_scene) as mock_transition, \
                    patch.object(MainGameScene, '_quit_whole_game') as mock_quit:
    
                try:
>                   main_game_scene.run()

main_game/tests/test_main_game_scene.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/scenes/main_game_scene.py:26: in run
    self.resolution_phase()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def resolution_phase(self):
        players = [self.player, self.bot]
        actions = [self.player_action, self.bot_action]
    
        # First, handle all swaps
        for i, (player, action) in enumerate(zip(players, actions)):
>           if action[0] == ""swap"":
E           TypeError: 'NoneType' object is not subscriptable

main_game/scenes/main_game_scene.py:76: TypeError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
BotListener:on_show_event:show_text: {'text': 'Basic Opponent swapped to Dumbird!'}
Bubwool used Tackle and dealt 9 damage!
Bubwool used Tackle and dealt 9 damage!
BotListener:on_show_event:show_text: {'text': 'Basic Opponent was forced to use Scizard!'}
BotListener:on_show_event:show_text: {'text': 'Scizard used Tackle and dealt 8 damage!'}
Bubwool used Tackle and dealt 5 damage!
BotListener:on_show_event:show_text: {'text': 'Scizard used Tackle and dealt 8 damage!'}
Default Player swapped to Dumbird!
BotListener:on_show_event:show_text: {'text': 'Scizard used Tackle and dealt 9 damage!'}
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:552: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:668: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:712: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:24: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:422: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:668: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:712: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:26: in run
    self.resolution_phase()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def resolution_phase(self):
        players = [self.player, self.bot]
        actions = [self.player_action, self.bot_action]
    
        # First, handle all swaps
        for i, (player, action) in enumerate(zip(players, actions)):
>           if action[0] == ""swap"":
E           TypeError: 'NoneType' object is not subscriptable

main_game/scenes/main_game_scene.py:76: TypeError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
Bubwool used Lick and dealt 6 damage!
BotListener:on_show_event:show_text: {'text': 'Scizard used Tackle and dealt 8 damage!'}
BotListener:on_show_event:show_text: {'text': 'Basic Opponent swapped to Dumbird!'}
Bubwool used Lick and dealt 7 damage!
Default Player swapped to Dumbird!
BotListener:on_show_event:show_text: {'text': 'Dumbird used Tackle and dealt 5 damage!'}
----------------------------- Captured stderr call -----------------------------
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1
","Traceback (most recent call last):
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py"", line 69, in execute
    await self.sdk.execute_as_task(PytestRunnerAgent, verbose=False)
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/volter-common/common/sdk/SDK.py"", line 274, in execute_as_task
    response = await agent.execute()
               ^^^^^^^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/game/pytest_runner_agent/logic.py"", line 27, in execute
    output = run_pytest(test_file_path, project_root=self.sdk.project_directory, verbose=self.verbose)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-std-agents/agent_lib/random_run_utils.py"", line 119, in run_pytest
    raise AssertionError(f""Pytest failed with exit code {exit_code}. Output:\n{output}"")
AssertionError: Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform darwin -- Python 3.11.9, pytest-7.4.4, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: asyncio-0.23.8, html-3.2.0, Faker-30.1.0, env-1.1.3, metadata-3.1.1, cov-4.1.0, anyio-4.4.0, timeout-2.3.1, sugar-0.9.7
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # Increased to 30 for more complex scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            class TransitionFromScene(Exception):
                pass
    
            def exit_scene(*args, **kwargs):
                raise TransitionFromScene()
    
            with patch.object(MainGameScene, '_transition_to_scene', side_effect=exit_scene) as mock_transition, \
                    patch.object(MainGameScene, '_quit_whole_game') as mock_quit:
    
                try:
>                   main_game_scene.run()

main_game/tests/test_main_game_scene.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/scenes/main_game_scene.py:26: in run
    self.resolution_phase()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def resolution_phase(self):
        players = [self.player, self.bot]
        actions = [self.player_action, self.bot_action]
    
        # First, handle all swaps
        for i, (player, action) in enumerate(zip(players, actions)):
>           if action[0] == ""swap"":
E           TypeError: 'NoneType' object is not subscriptable

main_game/scenes/main_game_scene.py:76: TypeError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
BotListener:on_show_event:show_text: {'text': 'Basic Opponent swapped to Dumbird!'}
Bubwool used Tackle and dealt 9 damage!
Bubwool used Tackle and dealt 9 damage!
BotListener:on_show_event:show_text: {'text': 'Basic Opponent was forced to use Scizard!'}
BotListener:on_show_event:show_text: {'text': 'Scizard used Tackle and dealt 8 damage!'}
Bubwool used Tackle and dealt 5 damage!
BotListener:on_show_event:show_text: {'text': 'Scizard used Tackle and dealt 8 damage!'}
Default Player swapped to Dumbird!
BotListener:on_show_event:show_text: {'text': 'Scizard used Tackle and dealt 9 damage!'}
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:552: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:668: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:712: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:24: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:422: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:668: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:712: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:26: in run
    self.resolution_phase()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def resolution_phase(self):
        players = [self.player, self.bot]
        actions = [self.player_action, self.bot_action]
    
        # First, handle all swaps
        for i, (player, action) in enumerate(zip(players, actions)):
>           if action[0] == ""swap"":
E           TypeError: 'NoneType' object is not subscriptable

main_game/scenes/main_game_scene.py:76: TypeError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
Bubwool used Lick and dealt 6 damage!
BotListener:on_show_event:show_text: {'text': 'Scizard used Tackle and dealt 8 damage!'}
BotListener:on_show_event:show_text: {'text': 'Basic Opponent swapped to Dumbird!'}
Bubwool used Lick and dealt 7 damage!
Default Player swapped to Dumbird!
BotListener:on_show_event:show_text: {'text': 'Dumbird used Tackle and dealt 5 damage!'}
----------------------------- Captured stderr call -----------------------------
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1


During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_bench/bench_utils.py"", line 92, in execute_agent
    asyncio.run(agent.execute())
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py"", line 190, in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py"", line 118, in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/base_events.py"", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py"", line 76, in execute
    raise FixableException(
common.exceptions.FixableException: After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform darwin -- Python 3.11.9, pytest-7.4.4, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: asyncio-0.23.8, html-3.2.0, Faker-30.1.0, env-1.1.3, metadata-3.1.1, cov-4.1.0, anyio-4.4.0, timeout-2.3.1, sugar-0.9.7
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py .                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # Increased to 30 for more complex scene
    
            player = app.create_player(f""player_{i}"")
            main_game_scene = MainGameScene(app, player)
    
            class TransitionFromScene(Exception):
                pass
    
            def exit_scene(*args, **kwargs):
                raise TransitionFromScene()
    
            with patch.object(MainGameScene, '_transition_to_scene', side_effect=exit_scene) as mock_transition, \
                    patch.object(MainGameScene, '_quit_whole_game') as mock_quit:
    
                try:
>                   main_game_scene.run()

main_game/tests/test_main_game_scene.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/scenes/main_game_scene.py:26: in run
    self.resolution_phase()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def resolution_phase(self):
        players = [self.player, self.bot]
        actions = [self.player_action, self.bot_action]
    
        # First, handle all swaps
        for i, (player, action) in enumerate(zip(players, actions)):
>           if action[0] == ""swap"":
E           TypeError: 'NoneType' object is not subscriptable

main_game/scenes/main_game_scene.py:76: TypeError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
BotListener:on_show_event:show_text: {'text': 'Basic Opponent swapped to Dumbird!'}
Bubwool used Tackle and dealt 9 damage!
Bubwool used Tackle and dealt 9 damage!
BotListener:on_show_event:show_text: {'text': 'Basic Opponent was forced to use Scizard!'}
BotListener:on_show_event:show_text: {'text': 'Scizard used Tackle and dealt 8 damage!'}
Bubwool used Tackle and dealt 5 damage!
BotListener:on_show_event:show_text: {'text': 'Scizard used Tackle and dealt 8 damage!'}
Default Player swapped to Dumbird!
BotListener:on_show_event:show_text: {'text': 'Scizard used Tackle and dealt 9 damage!'}
_____________________ test_full_game_flow_random_with_bots _____________________

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
            human_player = app.create_player(""HumanPlayer"")
            human_player.set_listener(HumanListener())
    
            try:
>               app.run(human_player)

main_game/tests/test_whole_game.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../mge2/mini_game_engine/engine/lib.py:552: in run
    self.transition_to_scene(self.entry_point_scene_id, player=player)
../../../../mge2/mini_game_engine/engine/lib.py:668: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:712: in __run_scene
    scene.run()
main_game/scenes/main_menu_scene.py:24: in run
    self._transition_to_scene(""MainGameScene"")
../../../../mge2/mini_game_engine/engine/lib.py:422: in _transition_to_scene
    self._app.transition_to_scene(scene_name, player=self.player)
../../../../mge2/mini_game_engine/engine/lib.py:668: in transition_to_scene
    self.__run_scene(scene)
../../../../mge2/mini_game_engine/engine/lib.py:712: in __run_scene
    scene.run()
main_game/scenes/main_game_scene.py:26: in run
    self.resolution_phase()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <main_game.scenes.main_game_scene.MainGameScene object at 0x[REDACTED]>

    def resolution_phase(self):
        players = [self.player, self.bot]
        actions = [self.player_action, self.bot_action]
    
        # First, handle all swaps
        for i, (player, action) in enumerate(zip(players, actions)):
>           if action[0] == ""swap"":
E           TypeError: 'NoneType' object is not subscriptable

main_game/scenes/main_game_scene.py:76: TypeError
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
broadcast: {'__type': 'OnGameStart'}
Bubwool used Lick and dealt 6 damage!
BotListener:on_show_event:show_text: {'text': 'Scizard used Tackle and dealt 8 damage!'}
BotListener:on_show_event:show_text: {'text': 'Basic Opponent swapped to Dumbird!'}
Bubwool used Lick and dealt 7 damage!
Default Player swapped to Dumbird!
BotListener:on_show_event:show_text: {'text': 'Dumbird used Tackle and dealt 5 damage!'}
----------------------------- Captured stderr call -----------------------------
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
16:27.15 - mydantic.py:406      - WARNING got a unserializable attribute on the GameEntity MainGameScene named player_action (type=<class 'tuple'>)
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots
========================= 2 failed, 1 passed in [REDACTED]s ==========================
PYTEST_EXIT_CODE: 1

",['new_prompt_logs/999752_125630_OneShotCoreAgent'],ladder/creature_battler_05_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:27:25,0f632699-1246-4230-a638-9a5164eb3ac0,OneShotCoreAgent,creature_battler_04,7,failure,"After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform darwin -- Python 3.11.9, pytest-7.4.4, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: asyncio-0.23.8, html-3.2.0, Faker-30.1.0, env-1.1.3, metadata-3.1.1, cov-4.1.0, anyio-4.4.0, timeout-2.3.1, sugar-0.9.7
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py F                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
>           data = cls.get_data().get(""prototypes"")[prototype_id]
E           KeyError: 'lick'

../../../../mge2/mini_game_engine/engine/lib.py:153: KeyError

The above exception was the direct cause of the following exception:

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # Increased to 30 for more complex scene
    
>           player = app.create_player(f""player_{i}"")

main_game/tests/test_main_game_scene.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/main.py:15: in create_player
    player = Player.from_prototype_id(prototype_id=""default_player"")
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
            data = cls.get_data().get(""prototypes"")[prototype_id]
            data[""prototype_id""] = prototype_id
            data[""category""] = cls.__name__
        except KeyError as e:
>           raise Exception(
                f'The JSON file corresponding to the {cls.__name__} model does not have a prototype entry called: ""{prototype_id}""') from e
E           Exception: The JSON file corresponding to the Skill model does not have a prototype entry called: ""lick""

../../../../mge2/mini_game_engine/engine/lib.py:157: Exception
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
__________ TestMainMenuSceneRandomRun.test_main_menu_scene_random_run __________

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
>           data = cls.get_data().get(""prototypes"")[prototype_id]
E           KeyError: 'lick'

../../../../mge2/mini_game_engine/engine/lib.py:153: KeyError

The above exception was the direct cause of the following exception:

self = <tests.test_main_menu_scene.TestMainMenuSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_menu_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 10
    
>           player = app.create_player(f""player_{i}"")

main_game/tests/test_main_menu_scene.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/main.py:15: in create_player
    player = Player.from_prototype_id(prototype_id=""default_player"")
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
            data = cls.get_data().get(""prototypes"")[prototype_id]
            data[""prototype_id""] = prototype_id
            data[""category""] = cls.__name__
        except KeyError as e:
>           raise Exception(
                f'The JSON file corresponding to the {cls.__name__} model does not have a prototype entry called: ""{prototype_id}""') from e
E           Exception: The JSON file corresponding to the Skill model does not have a prototype entry called: ""lick""

../../../../mge2/mini_game_engine/engine/lib.py:157: Exception
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
_____________________ test_full_game_flow_random_with_bots _____________________

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
>           data = cls.get_data().get(""prototypes"")[prototype_id]
E           KeyError: 'lick'

../../../../mge2/mini_game_engine/engine/lib.py:153: KeyError

The above exception was the direct cause of the following exception:

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
>           human_player = app.create_player(""HumanPlayer"")

main_game/tests/test_whole_game.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/main.py:15: in create_player
    player = Player.from_prototype_id(prototype_id=""default_player"")
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
            data = cls.get_data().get(""prototypes"")[prototype_id]
            data[""prototype_id""] = prototype_id
            data[""category""] = cls.__name__
        except KeyError as e:
>           raise Exception(
                f'The JSON file corresponding to the {cls.__name__} model does not have a prototype entry called: ""{prototype_id}""') from e
E           Exception: The JSON file corresponding to the Skill model does not have a prototype entry called: ""lick""

../../../../mge2/mini_game_engine/engine/lib.py:157: Exception
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run
FAILED main_game/tests/test_main_menu_scene.py::TestMainMenuSceneRandomRun::test_main_menu_scene_random_run
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots
============================== 3 failed in [REDACTED]s ===============================
PYTEST_EXIT_CODE: 1
","Traceback (most recent call last):
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py"", line 69, in execute
    await self.sdk.execute_as_task(PytestRunnerAgent, verbose=False)
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/volter-common/common/sdk/SDK.py"", line 274, in execute_as_task
    response = await agent.execute()
               ^^^^^^^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/game/pytest_runner_agent/logic.py"", line 27, in execute
    output = run_pytest(test_file_path, project_root=self.sdk.project_directory, verbose=self.verbose)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-std-agents/agent_lib/random_run_utils.py"", line 119, in run_pytest
    raise AssertionError(f""Pytest failed with exit code {exit_code}. Output:\n{output}"")
AssertionError: Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform darwin -- Python 3.11.9, pytest-7.4.4, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: asyncio-0.23.8, html-3.2.0, Faker-30.1.0, env-1.1.3, metadata-3.1.1, cov-4.1.0, anyio-4.4.0, timeout-2.3.1, sugar-0.9.7
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py F                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
>           data = cls.get_data().get(""prototypes"")[prototype_id]
E           KeyError: 'lick'

../../../../mge2/mini_game_engine/engine/lib.py:153: KeyError

The above exception was the direct cause of the following exception:

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # Increased to 30 for more complex scene
    
>           player = app.create_player(f""player_{i}"")

main_game/tests/test_main_game_scene.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/main.py:15: in create_player
    player = Player.from_prototype_id(prototype_id=""default_player"")
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
            data = cls.get_data().get(""prototypes"")[prototype_id]
            data[""prototype_id""] = prototype_id
            data[""category""] = cls.__name__
        except KeyError as e:
>           raise Exception(
                f'The JSON file corresponding to the {cls.__name__} model does not have a prototype entry called: ""{prototype_id}""') from e
E           Exception: The JSON file corresponding to the Skill model does not have a prototype entry called: ""lick""

../../../../mge2/mini_game_engine/engine/lib.py:157: Exception
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
__________ TestMainMenuSceneRandomRun.test_main_menu_scene_random_run __________

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
>           data = cls.get_data().get(""prototypes"")[prototype_id]
E           KeyError: 'lick'

../../../../mge2/mini_game_engine/engine/lib.py:153: KeyError

The above exception was the direct cause of the following exception:

self = <tests.test_main_menu_scene.TestMainMenuSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_menu_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 10
    
>           player = app.create_player(f""player_{i}"")

main_game/tests/test_main_menu_scene.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/main.py:15: in create_player
    player = Player.from_prototype_id(prototype_id=""default_player"")
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
            data = cls.get_data().get(""prototypes"")[prototype_id]
            data[""prototype_id""] = prototype_id
            data[""category""] = cls.__name__
        except KeyError as e:
>           raise Exception(
                f'The JSON file corresponding to the {cls.__name__} model does not have a prototype entry called: ""{prototype_id}""') from e
E           Exception: The JSON file corresponding to the Skill model does not have a prototype entry called: ""lick""

../../../../mge2/mini_game_engine/engine/lib.py:157: Exception
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
_____________________ test_full_game_flow_random_with_bots _____________________

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
>           data = cls.get_data().get(""prototypes"")[prototype_id]
E           KeyError: 'lick'

../../../../mge2/mini_game_engine/engine/lib.py:153: KeyError

The above exception was the direct cause of the following exception:

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
>           human_player = app.create_player(""HumanPlayer"")

main_game/tests/test_whole_game.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/main.py:15: in create_player
    player = Player.from_prototype_id(prototype_id=""default_player"")
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
            data = cls.get_data().get(""prototypes"")[prototype_id]
            data[""prototype_id""] = prototype_id
            data[""category""] = cls.__name__
        except KeyError as e:
>           raise Exception(
                f'The JSON file corresponding to the {cls.__name__} model does not have a prototype entry called: ""{prototype_id}""') from e
E           Exception: The JSON file corresponding to the Skill model does not have a prototype entry called: ""lick""

../../../../mge2/mini_game_engine/engine/lib.py:157: Exception
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run
FAILED main_game/tests/test_main_menu_scene.py::TestMainMenuSceneRandomRun::test_main_menu_scene_random_run
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots
============================== 3 failed in [REDACTED]s ===============================
PYTEST_EXIT_CODE: 1


During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_bench/bench_utils.py"", line 92, in execute_agent
    asyncio.run(agent.execute())
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py"", line 190, in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py"", line 118, in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/base_events.py"", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py"", line 76, in execute
    raise FixableException(
common.exceptions.FixableException: After 5 attempts to debug, could not create a bug-free game. Still have error Pytest failed with exit code 1. Output:
============================= test session starts ==============================
platform darwin -- Python 3.11.9, pytest-7.4.4, pluggy-1.5.0
rootdir: [REDACT]/volter-monorepo/packages/lib-volter-mge2
configfile: pytest.ini
plugins: asyncio-0.23.8, html-3.2.0, Faker-30.1.0, env-1.1.3, metadata-3.1.1, cov-4.1.0, anyio-4.4.0, timeout-2.3.1, sugar-0.9.7
asyncio: mode=Mode.STRICT
collected 3 items

main_game/tests/test_main_game_scene.py F                                [ 33%]
main_game/tests/test_main_menu_scene.py F                                [ 66%]
main_game/tests/test_whole_game.py F                                     [100%]

=================================== FAILURES ===================================
__________ TestMainGameSceneRandomRun.test_main_game_scene_random_run __________

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
>           data = cls.get_data().get(""prototypes"")[prototype_id]
E           KeyError: 'lick'

../../../../mge2/mini_game_engine/engine/lib.py:153: KeyError

The above exception was the direct cause of the following exception:

self = <tests.test_main_game_scene.TestMainGameSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # Increased to 30 for more complex scene
    
>           player = app.create_player(f""player_{i}"")

main_game/tests/test_main_game_scene.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/main.py:15: in create_player
    player = Player.from_prototype_id(prototype_id=""default_player"")
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
            data = cls.get_data().get(""prototypes"")[prototype_id]
            data[""prototype_id""] = prototype_id
            data[""category""] = cls.__name__
        except KeyError as e:
>           raise Exception(
                f'The JSON file corresponding to the {cls.__name__} model does not have a prototype entry called: ""{prototype_id}""') from e
E           Exception: The JSON file corresponding to the Skill model does not have a prototype entry called: ""lick""

../../../../mge2/mini_game_engine/engine/lib.py:157: Exception
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
__________ TestMainMenuSceneRandomRun.test_main_menu_scene_random_run __________

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
>           data = cls.get_data().get(""prototypes"")[prototype_id]
E           KeyError: 'lick'

../../../../mge2/mini_game_engine/engine/lib.py:153: KeyError

The above exception was the direct cause of the following exception:

self = <tests.test_main_menu_scene.TestMainMenuSceneRandomRun object at 0x[REDACTED]>
app = <main_game.main.App object at 0x[REDACTED]>

    def test_main_menu_scene_random_run(self, app):
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 10
    
>           player = app.create_player(f""player_{i}"")

main_game/tests/test_main_menu_scene.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/main.py:15: in create_player
    player = Player.from_prototype_id(prototype_id=""default_player"")
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
            data = cls.get_data().get(""prototypes"")[prototype_id]
            data[""prototype_id""] = prototype_id
            data[""category""] = cls.__name__
        except KeyError as e:
>           raise Exception(
                f'The JSON file corresponding to the {cls.__name__} model does not have a prototype entry called: ""{prototype_id}""') from e
E           Exception: The JSON file corresponding to the Skill model does not have a prototype entry called: ""lick""

../../../../mge2/mini_game_engine/engine/lib.py:157: Exception
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
_____________________ test_full_game_flow_random_with_bots _____________________

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
>           data = cls.get_data().get(""prototypes"")[prototype_id]
E           KeyError: 'lick'

../../../../mge2/mini_game_engine/engine/lib.py:153: KeyError

The above exception was the direct cause of the following exception:

    def test_full_game_flow_random_with_bots():
        for i in range(10):
            print(f""starting random run iteration {i}"")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
            App.matchmaking_wait_time = 0
            original_wait_time = App.matchmaking_wait_time
    
            app = App()
    
            # Create a human player
>           human_player = app.create_player(""HumanPlayer"")

main_game/tests/test_whole_game.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
main_game/main.py:15: in create_player
    player = Player.from_prototype_id(prototype_id=""default_player"")
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
../../../../mge2/mini_game_engine/engine/lib.py:159: in from_prototype_id
    return cls._create_from_data(data)
../../../../mge2/mini_game_engine/engine/lib.py:175: in _create_from_data
    return cls(**new_data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:338: in __init__
    super().__init__(**data)
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in __init__
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:74: in <listcomp>
    value = [self._init_nested(item_type, item) for item in value]
../../../../mge2/mini_game_engine/engine/new_mydantic/mydantic.py:95: in _init_nested
    return field_type.from_prototype_id(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'main_game.models.Skill'>, prototype_id = 'lick'

    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """""" During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """"""
        try:
            data = cls.get_data().get(""prototypes"")[prototype_id]
            data[""prototype_id""] = prototype_id
            data[""category""] = cls.__name__
        except KeyError as e:
>           raise Exception(
                f'The JSON file corresponding to the {cls.__name__} model does not have a prototype entry called: ""{prototype_id}""') from e
E           Exception: The JSON file corresponding to the Skill model does not have a prototype entry called: ""lick""

../../../../mge2/mini_game_engine/engine/lib.py:157: Exception
----------------------------- Captured stdout call -----------------------------
starting random run iteration 0
=========================== short test summary info ============================
FAILED main_game/tests/test_main_game_scene.py::TestMainGameSceneRandomRun::test_main_game_scene_random_run
FAILED main_game/tests/test_main_menu_scene.py::TestMainMenuSceneRandomRun::test_main_menu_scene_random_run
FAILED main_game/tests/test_whole_game.py::test_full_game_flow_random_with_bots
============================== 3 failed in [REDACTED]s ===============================
PYTEST_EXIT_CODE: 1

",['new_prompt_logs/999758_389092_OneShotCoreAgent'],ladder/creature_battler_04_7/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:28:22,ee5f745f-32e2-46e3-a0c5-e641fdb7837b,OneShotCoreAgent,creature_battler_05,1,success,,,['new_prompt_logs/999752_458358_OneShotCoreAgent'],ladder/creature_battler_05_1/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:29:27,b861e16c-40f6-4cf8-ae87-6ab2111d64e6,OneShotCoreAgent,creature_battler_05,2,success,,,['new_prompt_logs/999757_119827_OneShotCoreAgent'],ladder/creature_battler_05_2/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:30:07,18c34917-2eb0-414e-a5bb-93f64a00a1ab,OneShotCoreAgent,creature_battler_05,5,failure,"After 5 attempts to debug, could not create an accurate game. Got issue {
  ""issue"": ""A QA pass has detected a problem with the current implementation."",
  ""explanation"": ""The implementation is mostly correct but lacks explicit handling for draw conditions and does not specify how to handle cases when a player has no valid swap options during forced swaps. Additionally, the resetting of creatures' state after a battle is an extra implementation not mentioned in the architecture."",
  ""qa_result"": ""failed""
}","Traceback (most recent call last):
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py"", line 92, in execute
    result = await self.sdk.execute_as_task(
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/volter-common/common/sdk/SDK.py"", line 274, in execute_as_task
    response = await agent.execute()
               ^^^^^^^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/qa/all_qa_code_reader/logic.py"", line 60, in execute
    raise QAException(json.dumps({
mge_agents.qa.all_qa_code_reader.logic.QAException: {
  ""issue"": ""A QA pass has detected a problem with the current implementation."",
  ""explanation"": ""The implementation is mostly correct but lacks explicit handling for draw conditions and does not specify how to handle cases when a player has no valid swap options during forced swaps. Additionally, the resetting of creatures' state after a battle is an extra implementation not mentioned in the architecture."",
  ""qa_result"": ""failed""
}

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_bench/bench_utils.py"", line 92, in execute_agent
    asyncio.run(agent.execute())
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py"", line 190, in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py"", line 118, in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/base_events.py"", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py"", line 98, in execute
    raise FixableException(
common.exceptions.FixableException: After 5 attempts to debug, could not create an accurate game. Got issue {
  ""issue"": ""A QA pass has detected a problem with the current implementation."",
  ""explanation"": ""The implementation is mostly correct but lacks explicit handling for draw conditions and does not specify how to handle cases when a player has no valid swap options during forced swaps. Additionally, the resetting of creatures' state after a battle is an extra implementation not mentioned in the architecture."",
  ""qa_result"": ""failed""
}
",['new_prompt_logs/999759_211049_OneShotCoreAgent'],ladder/creature_battler_05_5/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
2024-10-09 16:31:49,9d44dffb-7f93-4639-b94e-6331efb6a646,OneShotCoreAgent,creature_battler_05,4,failure,"After 5 attempts to debug, could not create an accurate game. Got issue {
  ""issue"": ""A QA pass has detected a problem with the current implementation."",
  ""explanation"": ""The implementation closely follows the described architecture, but there are minor discrepancies. Specifically, the win/loss message is generic and does not explicitly inform the player of their win or loss. Additionally, the state reset of the player's creatures is implemented, but the bot's creatures are not reset, which could lead to inconsistencies."",
  ""qa_result"": ""failed""
}","Traceback (most recent call last):
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py"", line 92, in execute
    result = await self.sdk.execute_as_task(
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/volter-common/common/sdk/SDK.py"", line 274, in execute_as_task
    response = await agent.execute()
               ^^^^^^^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/qa/all_qa_code_reader/logic.py"", line 60, in execute
    raise QAException(json.dumps({
mge_agents.qa.all_qa_code_reader.logic.QAException: {
  ""issue"": ""A QA pass has detected a problem with the current implementation."",
  ""explanation"": ""The implementation closely follows the described architecture, but there are minor discrepancies. Specifically, the win/loss message is generic and does not explicitly inform the player of their win or loss. Additionally, the state reset of the player's creatures is implemented, but the bot's creatures are not reset, which could lead to inconsistencies."",
  ""qa_result"": ""failed""
}

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_bench/bench_utils.py"", line 92, in execute_agent
    asyncio.run(agent.execute())
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py"", line 190, in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py"", line 118, in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/base_events.py"", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File ""/Users/andrewvolter/Desktop/volter-monorepo/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py"", line 98, in execute
    raise FixableException(
common.exceptions.FixableException: After 5 attempts to debug, could not create an accurate game. Got issue {
  ""issue"": ""A QA pass has detected a problem with the current implementation."",
  ""explanation"": ""The implementation closely follows the described architecture, but there are minor discrepancies. Specifically, the win/loss message is generic and does not explicitly inform the player of their win or loss. Additionally, the state reset of the player's creatures is implemented, but the bot's creatures are not reset, which could lead to inconsistencies."",
  ""qa_result"": ""failed""
}
",['new_prompt_logs/999760_678496_OneShotCoreAgent'],ladder/creature_battler_05_4/main_game,https://github.com/volter-ai/volter-monorepo/blob/29d3784aae8668043bd090e4084cf578161bffc9/packages/lib-volter-mge2/mge_agents/one_shot_gen/one_shot_core.py
