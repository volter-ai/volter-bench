Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
The issue occurs when a player's last creature is knocked out and the game tries to show swap choices, but there are no valid creatures to swap to. This creates an empty choices list which triggers the assertion error.

The fix should be in MainGameScene to properly handle this end-game condition. Instead of trying to show swap choices when there are no valid creatures, we should check this condition first and end the battle immediately.

Here's the fixed MainGameScene:

# Excerpt ID: cb7ce265-e305-43a5-949a-8dcc5b481aa7
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        self._reset_creatures()

    def _reset_creatures(self):
        # Reset all creatures to full HP
        for p in [self.player, self.bot]:
            for c in p.creatures:
                c.hp = c.max_hp
            p.active_creature = p.creatures[0]

    def __str__(self):
        p1 = self.player
        p2 = self.bot
        
        return f"""=== Battle ===
{p1.display_name}'s {p1.active_creature.display_name}: {p1.active_creature.hp}/{p1.active_creature.max_hp} HP
{p2.display_name}'s {p2.active_creature.display_name}: {p2.active_creature.hp}/{p2.active_creature.max_hp} HP

> Attack
> Swap
"""

    def _calculate_damage(self, attacker: Creature, defender: Creature, skill):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Type effectiveness
        effectiveness = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf": effectiveness = 2.0
            elif defender.creature_type == "water": effectiveness = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire": effectiveness = 2.0
            elif defender.creature_type == "leaf": effectiveness = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water": effectiveness = 2.0
            elif defender.creature_type == "fire": effectiveness = 0.5
            
        return int(raw_damage * effectiveness)

    def _get_available_creatures(self, player: Player):
        return [c for c in player.creatures if c.hp > 0 and c != player.active_creature]

    def _check_battle_over(self, player: Player) -> bool:
        """Returns True if the player has no creatures left with HP > 0"""
        return all(c.hp <= 0 for c in player.creatures)

    def _handle_knocked_out(self, player: Player):
        # First check if battle is over
        if self._check_battle_over(player):
            return False
            
        available = self._get_available_creatures(player)
        choices = [SelectThing(c) for c in available]
        choice = self._wait_for_choice(player, choices)
        player.active_creature = choice.thing
        return True

    def _execute_turn(self, first_player, first_action, second_player, second_action):
        # Handle swaps first
        for player, action in [(first_player, first_action), (second_player, second_action)]:
            if isinstance(action, Creature):
                player.active_creature = action
                self._show_text(self.player, f"{player.display_name} swapped to {action.display_name}!")

        # Then handle attacks
        for attacker, action in [(first_player, first_action), (second_player, second_action)]:
            if isinstance(action, Creature):
                continue
                
            defender = second_player if attacker == first_player else first_player
            damage = self._calculate_damage(attacker.active_creature, defender.active_creature, action)
            defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
            
            self._show_text(self.player, 
                f"{attacker.display_name}'s {attacker.active_creature.display_name} used {action.display_name}!")
            self._show_text(self.player,
                f"{defender.display_name}'s {defender.active_creature.display_name} took {damage} damage!")
            
            if defender.active_creature.hp == 0:
                self._show_text(self.player,
                    f"{defender.display_name}'s {defender.active_creature.display_name} was knocked out!")
                
                # Check if battle is over before trying to swap
                if self._check_battle_over(defender):
                    return defender
                    
                if not self._handle_knocked_out(defender):
                    return defender
                    
        return None

    def run(self):
        while True:
            # Player turn
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choice = self._wait_for_choice(self.player, [attack_button, swap_button])
            
            player_action = None
            if choice == attack_button:
                skill_choices = [SelectThing(s) for s in self.player.active_creature.skills]
                choice = self._wait_for_choice(self.player, skill_choices)
                player_action = choice.thing
            else:
                available_creatures = self._get_available_creatures(self.player)
                if not available_creatures:
                    # No creatures to swap to, go back to main choices
                    continue
                    
                creature_choices = [SelectThing(c) for c in available_creatures]
                choice = self._wait_for_choice(self.player, creature_choices)
                player_action = choice.thing

            # Bot turn
            if random.random() < 0.2 and self._get_available_creatures(self.bot):  # 20% chance to swap
                bot_action = random.choice(self._get_available_creatures(self.bot))
            else:
                bot_action = random.choice(self.bot.active_creature.skills)

            # Determine turn order
            if (self.player.active_creature.speed > self.bot.active_creature.speed or 
                (self.player.active_creature.speed == self.bot.active_creature.speed and random.random() < 0.5)):
                first_player, first_action = self.player, player_action
                second_player, second_action = self.bot, bot_action
            else:
                first_player, first_action = self.bot, bot_action
                second_player, second_action = self.player, player_action

            # Execute turn
            loser = self._execute_turn(first_player, first_action, second_player, second_action)
            if loser:
                if loser == self.player:
                    self._show_text(self.player, "You lost!")
                else:
                    self._show_text(self.player, "You won!")
                self._transition_to_scene("MainMenuScene")
                return
```

The key changes are:

1. Added `_check_battle_over()` method to properly check if a player has any creatures left
2. Modified `_handle_knocked_out()` to check battle over condition first
3. Added check in the swap choice logic to prevent showing empty choices
4. Modified battle end condition check in `_execute_turn()`

These changes ensure we never try to show empty choices to the player and properly handle the end-game condition when all creatures are knocked out.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
