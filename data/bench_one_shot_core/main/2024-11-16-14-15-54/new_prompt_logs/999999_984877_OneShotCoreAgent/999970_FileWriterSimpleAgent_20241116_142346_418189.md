Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me analyze and fix the issues:

1. Missing "Back" option in player choice phase
- Need to add "Back" button when showing skills or swap choices
- Player should be able to return to main action menu

2. Incomplete bot choice phase
- Bot choice phase should mirror player choice phase exactly
- Bot should make choices through _wait_for_choice just like player

3. Random speed ties
- Need to randomize order when speeds are equal
- Should use random.random() to break speed ties

Here's the fixed MainGameScene:

# Excerpt ID: 55129223-849b-43d5-aedf-d966f7c9f87b
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        self.reset_creatures()

    def reset_creatures(self):
        for p in [self.player, self.bot]:
            for c in p.creatures:
                c.hp = c.max_hp
            p.active_creature = p.creatures[0]

    def __str__(self):
        p1 = self.player
        p2 = self.bot
        
        return f"""=== Battle ===
{p1.display_name}'s {p1.active_creature.display_name}: {p1.active_creature.hp}/{p1.active_creature.max_hp} HP
{p2.display_name}'s {p2.active_creature.display_name}: {p2.active_creature.hp}/{p2.active_creature.max_hp} HP

> Attack
{"> Swap" if self.get_available_creatures(p1) else ""}
"""

    def calculate_damage(self, attacker: Creature, defender: Creature, skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        effectiveness = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf": effectiveness = 2.0
            elif defender.creature_type == "water": effectiveness = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire": effectiveness = 2.0
            elif defender.creature_type == "leaf": effectiveness = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water": effectiveness = 2.0
            elif defender.creature_type == "fire": effectiveness = 0.5

        return int(raw_damage * effectiveness)

    def get_available_creatures(self, player: Player):
        return [c for c in player.creatures if c.hp > 0 and c != player.active_creature]

    def handle_knocked_out(self, player: Player):
        available = self.get_available_creatures(player)
        if not available:
            return False
        
        choices = [SelectThing(c) for c in available]
        choice = self._wait_for_choice(player, choices)
        player.active_creature = choice.thing
        return True

    def get_player_action(self, player: Player):
        while True:
            # Main action choices
            choices = [Button("Attack")]
            if self.get_available_creatures(player):
                choices.append(Button("Swap"))
            
            choice = self._wait_for_choice(player, choices)

            if choice.display_name == "Attack":
                # Show skills with Back option
                choices = [SelectThing(s) for s in player.active_creature.skills]
                choices.append(Button("Back"))
                skill_choice = self._wait_for_choice(player, choices)
                
                if skill_choice.display_name == "Back":
                    continue
                return ("attack", skill_choice.thing)
            else:
                # Show creatures with Back option
                choices = [SelectThing(c) for c in self.get_available_creatures(player)]
                choices.append(Button("Back"))
                creature_choice = self._wait_for_choice(player, choices)
                
                if creature_choice.display_name == "Back":
                    continue
                return ("swap", creature_choice.thing)

    def run(self):
        while True:
            # Player Choice Phase
            player_action = self.get_player_action(self.player)
            
            # Foe Choice Phase
            bot_action = self.get_player_action(self.bot)  # Bot uses same choice system

            # Resolution Phase
            actions = [(self.player, player_action), (self.bot, bot_action)]
            
            # Sort by speed and randomize ties
            actions.sort(key=lambda x: (
                x[1][0] != "swap",  # Swaps always go first
                -x[0].active_creature.speed if x[1][0] != "swap" else 0,
                random.random()  # Random tiebreaker for equal speeds
            ))

            # Execute actions
            for player, (action_type, target) in actions:
                opponent = self.bot if player == self.player else self.player
                
                if action_type == "swap":
                    player.active_creature = target
                    self._show_text(player, f"{player.display_name} swapped to {target.display_name}!")
                else:
                    damage = self.calculate_damage(player.active_creature, opponent.active_creature, target)
                    opponent.active_creature.hp -= damage
                    self._show_text(player, f"{player.active_creature.display_name} used {target.display_name} for {damage} damage!")

                    if opponent.active_creature.hp <= 0:
                        opponent.active_creature.hp = 0
                        if not self.handle_knocked_out(opponent):
                            self._show_text(self.player, f"{player.display_name} wins!")
                            self.reset_creatures()
                            self._quit_whole_game()

```

Key changes:
1. Added get_player_action method that handles both player and bot choices
2. Added "Back" button to skill and creature selection menus
3. Made bot use same choice system as player through _wait_for_choice
4. Added random tiebreaker for equal speeds
5. Improved code organization with separate methods for clarity

This implementation now:
- Fully matches the architecture documentation
- Handles all choice phases properly with Back options
- Treats bot choices identically to player choices
- Properly handles speed ties with randomization
- Stays within engine capabilities
- Maintains clean separation of concerns

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
