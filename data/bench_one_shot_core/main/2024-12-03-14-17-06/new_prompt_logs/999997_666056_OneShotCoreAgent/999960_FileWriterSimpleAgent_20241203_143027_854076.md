Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me plan out the implementation:

1. First, I'll create the data models in `models.py`:
- Skill - Has type, damage, physical/special flag
- Creature - Has stats, type, skills collection
- Player - Has creatures collection and active creature

2. Create JSON files in content folder:
- skill.json - Contains skill prototypes like Tackle, Fireball, etc.
- creature.json - Contains creature prototypes like Bubwool, Scizard, etc. 
- player.json - Contains player prototypes with their creature lists

3. Create the scenes:
- MainMenuScene - Simple menu with Play/Quit options
- MainGameScene - Complex battle scene with phases for player/bot choices and damage resolution

4. Create tests that run random choices through each scene

Here's the implementation:

# Excerpt ID: b4338672-d107-49ce-918c-6c5193501b07
```python main_game/models.py
from __future__ import annotations
from typing import List, Optional
from mini_game_engine.engine.lib import AbstractThing, AbstractPlayer, Collection

class Skill(AbstractThing):
    skill_type: str
    is_physical: bool
    base_damage: int

class Creature(AbstractThing):
    creature_type: str
    hp: int
    max_hp: int
    attack: int
    defense: int 
    sp_attack: int
    sp_defense: int
    speed: int
    skills: Collection[Skill]

class Player(AbstractPlayer):
    creatures: Collection[Creature]
    active_creature: Optional[Creature] = None
```

# Excerpt ID: 708d221d-b4bc-4451-9c76-1b46afc7d1b0
```json main_game/content/skill.json
{
  "prototypes": {
    "tackle": {
      "display_name": "Tackle",
      "description": "Throw yourself at a foe, dealing damage.",
      "skill_type": "normal",
      "is_physical": true,
      "base_damage": 7
    },
    "fireball": {
      "display_name": "Fireball", 
      "description": "Throw fire at a foe, dealing damage.",
      "skill_type": "fire",
      "is_physical": false,
      "base_damage": 5
    },
    "lick": {
      "display_name": "Lick",
      "description": "Lick a foe with a wet tongue, dealing damage.",
      "skill_type": "water", 
      "is_physical": true,
      "base_damage": 5
    }
  }
}
```

# Excerpt ID: b4c1c057-4006-4c38-94e5-94723f0289c2
```json main_game/content/creature.json
{
  "prototypes": {
    "bubwool": {
      "display_name": "Bubwool",
      "description": "A water creature",
      "creature_type": "water",
      "hp": 32,
      "max_hp": 32,
      "attack": 11,
      "defense": 10,
      "sp_attack": 12,
      "sp_defense": 12,
      "speed": 13,
      "skills": ["tackle", "lick"]
    },
    "scizard": {
      "display_name": "Scizard",
      "description": "A fire creature",
      "creature_type": "fire", 
      "hp": 40,
      "max_hp": 40,
      "attack": 11,
      "defense": 13,
      "sp_attack": 11,
      "sp_defense": 13,
      "speed": 11,
      "skills": ["tackle", "fireball"]
    },
    "dumbird": {
      "display_name": "Dumbird",
      "description": "A normal creature",
      "creature_type": "normal",
      "hp": 17,
      "max_hp": 17,
      "attack": 7,
      "defense": 9,
      "sp_attack": 7,
      "sp_defense": 4,
      "speed": 17,
      "skills": ["tackle"]
    }
  }
}
```

# Excerpt ID: c642a2ee-395e-4ceb-8466-7f0e2e474792
```json main_game/content/player.json
{
  "prototypes": {
    "default_player": {
      "display_name": "Default Player",
      "description": "The default human player",
      "creatures": ["bubwool", "dumbird"]
    },
    "basic_opponent": {
      "display_name": "Basic Opponent",
      "description": "A basic bot opponent",
      "creatures": ["scizard", "dumbird"]
    }
  }
}
```

# Excerpt ID: 27215d11-1d59-439a-95d3-bef9a739ce57
```python main_game/scenes/main_menu_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button

class MainMenuScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)

    def __str__(self):
        return """=== Creature Battler Main Menu ===
Welcome! Choose an option:
> Play - Start a battle
> Quit - Exit the game
"""

    def run(self):
        play_button = Button("Play")
        quit_button = Button("Quit") 
        
        choice = self._wait_for_choice(self.player, [play_button, quit_button])
        
        if choice == play_button:
            self._transition_to_scene("MainGameScene")
        else:
            self._quit_whole_game()
```

# Excerpt ID: 76d06167-d9b4-4a41-8360-bc7ba8a178f4
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, SelectThing, Button
from main_game.models import Creature

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        
        # Set initial active creatures
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]

    def __str__(self):
        player_creatures = "\n".join(
            f"{'[ACTIVE] ' if c == self.player.active_creature else ''}{c.display_name} - HP: {c.hp}/{c.max_hp}"
            for c in self.player.creatures
        )
        bot_creatures = "\n".join(
            f"{'[ACTIVE] ' if c == self.bot.active_creature else ''}{c.display_name} - HP: {c.hp}/{c.max_hp}"
            for c in self.bot.creatures
        )
        
        return f"""=== Battle Scene ===
Your Creatures:
{player_creatures}

Opponent's Creatures:
{bot_creatures}

Options:
> Attack - Use a skill
> Swap - Switch active creature
"""

    def run(self):
        while True:
            # Player turn
            player_action = self.get_player_action(self.player)
            if not player_action:
                return
                
            # Bot turn
            bot_action = self.get_player_action(self.bot)
            if not bot_action:
                return
                
            # Resolve actions
            self.resolve_turn(player_action, bot_action)
            
            # Check for battle end
            if self.check_battle_end():
                return

    def get_player_action(self, player):
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        
        choice = self._wait_for_choice(player, [attack_button, swap_button])
        
        if choice == attack_button:
            # Show skills
            skill_choices = [SelectThing(skill) for skill in player.active_creature.skills]
            back_button = Button("Back")
            skill_choice = self._wait_for_choice(player, skill_choices + [back_button])
            
            if skill_choice == back_button:
                return self.get_player_action(player)
                
            return ("attack", skill_choice.thing)
            
        else:
            # Show available creatures
            available_creatures = [
                c for c in player.creatures 
                if c != player.active_creature and c.hp > 0
            ]
            if not available_creatures:
                self._show_text(player, "No other creatures available!")
                return self.get_player_action(player)
                
            creature_choices = [SelectThing(c) for c in available_creatures]
            back_button = Button("Back")
            creature_choice = self._wait_for_choice(player, creature_choices + [back_button])
            
            if creature_choice == back_button:
                return self.get_player_action(player)
                
            return ("swap", creature_choice.thing)

    def resolve_turn(self, player_action, bot_action):
        # Handle swaps first
        if player_action[0] == "swap":
            self.player.active_creature = player_action[1]
        if bot_action[0] == "swap":
            self.bot.active_creature = bot_action[1]
            
        # Then handle attacks
        first_action, second_action = self.get_action_order(player_action, bot_action)
        self.execute_action(first_action)
        self.execute_action(second_action)

    def execute_action(self, action):
        if not action or action[0] != "attack":
            return
            
        skill = action[1]
        attacker = self.player if action[2] == "player" else self.bot
        defender = self.bot if action[2] == "player" else self.player
        
        # Calculate damage
        if skill.is_physical:
            raw_damage = attacker.active_creature.attack + skill.base_damage - defender.active_creature.defense
        else:
            raw_damage = (attacker.active_creature.sp_attack / defender.active_creature.sp_defense) * skill.base_damage
            
        # Apply type effectiveness
        multiplier = self.get_type_multiplier(skill.skill_type, defender.active_creature.creature_type)
        final_damage = int(raw_damage * multiplier)
        
        # Apply damage
        defender.active_creature.hp = max(0, defender.active_creature.hp - final_damage)
        
        # Show result
        self._show_text(self.player, f"{attacker.active_creature.display_name} used {skill.display_name} for {final_damage} damage!")
        
        # Handle knockouts
        if defender.active_creature.hp == 0:
            self.handle_knockout(defender)

    def get_type_multiplier(self, skill_type, creature_type):
        if skill_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(skill_type, {}).get(creature_type, 1.0)

    def get_action_order(self, player_action, bot_action):
        if player_action[0] == "swap" or bot_action[0] == "swap":
            return (player_action, bot_action)
            
        if self.player.active_creature.speed > self.bot.active_creature.speed:
            return ((player_action[0], player_action[1], "player"), (bot_action[0], bot_action[1], "bot"))
        elif self.player.active_creature.speed < self.bot.active_creature.speed:
            return ((bot_action[0], bot_action[1], "bot"), (player_action[0], player_action[1], "player"))
        else:
            if random.random() < 0.5:
                return ((player_action[0], player_action[1], "player"), (bot_action[0], bot_action[1], "bot"))
            else:
                return ((bot_action[0], bot_action[1], "bot"), (player_action[0], player_action[1], "player"))

    def handle_knockout(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if not available_creatures:
            winner = "You" if player == self.bot else "The opponent"
            self._show_text(self.player, f"{winner} won the battle!")
            self._transition_to_scene("MainMenuScene")
            return
            
        creature_choices = [SelectThing(c) for c in available_creatures]
        self._show_text(player, f"{player.active_creature.display_name} was knocked out! Choose a new creature!")
        new_creature = self._wait_for_choice(player, creature_choices).thing
        player.active_creature = new_creature

    def check_battle_end(self):
        player_alive = any(c.hp > 0 for c in self.player.creatures)
        bot_alive = any(c.hp > 0 for c in self.bot.creatures)
        
        if not player_alive or not bot_alive:
            winner = "You" if bot_alive else "The opponent"
            self._show_text(self.player, f"{winner} won the battle!")
            self._transition_to_scene("MainMenuScene")
            return True
            
        return False
```

# Excerpt ID: db5713b7-9b2e-44f8-9b57-01684100b931
```python main_game/main.py
from mini_game_engine.engine.lib import AbstractApp, HumanListener, BotListener
from main_game.models import Player
from main_game.scenes.main_menu_scene import MainMenuScene
from main_game.scenes.main_game_scene import MainGameScene

class App(AbstractApp):
    def __init__(self):
        super().__init__()
        self.register_scene("MainMenuScene", MainMenuScene, is_entry_point=True)
        self.register_scene("MainGameScene", MainGameScene)

    def create_player(self, player_id: str):
        player = Player.from_prototype_id("default_player")
        player.uid = player_id
        player.set_listener(HumanListener())
        return player

    def create_bot(self, prototype_id: str):
        bot = Player.from_prototype_id(prototype_id)
        bot.uid = str(uuid.uuid4())
        bot.set_listener(BotListener())
        return bot

if __name__ == '__main__':
    app = App()
    app.run(app.create_player("player1"))
```

# Excerpt ID: fb363c69-29c4-4b46-bf92-1518f62657a8
```python main_game/tests/test_main_menu_scene.py
import pytest
from mini_game_engine.engine.lib import HumanListener, RandomModeGracefulExit
from main_game.scenes.main_menu_scene import MainMenuScene
from main_game.main import App
from unittest.mock import patch

def test_main_menu_scene_random_run():
    app = App()
    
    for i in range(10):
        HumanListener.random_mode = True
        HumanListener.random_mode_counter = 10
        
        player = app.create_player(f"test_player_{i}")
        scene = MainMenuScene(app, player)
        
        with patch.object(MainMenuScene, '_transition_to_scene') as mock_transition, \
             patch.object(MainMenuScene, '_quit_whole_game') as mock_quit:
            
            try:
                scene.run()
            except RandomModeGracefulExit:
                print(f"Random mode completed run {i}")
            finally:
                assert mock_transition.called or mock_quit.called
```

# Excerpt ID: 4fb6aa0b-96c1-4a67-bb69-2d895283850b
```python main_game/tests/test_main_game_scene.py
import pytest
from mini_game_engine.engine.lib import HumanListener, RandomModeGracefulExit
from main_game.scenes.main_game_scene import MainGameScene
from main_game.main import App
from unittest.mock import patch

def test_main_game_scene_random_run():
    app = App()
    
    for i in range(10):
        HumanListener.random_mode = True
        HumanListener.random_mode_counter = 30  # More moves needed for complex battle scene
        
        player = app.create_player(f"test_player_{i}")
        scene = MainGameScene(app, player)
        
        with patch.object(MainGameScene, '_transition_to_scene') as mock_transition, \
             patch.object(MainGameScene, '_quit_whole_game') as mock_quit:
            
            try:
                scene.run()
            except RandomModeGracefulExit:
                print(f"Random mode completed run {i}")
            finally:
                assert mock_transition.called or mock_quit.called
```

This completes all the necessary files for the game implementation. The structure follows the engine guidelines with:

1. Models defined as pure data schemas inheriting from AbstractThing/AbstractPlayer
2. JSON files containing all prototype data
3. Scenes handling all game logic
4. Tests using random mode to verify scene functionality
5. Main app class registering scenes and handling player/bot creation

The game implements all the required features:
- Turn-based creature battles
- Physical/Special attack calculations
- Type effectiveness system
- Creature swapping
- Battle win/loss conditions
- Bot opponent AI

The code follows all guidelines regarding scene transitions, model references, and bot handling. Let me know if you need any clarification or have questions about specific parts of the implementation.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
