Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis and Solution:
The issue is in MainGameScene where we're trying to access `action.player` but `SelectThing` doesn't have this information. We need to track which player made which action when getting player/bot actions.

The solution is to create a simple action tuple in the MainGameScene that pairs the player with their selected action. This keeps the models pure while allowing us to track action ownership in the scene logic.

2. Here's the fixed MainGameScene file:

# Excerpt ID: ad6686df-2214-42cb-a0fc-8fd298071b0e
```python main_game/scenes/main_game_scene.py
from typing import Tuple, NamedTuple
import random
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Creature, Player

class PlayerAction(NamedTuple):
    player: Player
    action: SelectThing

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        
        # Set initial active creatures
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]

    def __str__(self):
        player_creature = self.player.active_creature
        bot_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {player_creature.display_name}: {player_creature.hp}/{player_creature.max_hp} HP
Foe's {bot_creature.display_name}: {bot_creature.hp}/{bot_creature.max_hp} HP

Your creatures: {[c.display_name for c in self.player.creatures]}
Foe's creatures: {[c.display_name for c in self.bot.creatures]}"""

    def run(self):
        while True:
            # Player turn
            player_action = PlayerAction(self.player, self.get_player_action(self.player))
            bot_action = PlayerAction(self.bot, self.get_player_action(self.bot))
            
            # Resolve actions
            self.resolve_actions(player_action, bot_action)
            
            # Check for battle end
            if self.check_battle_end():
                break

    def get_player_action(self, player):
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        
        choice = self._wait_for_choice(player, [attack_button, swap_button])
        
        if choice == attack_button:
            # Show skills
            skill_choices = [SelectThing(skill) for skill in player.active_creature.skills]
            return self._wait_for_choice(player, skill_choices)
        else:
            # Show creatures for swap
            available_creatures = [
                c for c in player.creatures 
                if c != player.active_creature and c.hp > 0
            ]
            creature_choices = [SelectThing(c) for c in available_creatures]
            return self._wait_for_choice(player, creature_choices)

    def resolve_actions(self, player_action: PlayerAction, bot_action: PlayerAction):
        # Handle swaps first
        if isinstance(player_action.action.thing, Creature):
            self.player.active_creature = player_action.action.thing
        if isinstance(bot_action.action.thing, Creature):
            self.bot.active_creature = bot_action.action.thing
            
        # Then handle attacks
        first, second = self.get_action_order(player_action, bot_action)
        self.execute_action(first)
        self.execute_action(second)
        
        # Force swaps for fainted creatures
        self.handle_fainted_creatures()

    def execute_action(self, action: PlayerAction):
        if isinstance(action.action.thing, Creature):
            return # Swap already handled
            
        attacker = action.player
        defender = self.bot if attacker == self.player else self.player
        
        skill = action.action.thing
        damage = self.calculate_damage(skill, attacker.active_creature, defender.active_creature)
        defender.active_creature.hp = max(0, defender.active_creature.hp - damage)

    def calculate_damage(self, skill, attacker, defender):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Apply type effectiveness
        multiplier = self.get_type_multiplier(skill.skill_type, defender.creature_type)
        
        return int(raw_damage * multiplier)

    def get_type_multiplier(self, attack_type, defend_type):
        if attack_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(attack_type, {}).get(defend_type, 1.0)

    def get_action_order(self, player_action: PlayerAction, bot_action: PlayerAction):
        if isinstance(player_action.action.thing, Creature) or isinstance(bot_action.action.thing, Creature):
            return (player_action, bot_action) # Swaps always go first
            
        if self.player.active_creature.speed > self.bot.active_creature.speed:
            return (player_action, bot_action)
        elif self.player.active_creature.speed < self.bot.active_creature.speed:
            return (bot_action, player_action)
        else:
            return (player_action, bot_action) if random.random() < 0.5 else (bot_action, player_action)

    def handle_fainted_creatures(self):
        for player in [self.player, self.bot]:
            if player.active_creature.hp <= 0:
                available = [c for c in player.creatures if c.hp > 0]
                if available:
                    choices = [SelectThing(c) for c in available]
                    choice = self._wait_for_choice(player, choices)
                    player.active_creature = choice.thing

    def check_battle_end(self):
        player_alive = any(c.hp > 0 for c in self.player.creatures)
        bot_alive = any(c.hp > 0 for c in self.bot.creatures)
        
        if not player_alive or not bot_alive:
            winner = "You win!" if player_alive else "You lose!"
            self._show_text(self.player, winner)
            return True
            
        return False
```

The key changes are:
1. Added a PlayerAction NamedTuple to track which player made which action
2. Modified run() to wrap actions with PlayerAction
3. Updated resolve_actions() and execute_action() to use PlayerAction
4. Updated get_action_order() to handle PlayerAction

This solution:
- Keeps models pure by handling action ownership in the scene
- Maintains the engine's architecture 
- Fixes the AttributeError by properly tracking which player made which action
- Doesn't require any changes to the models or other parts of the codebase

The rest of the battle logic remains unchanged, we just properly track action ownership now.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
