Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The error occurs because MainGameScene ends without properly transitioning or quitting. When the battle ends (win or lose), we just break from the loop instead of properly ending the game flow. According to the engine requirements, we must either:
- Transition to another scene using `_transition_to_scene()`
- End the game using `_quit_whole_game()`

The fix is simple: in MainGameScene, when the battle ends (win or lose), we should call `_quit_whole_game()` to properly end the game flow.

2. Here's the fixed MainGameScene:

# Excerpt ID: c7c5f9a1-56d5-4f6d-ab7f-325dd5bfe8a8
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""=== Battle ===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available Skills:
{' '.join([f'> {skill.display_name}' for skill in self.player_creature.skills])}
"""

    def run(self):
        while True:
            # Player Choice Phase
            player_skill = self._handle_player_turn()
            
            # Opponent Choice Phase
            opponent_skill = self._handle_opponent_turn()
            
            # Resolution Phase
            self._resolve_turn(player_skill, opponent_skill)
            
            # Check for battle end
            if self._check_battle_end():
                self._quit_whole_game()  # <-- Added proper game end

    def _handle_player_turn(self):
        choices = [Button(skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return next(skill for skill in self.player_creature.skills 
                   if skill.display_name == choice.display_name)

    def _handle_opponent_turn(self):
        choices = [Button(skill.display_name) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return next(skill for skill in self.opponent_creature.skills 
                   if skill.display_name == choice.display_name)

    def _calculate_damage(self, attacker, defender, skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        
        type_multiplier = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf": type_multiplier = 2.0
            elif defender.creature_type == "water": type_multiplier = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire": type_multiplier = 2.0
            elif defender.creature_type == "leaf": type_multiplier = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water": type_multiplier = 2.0
            elif defender.creature_type == "fire": type_multiplier = 0.5
            
        return int(raw_damage * type_multiplier)

    def _resolve_turn(self, player_skill, opponent_skill):
        first, second = (self.player_creature, player_skill), (self.opponent_creature, opponent_skill)
        
        if self.opponent_creature.speed > self.player_creature.speed:
            first, second = second, first
        elif self.opponent_creature.speed == self.player_creature.speed:
            if random.random() < 0.5:
                first, second = second, first
                
        # First attack
        attacker, skill = first
        defender = self.opponent_creature if attacker == self.player_creature else self.player_creature
        damage = self._calculate_damage(attacker, defender, skill)
        defender.hp = max(0, defender.hp - damage)
        self._show_text(self.player, f"{attacker.display_name} used {skill.display_name} for {damage} damage!")
        
        if defender.hp > 0:
            # Second attack
            attacker, skill = second
            defender = self.opponent_creature if attacker == self.player_creature else self.player_creature
            damage = self._calculate_damage(attacker, defender, skill)
            defender.hp = max(0, defender.hp - damage)
            self._show_text(self.player, f"{attacker.display_name} used {skill.display_name} for {damage} damage!")

    def _check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, "You lost!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, "You won!")
            return True
        return False
```

The key change is in the `run()` method where we now properly end the game with `self._quit_whole_game()` when the battle ends. This ensures we follow the engine's requirements for proper scene termination.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
