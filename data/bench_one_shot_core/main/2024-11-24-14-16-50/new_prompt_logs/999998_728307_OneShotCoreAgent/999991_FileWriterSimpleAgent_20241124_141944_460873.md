Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis and Solution:
The issue is that the MainGameScene isn't properly implementing the queuing system described in the architecture. According to the docs, we should:
1. Queue the player's skill choice during Player Choice Phase
2. Queue the bot's skill choice during Foe Choice Phase
3. Resolve all queued skills during Resolution Phase

To fix this, I'll:
1. Create a proper queue in MainGameScene to store skills
2. Split the turn phases into distinct methods
3. Only resolve skills during the resolution phase
4. Keep track of which skill belongs to which creature in the queue

Here's the fixed implementation:

# Excerpt ID: a162e9ef-5570-43b8-aecb-613b1c5056d9
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, DictionaryChoice
from typing import NamedTuple

class QueuedSkill(NamedTuple):
    skill: 'Skill'
    user: 'Creature'
    target: 'Creature'

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("default_player")
        self.player_creature = player.creatures[0]
        self.bot_creature = self.bot.creatures[0]
        self.skill_queue: list[QueuedSkill] = []

    def __str__(self):
        queue_str = "\nQueued Actions:"
        if self.skill_queue:
            for queued in self.skill_queue:
                queue_str += f"\n> {queued.user.display_name} will use {queued.skill.display_name} on {queued.target.display_name}"
        else:
            queue_str += "\n> No actions queued"
            
        return f"""=== Battle Scene ===
Your {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
Foe {self.bot_creature.display_name}: HP {self.bot_creature.hp}/{self.bot_creature.max_hp}

Available Skills:
{chr(10).join([f"> {skill.display_name} - {skill.description}" for skill in self.player_creature.skills])}
{queue_str}
"""

    def run(self):
        self._show_text(self.player, "A wild creature appears!")
        
        while True:
            # Clear queue at start of turn
            self.skill_queue.clear()
            
            # Player Choice Phase
            self._player_choice_phase()
            
            # Foe Choice Phase
            self._foe_choice_phase()
            
            # Resolution Phase
            self._resolution_phase()
            
            # Check win condition
            if self.player_creature.hp <= 0:
                self._show_text(self.player, "You lost!")
                break
            elif self.bot_creature.hp <= 0:
                self._show_text(self.player, "You won!")
                break

        # Reset creatures before leaving
        self.player_creature.hp = self.player_creature.max_hp
        self.bot_creature.hp = self.bot_creature.max_hp
        self._transition_to_scene("MainMenuScene")

    def _player_choice_phase(self):
        """Player Choice Phase - Queue player's chosen skill"""
        choices = [DictionaryChoice(skill.display_name) for skill in self.player_creature.skills]
        for choice, skill in zip(choices, self.player_creature.skills):
            choice.value = {"skill": skill}
        
        choice = self._wait_for_choice(self.player, choices)
        chosen_skill = choice.value["skill"]
        
        self.skill_queue.append(QueuedSkill(
            skill=chosen_skill,
            user=self.player_creature,
            target=self.bot_creature
        ))
        self._show_text(self.player, f"You chose {chosen_skill.display_name}!")

    def _foe_choice_phase(self):
        """Foe Choice Phase - Queue bot's chosen skill"""
        choices = [DictionaryChoice(skill.display_name) for skill in self.bot_creature.skills]
        for choice, skill in zip(choices, self.bot_creature.skills):
            choice.value = {"skill": skill}
        
        choice = self._wait_for_choice(self.bot, choices)
        chosen_skill = choice.value["skill"]
        
        self.skill_queue.append(QueuedSkill(
            skill=chosen_skill,
            user=self.bot_creature,
            target=self.player_creature
        ))
        self._show_text(self.player, f"Foe chose {chosen_skill.display_name}!")

    def _resolution_phase(self):
        """Resolution Phase - Resolve all queued skills"""
        self._show_text(self.player, "=== Resolution Phase ===")
        
        while self.skill_queue:
            queued = self.skill_queue.pop(0)
            queued.target.hp -= queued.skill.damage
            self._show_text(self.player, 
                f"{queued.user.display_name} used {queued.skill.display_name} on {queued.target.display_name}!")
```

Key changes:
1. Added QueuedSkill class to track skill, user, and target
2. Created skill_queue to store queued actions
3. Split logic into three distinct phase methods
4. Added queue status to __str__ display
5. Clear queue at start of each turn
6. Process skills in order during resolution phase
7. Maintained pure data models by keeping all logic in scene

This implementation now properly follows the architecture's queuing system while maintaining the engine's guidelines.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
