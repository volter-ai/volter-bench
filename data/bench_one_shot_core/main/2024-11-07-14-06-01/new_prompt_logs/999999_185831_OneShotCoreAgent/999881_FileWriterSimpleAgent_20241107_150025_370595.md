Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
To address the issue of speed ties not being handled according to the specified logic, we need to modify the MainGameScene to implement random order decision when creatures have the same speed. Here's how we'll fix this:

1. We'll add a method to determine the turn order, which will use random selection when speeds are equal.
2. We'll modify the resolve_turn method to use this new turn order determination.

This change doesn't require any modifications to the models, as it's purely a logic change within the scene. Here's the updated MainGameScene file with the proposed solution:

# Excerpt ID: d21c02c3-24d3-4931-a419-21c238cb82d0
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.battle_ended = False

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}: {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
{self.opponent.display_name}: {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Your turn! Choose a skill:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appeared!")
        
        while not self.battle_ended:
            # Player turn
            player_skill = self.player_turn()
            
            # Opponent turn
            opponent_skill = self.opponent_turn()
            
            # Resolve turn
            self.resolve_turn(player_skill, opponent_skill)
            
            # Check for battle end
            self.check_battle_end()

        self.reset_creatures()
        self._transition_to_scene("MainMenuScene")

    def player_turn(self):
        choices = [SelectThing(skill) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def opponent_turn(self):
        choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def determine_turn_order(self):
        if self.player_creature.speed > self.opponent_creature.speed:
            return [self.player, self.opponent]
        elif self.player_creature.speed < self.opponent_creature.speed:
            return [self.opponent, self.player]
        else:
            # Random decision when speeds are equal
            return random.sample([self.player, self.opponent], 2)

    def resolve_turn(self, player_skill, opponent_skill):
        turn_order = self.determine_turn_order()
        
        for attacker in turn_order:
            if attacker == self.player:
                attacker_creature = self.player_creature
                defender_creature = self.opponent_creature
                skill = player_skill
            else:
                attacker_creature = self.opponent_creature
                defender_creature = self.player_creature
                skill = opponent_skill

            self.execute_skill(attacker, attacker_creature, skill, defender_creature)
            
            if defender_creature.hp == 0:
                break

    def execute_skill(self, attacker, attacker_creature, skill, defender_creature):
        damage = self.calculate_damage(attacker_creature, skill, defender_creature)
        defender_creature.hp = max(0, defender_creature.hp - damage)
        self._show_text(attacker, f"{attacker_creature.display_name} used {skill.display_name}! It dealt {damage} damage.")

    def calculate_damage(self, attacker, skill, defender):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
        
        type_factor = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(type_factor * raw_damage)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def get_type_effectiveness(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def check_battle_end(self):
        if self.player_creature.hp == 0:
            self._show_text(self.player, "You lost the battle!")
            self.battle_ended = True
        elif self.opponent_creature.hp == 0:
            self._show_text(self.player, "You won the battle!")
            self.battle_ended = True

    def reset_creatures(self):
        for creature in self.player.creatures + self.opponent.creatures:
            creature.hp = creature.max_hp
```

This updated implementation addresses the issue by introducing a `determine_turn_order` method that handles speed ties correctly. When the speeds are equal, it uses `random.sample` to randomly decide the order of turns. The `resolve_turn` method has been updated to use this new turn order determination, ensuring that the battle logic aligns with the specified architecture.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
