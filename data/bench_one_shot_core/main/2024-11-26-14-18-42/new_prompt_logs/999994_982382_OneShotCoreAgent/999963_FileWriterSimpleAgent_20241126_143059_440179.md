Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The error occurs when trying to get choices for swapping creatures. The assertion fails because `creature_choices` is empty, meaning there are no valid creatures to swap to. This happens when:
- All non-active creatures are knocked out (hp = 0)
- Or when trying to swap but having no other creatures available

The fix needs to:
1. Check if there are any valid swap options before offering the swap choice
2. Only show "Swap" as an initial choice if there are valid creatures to swap to
3. Handle the case where a creature is knocked out but there are no valid swaps (this should trigger game end)

This requires modifying the MainGameScene to check for available creatures before showing the swap option.

2. Here's the fixed MainGameScene:

# Excerpt ID: 91ceb9fd-f594-453c-b6ad-5a293fad9c46
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Creature

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        
        # Set initial active creatures
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]

    def __str__(self):
        player_creatures_status = "\n".join(
            f"{c.display_name}: {c.hp}/{c.max_hp} HP" 
            for c in self.player.creatures
        )
        opponent_creatures_status = "\n".join(
            f"{c.display_name}: {c.hp}/{c.max_hp} HP"
            for c in self.opponent.creatures
        )
        
        return f"""=== Battle ===
Your Active: {self.player.active_creature.display_name} ({self.player.active_creature.hp}/{self.player.active_creature.max_hp} HP)
Opponent's Active: {self.opponent.active_creature.display_name} ({self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp} HP)

Your Team:
{player_creatures_status}

Opponent's Team:
{opponent_creatures_status}"""

    def run(self):
        while True:
            # Check for knocked out creatures and force swaps
            if self.player.active_creature.hp <= 0:
                if not self.handle_forced_swap(self.player):
                    break
            if self.opponent.active_creature.hp <= 0:
                if not self.handle_forced_swap(self.opponent):
                    break

            # Player turn
            player_action = self.get_turn_action(self.player)
            opponent_action = self.get_turn_action(self.opponent)
            
            # Resolve actions
            self.resolve_turn(player_action, opponent_action)
            
            # Check for battle end
            if self.check_battle_end():
                break

    def get_available_creatures(self, player):
        return [
            c for c in player.creatures 
            if c != player.active_creature and c.hp > 0
        ]

    def handle_forced_swap(self, player):
        """Handle forced swap when active creature is knocked out.
        Returns False if no valid swaps available (game over)."""
        available = self.get_available_creatures(player)
        if not available:
            return False
            
        creature_choices = [SelectThing(c) for c in available]
        choice = self._wait_for_choice(player, creature_choices)
        player.active_creature = choice.thing
        return True

    def get_turn_action(self, player):
        choices = [Button("Attack")]
        
        # Only add swap option if there are creatures to swap to
        available_creatures = self.get_available_creatures(player)
        if available_creatures:
            choices.append(Button("Swap"))
        
        choice = self._wait_for_choice(player, choices)
        
        if choice.display_name == "Attack":
            # Show skills
            skill_choices = [SelectThing(skill) for skill in player.active_creature.skills]
            return self._wait_for_choice(player, skill_choices)
        else:
            # Show available creatures
            creature_choices = [SelectThing(c) for c in available_creatures]
            return self._wait_for_choice(player, creature_choices)

    def resolve_turn(self, player_action, opponent_action):
        # Handle swaps first
        if isinstance(player_action.thing, Creature):
            self.player.active_creature = player_action.thing
        if isinstance(opponent_action.thing, Creature):
            self.opponent.active_creature = opponent_action.thing
            
        # Then handle attacks
        if not isinstance(player_action.thing, Creature):
            self.resolve_attack(self.player, self.opponent, player_action.thing)
        if not isinstance(opponent_action.thing, Creature):
            self.resolve_attack(self.opponent, self.player, opponent_action.thing)

    def resolve_attack(self, attacker, defender, skill):
        # Calculate damage
        if skill.is_physical:
            raw_damage = (
                attacker.active_creature.attack + 
                skill.base_damage - 
                defender.active_creature.defense
            )
        else:
            raw_damage = (
                skill.base_damage * 
                attacker.active_creature.sp_attack / 
                defender.active_creature.sp_defense
            )
            
        # Apply type effectiveness
        multiplier = self.get_type_multiplier(
            skill.skill_type, 
            defender.active_creature.creature_type
        )
        
        final_damage = int(raw_damage * multiplier)
        defender.active_creature.hp = max(0, defender.active_creature.hp - final_damage)
        
        self._show_text(
            attacker,
            f"{attacker.active_creature.display_name} used {skill.display_name}! "
            f"Dealt {final_damage} damage!"
        )

    def get_type_multiplier(self, attack_type, defend_type):
        if attack_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(attack_type, {}).get(defend_type, 1.0)

    def check_battle_end(self):
        player_has_creatures = any(c.hp > 0 for c in self.player.creatures)
        opponent_has_creatures = any(c.hp > 0 for c in self.opponent.creatures)
        
        if not player_has_creatures:
            self._show_text(self.player, "You lost the battle!")
            return True
        elif not opponent_has_creatures:
            self._show_text(self.player, "You won the battle!")
            return True
            
        return False
```

Key changes:
1. Added `get_available_creatures()` helper method to centralize creature availability logic
2. Added `handle_forced_swap()` method to handle knocked out creatures
3. Modified `get_turn_action()` to only show swap option when valid swaps exist
4. Added checks at the start of each turn for knocked out creatures
5. Simplified the scene's __str__ output to be cleaner

This should resolve the empty choices assertion error while maintaining proper game flow and staying within the engine's capabilities.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
