Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The error occurs in `_resolve_turn` where we try to unpack 3 values (attacker, defender, skill) but only have 2. This is happening because in `_determine_order`, we're returning tuples with incorrect structure.

The issue is in this line:
# Excerpt ID: 99d2a2c4-80fd-4376-a484-10588d62ff63
```python
return (pair1, (creature2, creature2, skill2))
```

We're creating inconsistent tuple structures. The first part (pair1) has 2 elements while we're trying to unpack 3 elements later. We need to fix the return structure to consistently return 3-element tuples representing (attacker, defender, skill).

2. Here's the fixed MainGameScene with the corrected _determine_order method:

# Excerpt ID: 342f739f-4f9d-4a68-a3b7-97c19c653dd5
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random
import math

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        
    def __str__(self):
        return f"""=== Battle ===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available Skills:
{', '.join(skill.display_name for skill in self.player_creature.skills)}
"""

    def run(self):
        self._show_text(self.player, "Battle Start!")
        
        while True:
            # Player phase
            player_skill = self._handle_player_turn()
            
            # Opponent phase
            opponent_skill = self._handle_opponent_turn()
            
            # Resolution phase
            self._resolve_turn(player_skill, opponent_skill)
            
            # Check win condition
            if self._check_battle_end():
                break

    def _handle_player_turn(self):
        choices = [SelectThing(skill) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def _handle_opponent_turn(self):
        choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def _calculate_damage(self, attacker, defender, skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        
        # Type effectiveness
        multiplier = self._get_type_multiplier(skill.skill_type, defender.creature_type)
        
        return int(raw_damage * multiplier)

    def _get_type_multiplier(self, skill_type, creature_type):
        if skill_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(skill_type, {}).get(creature_type, 1.0)

    def _resolve_turn(self, player_skill, opponent_skill):
        # Determine order
        first, second = self._determine_order(
            (self.player_creature, self.opponent_creature, player_skill),
            (self.opponent_creature, self.player_creature, opponent_skill)
        )
        
        # Execute skills in order
        for attacker, defender, skill in [first, second]:
            damage = self._calculate_damage(attacker, defender, skill)
            defender.hp = max(0, defender.hp - damage)
            
            self._show_text(self.player, 
                f"{attacker.display_name} used {skill.display_name}! "
                f"Dealt {damage} damage to {defender.display_name}!")

    def _determine_order(self, action1, action2):
        """
        Takes two tuples of (attacker, defender, skill) and returns them in speed order
        """
        attacker1, defender1, skill1 = action1
        attacker2, defender2, skill2 = action2
        
        if attacker1.speed > attacker2.speed:
            return action1, action2
        elif attacker2.speed > attacker1.speed:
            return action2, action1
        else:
            if random.random() < 0.5:
                return action1, action2
            return action2, action1

    def _check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, "You lost the battle!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, "You won the battle!")
            return True
        return False
```

The key changes are:
1. In `_resolve_turn`, we now pass complete (attacker, defender, skill) tuples to `_determine_order`
2. `_determine_order` now properly handles and returns these 3-element tuples
3. The order logic remains the same, but the data structure is now consistent throughout

This maintains the same game logic while fixing the tuple unpacking error. The fix stays within the engine's capabilities and doesn't require any changes to the models or architecture.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
