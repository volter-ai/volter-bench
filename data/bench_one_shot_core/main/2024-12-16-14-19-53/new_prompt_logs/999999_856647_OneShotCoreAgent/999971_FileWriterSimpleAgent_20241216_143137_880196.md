Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
I'll fix the issue with the speed tie-breaking in MainGameScene. The architecture document specifically states:

"If the creatures have the same speed, then which creature goes first is decided randomly, with either creature having equal chance of being picked to go first."

The current implementation only checks which speed is higher but doesn't handle equal speeds correctly. I'll modify the execute_turn method in MainGameScene to properly randomize the order when speeds are equal.

Here's the fixed MainGameScene:

# Excerpt ID: 82476aa1-3ba7-4f13-8f68-642a2c63f2c2
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, DictionaryChoice
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        self.player_creature = player.creatures[0]
        self.bot_creature = self.bot.creatures[0]
        self.reset_creatures()

    def reset_creatures(self):
        self.player_creature.hp = self.player_creature.max_hp
        self.bot_creature.hp = self.bot_creature.max_hp

    def __str__(self):
        return f"""=== Battle ===
Your {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
Foe {self.bot_creature.display_name}: HP {self.bot_creature.hp}/{self.bot_creature.max_hp}

Available Skills:
{chr(10).join([f"> {skill.display_name}" for skill in self.player_creature.skills])}
"""

    def calculate_damage(self, attacker, defender, skill):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        # Calculate type multiplier
        multiplier = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf": multiplier = 2.0
            elif defender.creature_type == "water": multiplier = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire": multiplier = 2.0
            elif defender.creature_type == "leaf": multiplier = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water": multiplier = 2.0
            elif defender.creature_type == "fire": multiplier = 0.5

        return int(raw_damage * multiplier)

    def execute_turn(self, player_skill, bot_skill):
        # Determine order based on speed with random tiebreaker
        if self.player_creature.speed > self.bot_creature.speed:
            first = self.player_creature
            second = self.bot_creature
            first_skill = player_skill
            second_skill = bot_skill
        elif self.player_creature.speed < self.bot_creature.speed:
            first = self.bot_creature
            second = self.player_creature
            first_skill = bot_skill
            second_skill = player_skill
        else:
            # Random tiebreaker when speeds are equal
            if random.random() < 0.5:
                first = self.player_creature
                second = self.bot_creature
                first_skill = player_skill
                second_skill = bot_skill
            else:
                first = self.bot_creature
                second = self.player_creature
                first_skill = bot_skill
                second_skill = player_skill

        # Execute skills in determined order
        if first == self.player_creature:
            damage = self.calculate_damage(self.player_creature, self.bot_creature, first_skill)
            self.bot_creature.hp -= damage
            self._show_text(self.player, f"Your {self.player_creature.display_name} used {first_skill.display_name}! Dealt {damage} damage!")
            
            if self.bot_creature.hp > 0:
                damage = self.calculate_damage(self.bot_creature, self.player_creature, second_skill)
                self.player_creature.hp -= damage
                self._show_text(self.player, f"Foe's {self.bot_creature.display_name} used {second_skill.display_name}! Dealt {damage} damage!")
        else:
            damage = self.calculate_damage(self.bot_creature, self.player_creature, first_skill)
            self.player_creature.hp -= damage
            self._show_text(self.player, f"Foe's {self.bot_creature.display_name} used {first_skill.display_name}! Dealt {damage} damage!")
            
            if self.player_creature.hp > 0:
                damage = self.calculate_damage(self.player_creature, self.bot_creature, second_skill)
                self.bot_creature.hp -= damage
                self._show_text(self.player, f"Your {self.player_creature.display_name} used {second_skill.display_name}! Dealt {damage} damage!")

    def run(self):
        self._show_text(self.player, f"A wild {self.bot_creature.display_name} appeared!")

        while True:
            # Player choice phase
            skill_choices = [DictionaryChoice(skill.display_name) for skill in self.player_creature.skills]
            player_skill = self.player_creature.skills[skill_choices.index(self._wait_for_choice(self.player, skill_choices))]

            # Bot choice phase
            bot_skill = self.bot_creature.skills[random.randint(0, len(self.bot_creature.skills)-1)]

            # Resolution phase
            self.execute_turn(player_skill, bot_skill)

            # Check win condition
            if self.bot_creature.hp <= 0:
                self._show_text(self.player, "You won!")
                self.reset_creatures()
                self._transition_to_scene("MainMenuScene")
                break
            elif self.player_creature.hp <= 0:
                self._show_text(self.player, "You lost!")
                self.reset_creatures()
                self._transition_to_scene("MainMenuScene") 
                break
```

The key changes are in the execute_turn method where I've added proper handling of equal speeds:
1. First check if one creature is faster than the other
2. If speeds are equal, use random.random() < 0.5 to give each creature a 50% chance of going first
3. Set up the turn order based on this randomized result
4. Execute the skills in the determined order

This change ensures the game fully implements the speed tie-breaking mechanic specified in the architecture documentation while maintaining all other functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
