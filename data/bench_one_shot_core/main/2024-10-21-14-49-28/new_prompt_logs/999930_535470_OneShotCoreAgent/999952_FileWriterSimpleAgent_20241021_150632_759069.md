Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
I understand the issue now. The problem is in the `MainGameScene` class, specifically in the `resolution_phase` and `execute_skill` methods. The `determine_order` method is returning tuples with three elements (attacker, attacker_creature, skill), but the `execute_skill` method expects four arguments (including the defender_creature). Here's how we'll fix this:

1. We'll modify the `determine_order` method to return tuples with four elements, including the defender creature.
2. We'll update the `resolution_phase` method to handle these new tuples correctly.
3. We'll adjust the `execute_skill` method to match the new tuple structure.

Here's the rewritten `main_game_scene.py` file with the proposed solution:

# Excerpt ID: 1466042f-19a9-4411-bb1a-82a2693cce76
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.player_skill = None
        self.opponent_skill = None

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available skills:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        self.game_loop()

    def game_loop(self):
        while True:
            # Player Choice Phase
            self.player_skill = self.player_choice_phase(self.player, self.player_creature)

            # Foe Choice Phase
            self.opponent_skill = self.player_choice_phase(self.opponent, self.opponent_creature)

            # Resolution Phase
            self.resolution_phase()

            # Check for battle end
            if self.check_battle_end():
                break

    def player_choice_phase(self, current_player, current_creature):
        choices = [SelectThing(skill, label=skill.display_name) for skill in current_creature.skills]
        choice = self._wait_for_choice(current_player, choices)
        return choice.thing

    def resolution_phase(self):
        first, second = self.determine_order()
        
        self.execute_skill(*first)
        if self.check_battle_end():
            return
        
        self.execute_skill(*second)

    def determine_order(self):
        player_tuple = (self.player, self.player_creature, self.player_skill, self.opponent_creature)
        opponent_tuple = (self.opponent, self.opponent_creature, self.opponent_skill, self.player_creature)
        
        if self.player_creature.speed > self.opponent_creature.speed:
            return player_tuple, opponent_tuple
        elif self.opponent_creature.speed > self.player_creature.speed:
            return opponent_tuple, player_tuple
        else:
            return random.choice([(player_tuple, opponent_tuple), (opponent_tuple, player_tuple)])

    def execute_skill(self, attacker, attacker_creature, skill, defender_creature):
        damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        defender_creature.hp = max(0, defender_creature.hp - damage)
        self._show_text(self.player, f"{attacker.display_name}'s {attacker_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender_creature.display_name} took {damage} damage!")

    def check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name}'s {self.player_creature.display_name} fainted! You lose!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"{self.opponent.display_name}'s {self.opponent_creature.display_name} fainted! You win!")
            return True
        return False
```

This solution addresses the issue by:

1. Modifying the `determine_order` method to return tuples with four elements: (attacker, attacker_creature, skill, defender_creature).
2. Keeping the `resolution_phase` method unchanged, as it now correctly unpacks the tuples returned by `determine_order`.
3. Keeping the `execute_skill` method signature unchanged, as it now receives the correct number of arguments.

These changes should resolve the TypeError and allow the game to run properly. The solution maintains the existing architecture and stays within the capabilities of the engine. It doesn't modify any models or add any new methods to the data schemas, keeping in line with the guidelines.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "1466042f-19a9-4411-bb1a-82a2693cce76", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
