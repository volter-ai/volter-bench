Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issue raised during QA/testing, we need to address the TypeError in the `MainGameScene` class. The error occurs because we're trying to pass a `winner` argument to the `_transition_to_scene` method, which doesn't accept this parameter.

Here's how we'll fix this issue:

1. Instead of passing the `winner` as an argument to `_transition_to_scene`, we'll store it as an attribute of the `MainGameScene` class.
2. We'll modify the `BattleResultScene` to retrieve the winner information from the previous scene.
3. We'll update the `App` class to pass the previous scene to the new scene during transition.

This approach stays within the capabilities of the engine and doesn't modify any models or add methods to data schemas.

Let's rewrite the `main_game_scene.py` file with the proposed solution:

# Excerpt ID: 99caa56b-8034-48f3-93d8-0481c42c2283
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.player_skill = None
        self.opponent_skill = None
        self.battle_winner = None

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available skills:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        self.game_loop()

    def game_loop(self):
        while True:
            # Player Choice Phase
            self.player_skill = self.player_choice_phase(self.player, self.player_creature)

            # Foe Choice Phase
            self.opponent_skill = self.player_choice_phase(self.opponent, self.opponent_creature)

            # Resolution Phase
            self.resolution_phase()

            # Check for battle end
            battle_ended, winner = self.check_battle_end()
            if battle_ended:
                self.battle_winner = winner
                self._transition_to_scene("BattleResultScene")
                return

    def player_choice_phase(self, current_player, current_creature):
        choices = [SelectThing(skill, label=skill.display_name) for skill in current_creature.skills]
        choice = self._wait_for_choice(current_player, choices)
        return choice.thing

    def resolution_phase(self):
        first, second = self.determine_order()
        
        self.execute_skill(*first)
        if self.check_battle_end()[0]:
            return
        
        self.execute_skill(*second)

    def determine_order(self):
        player_tuple = (self.player, self.player_creature, self.player_skill, self.opponent_creature)
        opponent_tuple = (self.opponent, self.opponent_creature, self.opponent_skill, self.player_creature)
        
        if self.player_creature.speed > self.opponent_creature.speed:
            return player_tuple, opponent_tuple
        elif self.opponent_creature.speed > self.player_creature.speed:
            return opponent_tuple, player_tuple
        else:
            return random.choice([(player_tuple, opponent_tuple), (opponent_tuple, player_tuple)])

    def execute_skill(self, attacker, attacker_creature, skill, defender_creature):
        damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        defender_creature.hp = max(0, defender_creature.hp - damage)
        self._show_text(self.player, f"{attacker.display_name}'s {attacker_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender_creature.display_name} took {damage} damage!")

    def check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name}'s {self.player_creature.display_name} fainted!")
            return True, self.opponent
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"{self.opponent.display_name}'s {self.opponent_creature.display_name} fainted!")
            return True, self.player
        return False, None
```

Now, let's update the `battle_result_scene.py` file to retrieve the winner information from the previous scene:

# Excerpt ID: d803ebfc-8db4-458f-910e-86997738eb23
```python main_game/scenes/battle_result_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button

class BattleResultScene(AbstractGameScene):
    def __init__(self, app, player, previous_scene):
        super().__init__(app, player)
        self.winner = previous_scene.battle_winner if hasattr(previous_scene, 'battle_winner') else None

    def __str__(self):
        result = "You win!" if self.winner == self.player else "You lose!"
        return f"""===Battle Result===
{result}

> Return to Main Menu
> Quit Game
"""

    def run(self):
        self.game_loop()

    def game_loop(self):
        while True:
            main_menu_button = Button("Return to Main Menu")
            quit_button = Button("Quit Game")
            choices = [main_menu_button, quit_button]
            choice = self._wait_for_choice(self.player, choices)

            if choice == main_menu_button:
                self._transition_to_scene("MainMenuScene")
                return
            elif choice == quit_button:
                self._quit_whole_game()
                return
```

Finally, we need to update the `main.py` file to pass the previous scene during scene transitions:

# Excerpt ID: 4cee5eca-215f-4b4e-b9f6-ed5cd9bf27c1
```python main_game/main.py
import uuid
from mini_game_engine.engine.lib import AbstractApp, HumanListener, BotListener
from main_game.models import Player
from main_game.scenes.main_menu_scene import MainMenuScene
from main_game.scenes.main_game_scene import MainGameScene
from main_game.scenes.battle_result_scene import BattleResultScene

class App(AbstractApp):
    def __init__(self):
        super().__init__()
        self.register_scene("MainMenuScene", MainMenuScene, is_entry_point=True)
        self.register_scene("MainGameScene", MainGameScene)
        self.register_scene("BattleResultScene", BattleResultScene)
        self.current_scene = None

    def create_player(self, player_id: str):
        player = Player.from_prototype_id(prototype_id="default_player")
        player.uid = player_id
        player.set_listener(HumanListener())
        return player

    def create_bot(self, prototype_id: str):
        bot = Player.from_prototype_id(prototype_id=prototype_id)
        bot.uid = str(uuid.uuid4())
        bot.set_listener(BotListener())
        return bot

    def transition_to_scene(self, scene_id: str, **kwargs):
        scene_factory = self.scene_registry[scene_id]
        scene = scene_factory(app=self, previous_scene=self.current_scene, **kwargs)
        self.current_scene = scene
        self.__run_scene(scene)

if __name__ == '__main__':
    app = App()
    app.run(app.create_player("just_a_guy"))
```

These changes should resolve the TypeError and allow the game to run properly. The solution maintains the existing architecture and stays within the capabilities of the engine. It doesn't modify any models or add any new methods to the data schemas, keeping in line with the guidelines.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[
    {"action": "overwrite", "excerpt_id": "99caa56b-8034-48f3-93d8-0481c42c2283", "file_path": "main_game/scenes/main_game_scene.py"},
    {"action": "overwrite", "excerpt_id": "d803ebfc-8db4-458f-910e-86997738eb23", "file_path": "main_game/scenes/battle_result_scene.py"},
    {"action": "overwrite", "excerpt_id": "4cee5eca-215f-4b4e-b9f6-ed5cd9bf27c1", "file_path": "main_game/main.py"}
]
```
__________________
