Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issues raised during QA/testing, we need to address two main problems:

1. The `MainGameScene` is not exiting properly when the battle ends.
2. The game loop in `MainGameScene` is not transitioning to another scene or quitting the game when it should.

Here's how we'll fix these issues:

1. We'll modify the `MainGameScene` to transition to a new "BattleResultScene" when the battle ends.
2. We'll create a new "BattleResultScene" that displays the result of the battle and allows the player to return to the main menu or quit the game.
3. We'll update the `check_battle_end` method to return a boolean indicating whether the battle has ended, and who the winner is.

Let's implement these changes:

# Excerpt ID: 880d01ec-d6cd-4bdb-9844-140b6dcd64dc
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.player_skill = None
        self.opponent_skill = None

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available skills:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        self.game_loop()

    def game_loop(self):
        while True:
            # Player Choice Phase
            self.player_skill = self.player_choice_phase(self.player, self.player_creature)

            # Foe Choice Phase
            self.opponent_skill = self.player_choice_phase(self.opponent, self.opponent_creature)

            # Resolution Phase
            self.resolution_phase()

            # Check for battle end
            battle_ended, winner = self.check_battle_end()
            if battle_ended:
                self._transition_to_scene("BattleResultScene", winner=winner)
                return

    def player_choice_phase(self, current_player, current_creature):
        choices = [SelectThing(skill, label=skill.display_name) for skill in current_creature.skills]
        choice = self._wait_for_choice(current_player, choices)
        return choice.thing

    def resolution_phase(self):
        first, second = self.determine_order()
        
        self.execute_skill(*first)
        if self.check_battle_end()[0]:
            return
        
        self.execute_skill(*second)

    def determine_order(self):
        player_tuple = (self.player, self.player_creature, self.player_skill, self.opponent_creature)
        opponent_tuple = (self.opponent, self.opponent_creature, self.opponent_skill, self.player_creature)
        
        if self.player_creature.speed > self.opponent_creature.speed:
            return player_tuple, opponent_tuple
        elif self.opponent_creature.speed > self.player_creature.speed:
            return opponent_tuple, player_tuple
        else:
            return random.choice([(player_tuple, opponent_tuple), (opponent_tuple, player_tuple)])

    def execute_skill(self, attacker, attacker_creature, skill, defender_creature):
        damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        defender_creature.hp = max(0, defender_creature.hp - damage)
        self._show_text(self.player, f"{attacker.display_name}'s {attacker_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender_creature.display_name} took {damage} damage!")

    def check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name}'s {self.player_creature.display_name} fainted!")
            return True, self.opponent
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"{self.opponent.display_name}'s {self.opponent_creature.display_name} fainted!")
            return True, self.player
        return False, None
```

Now, let's create a new file for the `BattleResultScene`:

# Excerpt ID: 6472495c-546e-47f7-85d3-6384c610add9
```python main_game/scenes/battle_result_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button

class BattleResultScene(AbstractGameScene):
    def __init__(self, app, player, winner):
        super().__init__(app, player)
        self.winner = winner

    def __str__(self):
        result = "You win!" if self.winner == self.player else "You lose!"
        return f"""===Battle Result===
{result}

> Return to Main Menu
> Quit Game
"""

    def run(self):
        self.game_loop()

    def game_loop(self):
        while True:
            main_menu_button = Button("Return to Main Menu")
            quit_button = Button("Quit Game")
            choices = [main_menu_button, quit_button]
            choice = self._wait_for_choice(self.player, choices)

            if choice == main_menu_button:
                self._transition_to_scene("MainMenuScene")
                return
            elif choice == quit_button:
                self._quit_whole_game()
                return
```

Finally, we need to update the `main.py` file to register the new `BattleResultScene`:

# Excerpt ID: 09fd2a80-f882-4c24-b6c5-d2c8a3795466
```python main_game/main.py
import uuid
from mini_game_engine.engine.lib import AbstractApp, HumanListener, BotListener
from main_game.models import Player
from main_game.scenes.main_menu_scene import MainMenuScene
from main_game.scenes.main_game_scene import MainGameScene
from main_game.scenes.battle_result_scene import BattleResultScene

class App(AbstractApp):
    def __init__(self):
        super().__init__()
        self.register_scene("MainMenuScene", MainMenuScene, is_entry_point=True)
        self.register_scene("MainGameScene", MainGameScene)
        self.register_scene("BattleResultScene", BattleResultScene)

    def create_player(self, player_id: str):
        player = Player.from_prototype_id(prototype_id="default_player")
        player.uid = player_id
        player.set_listener(HumanListener())
        return player

    def create_bot(self, prototype_id: str):
        bot = Player.from_prototype_id(prototype_id=prototype_id)
        bot.uid = str(uuid.uuid4())
        bot.set_listener(BotListener())
        return bot

if __name__ == '__main__':
    app = App()
    app.run(app.create_player("just_a_guy"))
```

These changes should resolve the issues by:

1. Properly ending the `MainGameScene` when the battle is over by transitioning to the `BattleResultScene`.
2. Adding a new `BattleResultScene` that allows the player to return to the main menu or quit the game.
3. Ensuring that the game always transitions to another scene or quits when appropriate.

This solution maintains the existing architecture and stays within the capabilities of the engine. It doesn't modify any models or add any new methods to the data schemas, keeping in line with the guidelines.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[
    {
        "action": "overwrite",
        "excerpt_id": "880d01ec-d6cd-4bdb-9844-140b6dcd64dc",
        "file_path": "main_game/scenes/main_game_scene.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "6472495c-546e-47f7-85d3-6384c610add9",
        "file_path": "main_game/scenes/battle_result_scene.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "09fd2a80-f882-4c24-b6c5-d2c8a3795466",
        "file_path": "main_game/main.py"
    }
]
```
__________________
