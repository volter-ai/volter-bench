Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for bringing this issue to my attention. I'll address the problems and propose a solution that aligns with the architecture and engine capabilities.

1. Proposed solution:

To fix the issues raised during QA/testing, we need to make the following changes to the MainGameScene:

a) Implement a proper resolution phase that considers creature speed:
   - Create a list of actions (player and opponent) with their respective creatures and chosen skills.
   - Sort this list based on creature speed in descending order.
   - In case of a tie, use random selection to determine the order.

b) Update damage calculation to use floats:
   - Perform all damage calculations using float arithmetic.
   - Convert the final damage to an integer only at the end of the calculation.

c) Refactor the turn structure:
   - Implement separate methods for the choice phase and the resolution phase.
   - Update the main game loop to reflect this new structure.

2. Here's the rewritten MainGameScene with the proposed solution:

# Excerpt ID: 90d5000e-ead4-42ac-8ffd-a9d740a2a5fa
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.battle_ended = False

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Your skills:
{self._format_skills(self.player_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name} ({skill.skill_type} type, {skill.base_damage} damage)" for skill in skills])

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appears!")
        while not self.battle_ended:
            player_action = self._player_choice_phase()
            opponent_action = self._opponent_choice_phase()
            self._resolution_phase([player_action, opponent_action])
        
        self._end_battle()

    def _player_choice_phase(self):
        self._show_text(self.player, "Your turn!")
        choices = [SelectThing(skill, label=f"{skill.display_name} ({skill.skill_type} type)") for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return (self.player_creature, choice.thing)

    def _opponent_choice_phase(self):
        self._show_text(self.player, f"{self.opponent.display_name}'s turn!")
        skill = random.choice(self.opponent_creature.skills)
        return (self.opponent_creature, skill)

    def _resolution_phase(self, actions):
        # Sort actions based on creature speed, with random tiebreaker
        sorted_actions = sorted(actions, key=lambda x: (x[0].speed, random.random()), reverse=True)
        
        for attacker, skill in sorted_actions:
            if attacker == self.player_creature:
                defender = self.opponent_creature
            else:
                defender = self.player_creature
            
            self._execute_skill(attacker, defender, skill)
            if self._check_battle_end():
                break

    def _execute_skill(self, attacker: Creature, defender: Creature, skill: Skill):
        self._show_text(self.player, f"{attacker.display_name} uses {skill.display_name}!")
        raw_damage = float(attacker.attack) + float(skill.base_damage) - float(defender.defense)
        type_factor = self._get_type_factor(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_factor)
        defender.hp = max(0, defender.hp - final_damage)
        self._show_text(self.player, f"{defender.display_name} takes {final_damage} damage!")

    def _get_type_factor(self, skill_type: str, defender_type: str) -> float:
        if skill_type == "normal":
            return 1.0
        elif skill_type == "fire" and defender_type == "leaf":
            return 2.0
        elif skill_type == "water" and defender_type == "fire":
            return 2.0
        elif skill_type == "leaf" and defender_type == "water":
            return 2.0
        elif skill_type == "fire" and defender_type == "water":
            return 0.5
        elif skill_type == "water" and defender_type == "leaf":
            return 0.5
        elif skill_type == "leaf" and defender_type == "fire":
            return 0.5
        else:
            return 1.0

    def _check_battle_end(self) -> bool:
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player_creature.display_name} fainted! You lose!")
            self.battle_ended = True
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"{self.opponent_creature.display_name} fainted! You win!")
            self.battle_ended = True
            return True
        return False

    def _end_battle(self):
        self._show_text(self.player, "The battle has ended!")
        self._show_text(self.player, "Returning to the main menu...")
        self._transition_to_scene("MainMenuScene")
```

This solution addresses the issues by:

1. Implementing a proper resolution phase that considers creature speed and uses random selection for tiebreakers.
2. Using float arithmetic for damage calculations and converting to integer only at the final step.
3. Refactoring the turn structure to separate choice phases and the resolution phase.

These changes ensure that the battle mechanics align with the specified architecture while staying within the capabilities of the engine.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "90d5000e-ead4-42ac-8ffd-a9d740a2a5fa", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
