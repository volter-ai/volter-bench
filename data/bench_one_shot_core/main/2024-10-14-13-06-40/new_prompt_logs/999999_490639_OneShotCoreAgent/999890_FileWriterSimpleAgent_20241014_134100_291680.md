Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To address the issue of not resetting the state of the player's creatures when transitioning out of the MainGameScene, we need to make the following changes:

1. We'll add a method to reset the creature's state in the `MainGameScene` class.
2. We'll call this method before transitioning back to the `MainMenuScene`.

Since we can't add methods to the `Creature` model (as models should be pure data schemas), we'll implement the reset logic within the `MainGameScene` class.

Here's how we'll fix the `main_game_scene.py` file:

# Excerpt ID: 706249a9-1fe7-4cbb-83d6-c0d01197a3db
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.battle_ended = False
        self.initial_player_creature_state = self.store_creature_state(self.player_creature)
        self.initial_opponent_creature_state = self.store_creature_state(self.opponent_creature)

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}: {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
{self.opponent.display_name}: {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Your turn! Choose a skill:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        self._show_text(self.player, f"Battle start! {self.player.display_name} vs {self.opponent.display_name}")
        self.battle_loop()

    def battle_loop(self):
        while not self.battle_ended:
            player_skill = self.player_turn()
            opponent_skill = self.opponent_turn()
            self.resolve_turn(player_skill, opponent_skill)
            self.check_battle_end()

    def player_turn(self):
        choices = [SelectThing(skill) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def opponent_turn(self):
        choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def resolve_turn(self, player_skill, opponent_skill):
        first, second = self.determine_turn_order(player_skill, opponent_skill)
        self.execute_skill(*first)
        if not self.battle_ended:
            self.execute_skill(*second)

    def determine_turn_order(self, player_skill, opponent_skill):
        if self.player_creature.speed > self.opponent_creature.speed:
            return (self.player, player_skill, self.opponent_creature), (self.opponent, opponent_skill, self.player_creature)
        elif self.player_creature.speed < self.opponent_creature.speed:
            return (self.opponent, opponent_skill, self.player_creature), (self.player, player_skill, self.opponent_creature)
        else:
            if random.random() < 0.5:
                return (self.player, player_skill, self.opponent_creature), (self.opponent, opponent_skill, self.player_creature)
            else:
                return (self.opponent, opponent_skill, self.player_creature), (self.player, player_skill, self.opponent_creature)

    def execute_skill(self, attacker, skill, defender):
        if skill.is_physical:
            raw_damage = attacker.creatures[0].attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.creatures[0].sp_attack / defender.sp_defense) * skill.base_damage
        
        weakness_factor = self.calculate_weakness_factor(skill.skill_type, defender.creature_type)
        final_damage = int(weakness_factor * raw_damage)
        
        defender.hp = max(0, defender.hp - final_damage)
        self._show_text(self.player, f"{attacker.display_name}'s {attacker.creatures[0].display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender.display_name}'s {defender.display_name} took {final_damage} damage!")

    def calculate_weakness_factor(self, skill_type, defender_type):
        effectiveness = {
            "fire": {"leaf": 2, "water": 0.5},
            "water": {"fire": 2, "leaf": 0.5},
            "leaf": {"water": 2, "fire": 0.5}
        }
        return effectiveness.get(skill_type, {}).get(defender_type, 1)

    def check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name} lost the battle!")
            self.battle_ended = True
            self.reset_creatures_state()
            self._transition_to_scene("MainMenuScene")
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name} won the battle!")
            self.battle_ended = True
            self.reset_creatures_state()
            self._transition_to_scene("MainMenuScene")

    def store_creature_state(self, creature):
        return {
            "hp": creature.hp,
            "max_hp": creature.max_hp,
            "attack": creature.attack,
            "defense": creature.defense,
            "sp_attack": creature.sp_attack,
            "sp_defense": creature.sp_defense,
            "speed": creature.speed
        }

    def reset_creatures_state(self):
        self.reset_creature_state(self.player_creature, self.initial_player_creature_state)
        self.reset_creature_state(self.opponent_creature, self.initial_opponent_creature_state)

    def reset_creature_state(self, creature, initial_state):
        for attr, value in initial_state.items():
            setattr(creature, attr, value)

```

This solution addresses the issue by implementing the following changes:

1. We've added a `store_creature_state` method to capture the initial state of creatures at the beginning of the battle.
2. We've added a `reset_creatures_state` method that resets both the player's and opponent's creatures to their initial states.
3. We call `reset_creatures_state` before transitioning back to the `MainMenuScene` in the `check_battle_end` method.

These changes ensure that the state of the player's creatures (and the opponent's creatures, for completeness) is reset when transitioning out of the `MainGameScene`, as required by the architecture documentation. This implementation stays within the capabilities of the engine and maintains the separation of concerns between models and game logic.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "706249a9-1fe7-4cbb-83d6-c0d01197a3db", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
