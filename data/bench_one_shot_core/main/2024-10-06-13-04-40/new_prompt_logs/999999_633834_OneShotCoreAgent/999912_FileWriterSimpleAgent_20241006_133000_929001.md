Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: To fix the issue, we need to modify the MainGameScene to properly exit the scene when the battle ends. The main problem is that the scene is not transitioning to another scene or quitting the game when the battle is over. Here's how we'll fix it:

1. In the MainGameScene, we'll modify the run method to continue the game loop until the battle ends.
2. After the battle ends, we'll add logic to either transition back to the MainMenuScene or quit the whole game.
3. We'll update the _check_battle_end method to return a boolean indicating whether the battle has ended.

Here's the rewritten MainGameScene with the proposed solution:

# Excerpt ID: 5aa38ec0-f9e2-41c1-a684-f66554b548b4
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available skills:
{self._format_skills(self.player_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name}" for skill in skills])

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appeared!")
        
        battle_ended = False
        while not battle_ended:
            # Player turn
            player_skill = self._player_turn()
            
            # Opponent turn
            opponent_skill = self._opponent_turn()
            
            # Resolve turn
            self._resolve_turn(player_skill, opponent_skill)
            
            # Check for battle end
            battle_ended = self._check_battle_end()

        # Battle has ended, ask player if they want to play again or quit
        play_again_button = Button("Play Again")
        quit_button = Button("Quit")
        choices = [play_again_button, quit_button]
        choice = self._wait_for_choice(self.player, choices)

        if play_again_button == choice:
            self._transition_to_scene("MainMenuScene")
        elif quit_button == choice:
            self._quit_whole_game()

    def _player_turn(self):
        choices = [Button(skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return next(skill for skill in self.player_creature.skills if skill.display_name == choice.display_name)

    def _opponent_turn(self):
        return random.choice(self.opponent_creature.skills)

    def _resolve_turn(self, player_skill, opponent_skill):
        if self.player_creature.speed >= self.opponent_creature.speed:
            self._execute_skill(self.player_creature, player_skill, self.opponent_creature)
            if self.opponent_creature.hp > 0:
                self._execute_skill(self.opponent_creature, opponent_skill, self.player_creature)
        else:
            self._execute_skill(self.opponent_creature, opponent_skill, self.player_creature)
            if self.player_creature.hp > 0:
                self._execute_skill(self.player_creature, player_skill, self.opponent_creature)

    def _execute_skill(self, attacker, skill, defender):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        weakness_factor = self._calculate_weakness_factor(skill.skill_type, defender.creature_type)
        final_damage = int(weakness_factor * raw_damage)
        defender.hp = max(0, defender.hp - final_damage)
        
        self._show_text(self.player, f"{attacker.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender.display_name} took {final_damage} damage!")

    def _calculate_weakness_factor(self, skill_type, defender_type):
        if skill_type == defender_type:
            return 1
        elif (skill_type == "fire" and defender_type == "leaf") or \
             (skill_type == "water" and defender_type == "fire") or \
             (skill_type == "leaf" and defender_type == "water"):
            return 2
        elif (skill_type == "fire" and defender_type == "water") or \
             (skill_type == "water" and defender_type == "leaf") or \
             (skill_type == "leaf" and defender_type == "fire"):
            return 0.5
        else:
            return 1

    def _check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, "You lost the battle!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, "You won the battle!")
            return True
        return False
```

This solution addresses the issue by ensuring that the MainGameScene properly exits by either transitioning back to the MainMenuScene or quitting the whole game. The main changes are:

1. The `run` method now uses a `while` loop that continues until the battle ends.
2. After the battle ends, we present the player with options to play again or quit.
3. Based on the player's choice, we either transition back to the MainMenuScene or quit the whole game.
4. The `_check_battle_end` method now returns a boolean indicating whether the battle has ended.

These changes should resolve the FixableException and ensure that the scene exits properly, following the engine's architecture and guidelines.
__________________
Role: assistant
Content: ```json
{
  "actions": [
    {
      "action": "overwrite",
      "excerpt_id": "5aa38ec0-f9e2-41c1-a684-f66554b548b4",
      "file_path": "main_game/scenes/main_game_scene.py"
    }
  ]
}
```
__________________
