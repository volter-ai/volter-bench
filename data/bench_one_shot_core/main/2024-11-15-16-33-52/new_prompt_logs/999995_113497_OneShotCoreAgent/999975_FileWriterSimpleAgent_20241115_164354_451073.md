Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The error occurs when trying to swap creatures but there are no available choices. This happens in MainGameScene when:
- The player chooses "Swap" but all other creatures are fainted
- We try to handle a fainted creature but there are no available creatures to swap to

The fix should:
- Check if there are available creatures before offering the "Swap" option
- Handle the case where no swaps are available by only showing "Attack" option
- Keep the models as pure data schemas
- Stay within engine capabilities by using the existing choice system

2. Here's the fixed MainGameScene:

# Excerpt ID: c1988322-8283-4b63-9873-3bcf16644ed7
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        self._reset_creatures()

    def _reset_creatures(self):
        # Reset all creatures to full HP
        for p in [self.player, self.bot]:
            for c in p.creatures:
                c.hp = c.max_hp
            p.active_creature = p.creatures[0]

    def __str__(self):
        p1 = self.player
        p2 = self.bot
        return f"""=== Battle ===
{p1.display_name}'s {p1.active_creature.display_name}: {p1.active_creature.hp}/{p1.active_creature.max_hp} HP
{p2.display_name}'s {p2.active_creature.display_name}: {p2.active_creature.hp}/{p2.active_creature.max_hp} HP

> Attack
{"> Swap" if self._get_available_creatures(p1) else ""}
"""

    def _calculate_damage(self, attacker: Creature, defender: Creature, skill):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        # Type effectiveness
        effectiveness = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf": effectiveness = 2.0
            elif defender.creature_type == "water": effectiveness = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire": effectiveness = 2.0
            elif defender.creature_type == "leaf": effectiveness = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water": effectiveness = 2.0
            elif defender.creature_type == "fire": effectiveness = 0.5

        return int(raw_damage * effectiveness)

    def _get_available_creatures(self, player: Player):
        return [c for c in player.creatures if c.hp > 0 and c != player.active_creature]

    def _handle_fainted(self, player: Player):
        if player.active_creature.hp <= 0:
            available = self._get_available_creatures(player)
            if not available:
                return False
            
            choices = [SelectThing(c) for c in available]
            choice = self._wait_for_choice(player, choices)
            player.active_creature = choice.thing
            
        return True

    def run(self):
        while True:
            # Player turn
            choices = [Button("Attack")]
            available_creatures = self._get_available_creatures(self.player)
            if available_creatures:
                choices.append(Button("Swap"))
            
            player_choice = self._wait_for_choice(self.player, choices)

            player_action = None
            if player_choice.display_name == "Attack":
                skill_choices = [SelectThing(s) for s in self.player.active_creature.skills]
                skill_choice = self._wait_for_choice(self.player, skill_choices)
                player_action = ("attack", skill_choice.thing)
            else:
                creature_choices = [SelectThing(c) for c in available_creatures]
                creature_choice = self._wait_for_choice(self.player, creature_choices)
                player_action = ("swap", creature_choice.thing)

            # Bot turn
            bot_action = None
            available_bot_creatures = self._get_available_creatures(self.bot)
            if not available_bot_creatures or random.random() < 0.8:  # 80% chance to attack or no choice
                bot_action = ("attack", random.choice(self.bot.active_creature.skills))
            else:
                bot_action = ("swap", random.choice(available_bot_creatures))

            # Resolution phase
            # Handle swaps first
            if player_action[0] == "swap":
                self.player.active_creature = player_action[1]
            if bot_action[0] == "swap":
                self.bot.active_creature = bot_action[1]

            # Handle attacks
            if player_action[0] == "attack" and bot_action[0] == "attack":
                # Determine order
                first = self.player if self.player.active_creature.speed > self.bot.active_creature.speed else self.bot
                second = self.bot if first == self.player else self.player
                first_action = player_action if first == self.player else bot_action
                second_action = bot_action if first == self.player else player_action

                # First attack
                damage = self._calculate_damage(first.active_creature, second.active_creature, first_action[1])
                second.active_creature.hp -= damage
                self._show_text(self.player, f"{first.active_creature.display_name} used {first_action[1].display_name}!")
                
                if second.active_creature.hp > 0:
                    # Second attack
                    damage = self._calculate_damage(second.active_creature, first.active_creature, second_action[1])
                    first.active_creature.hp -= damage
                    self._show_text(self.player, f"{second.active_creature.display_name} used {second_action[1].display_name}!")

            # Check for fainted creatures
            if not self._handle_fainted(self.player):
                self._show_text(self.player, "You lost!")
                break
            if not self._handle_fainted(self.bot):
                self._show_text(self.player, "You won!")
                break

        self._transition_to_scene("MainMenuScene")
```

The key changes are:
1. Only show "Swap" button if there are available creatures to swap to
2. Check available creatures before offering swap choices
3. Bot logic updated to only try swapping if creatures are available
4. Updated __str__ to only show swap option when available

This maintains the pure data model approach while fixing the empty choices issue by properly checking creature availability before offering swap options.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
