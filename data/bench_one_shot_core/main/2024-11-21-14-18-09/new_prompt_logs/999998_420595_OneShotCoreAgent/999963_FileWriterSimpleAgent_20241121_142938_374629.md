Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis and Solution Plan:
The error occurs in MainGameScene's resolve_turn method when trying to sort actions. The issue is that bot_action can be None (when get_player_action returns None), but the sort lambda tries to access the first element of None with `x[1][0]`.

The fix should:
- Handle None actions properly in resolve_turn
- Maintain separation of concerns (keep models as pure data schemas)
- Stay within engine capabilities
- Not change the core battle mechanics

The solution is to:
1. Skip None actions in resolve_turn
2. Filter out None values before sorting
3. Keep the same turn structure but handle empty/None actions gracefully

Here's the fixed MainGameScene:

# Excerpt ID: af6dcb16-8eab-45ac-a879-c830ac6303f0
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, SelectThing, Button
from main_game.models import Creature
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        
        # Initialize creatures
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]

    def __str__(self):
        player_creature = self.player.active_creature
        bot_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {player_creature.display_name}: {player_creature.hp}/{player_creature.max_hp} HP
Foe's {bot_creature.display_name}: {bot_creature.hp}/{bot_creature.max_hp} HP

> Attack
> Swap"""

    def run(self):
        while True:
            # Player turn
            player_action = self.get_player_action(self.player)
            
            # Bot turn
            bot_action = self.get_player_action(self.bot)
            
            # Resolve actions
            if player_action or bot_action:  # Only resolve if at least one action exists
                self.resolve_turn(player_action, bot_action)
            
            # Check for battle end
            if self.check_battle_end():
                break

    def get_player_action(self, player):
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        back_button = Button("Back")
        
        choice = self._wait_for_choice(player, [attack_button, swap_button])
        
        if choice == attack_button:
            # Show skills
            skill_choices = [SelectThing(skill) for skill in player.active_creature.skills]
            skill_choices.append(back_button)
            skill_choice = self._wait_for_choice(player, skill_choices)
            
            if skill_choice == back_button:
                return None
            return ("attack", skill_choice.thing)
            
        elif choice == swap_button:
            # Show available creatures
            available_creatures = [c for c in player.creatures if c != player.active_creature and c.hp > 0]
            if not available_creatures:
                self._show_text(player, "No other creatures available!")
                return None
                
            creature_choices = [SelectThing(c) for c in available_creatures]
            creature_choices.append(back_button)
            creature_choice = self._wait_for_choice(player, creature_choices)
            
            if creature_choice == back_button:
                return None
            return ("swap", creature_choice.thing)

    def resolve_turn(self, player_action, bot_action):
        # Create list of valid actions
        actions = []
        if player_action:
            actions.append((self.player, player_action))
        if bot_action:
            actions.append((self.bot, bot_action))
            
        if not actions:  # If no valid actions, return early
            return
            
        # Sort valid actions by speed (swaps first, then by creature speed)
        actions.sort(
            key=lambda x: (
                float('inf') if x[1][0] == "swap" 
                else x[0].active_creature.speed
            ),
            reverse=True
        )
        
        # Execute actions
        for player, action in actions:
            if action[0] == "swap":
                player.active_creature = action[1]
                self._show_text(player, f"{player.display_name} swapped to {action[1].display_name}!")
            else:
                self.execute_attack(player, action[1])

    def execute_attack(self, attacker, skill):
        defender = self.bot if attacker == self.player else self.player
        
        # Calculate damage
        if skill.is_physical:
            raw_damage = attacker.active_creature.attack + skill.base_damage - defender.active_creature.defense
        else:
            raw_damage = (attacker.active_creature.sp_attack / defender.active_creature.sp_defense) * skill.base_damage
            
        # Apply type effectiveness
        multiplier = self.get_type_multiplier(skill.skill_type, defender.active_creature.creature_type)
        final_damage = int(raw_damage * multiplier)
        
        defender.active_creature.hp = max(0, defender.active_creature.hp - final_damage)
        self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(defender, f"{defender.active_creature.display_name} took {final_damage} damage!")

    def get_type_multiplier(self, skill_type, defender_type):
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        return effectiveness.get(skill_type, {}).get(defender_type, 1.0)

    def check_battle_end(self):
        def has_available_creatures(player):
            return any(c.hp > 0 for c in player.creatures)
            
        if not has_available_creatures(self.player):
            self._show_text(self.player, "You lost the battle!")
            return True
        elif not has_available_creatures(self.bot):
            self._show_text(self.player, "You won the battle!")
            return True
            
        return False
```

The key changes are:
1. Added check for None actions before resolving turn
2. Restructured resolve_turn to handle None actions gracefully
3. Simplified the sorting logic to avoid None access
4. Maintained all game mechanics while adding proper null checks
5. Kept the scene's interface and behavior consistent

This should fix the NoneType errors while maintaining the game's architecture and functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
