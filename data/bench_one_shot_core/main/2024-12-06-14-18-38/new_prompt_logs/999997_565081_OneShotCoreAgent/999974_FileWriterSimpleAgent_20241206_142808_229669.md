Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. To fix the missing "Back" option in the Player Choice Phase:

I need to modify the MainGameScene to add "Back" options in both the skill selection and creature swap menus. This requires:
- Adding a Button("Back") to both sub-menus
- Modifying handle_turn() to support recursive menu navigation
- When "Back" is selected, return to the main Attack/Swap menu

The fix only requires changes to main_game_scene.py since this is purely a scene logic issue. No model changes are needed since this is just UI flow control.

2. Here's the complete fixed file:

# Excerpt ID: bff7eda3-a277-4001-8bb7-d833ba62762f
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        self.initialize_battle()

    def initialize_battle(self):
        # Reset creatures
        for creature in self.player.creatures:
            creature.hp = creature.max_hp
        for creature in self.bot.creatures:
            creature.hp = creature.max_hp
            
        # Set initial active creatures
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]

    def __str__(self):
        return f"""=== Battle ===
Your {self.player.active_creature.display_name}: {self.player.active_creature.hp}/{self.player.active_creature.max_hp} HP
Foe's {self.bot.active_creature.display_name}: {self.bot.active_creature.hp}/{self.bot.active_creature.max_hp} HP

> Attack
> Swap
"""

    def calculate_damage(self, attacker: Creature, defender: Creature, skill):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        # Type effectiveness
        effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        
        return int(raw_damage * effectiveness)

    def get_type_effectiveness(self, skill_type: str, defender_type: str) -> float:
        if skill_type == "normal" or defender_type == "normal":
            return 1.0
            
        effectiveness_chart = {
            "fire": {"water": 0.5, "leaf": 2.0},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness_chart.get(skill_type, {}).get(defender_type, 1.0)

    def get_available_creatures(self, player: Player) -> list[Creature]:
        return [c for c in player.creatures if c.hp > 0 and c != player.active_creature]

    def handle_turn(self, player: Player, opponent: Player):
        while True:  # Allow returning to main menu with Back option
            # Main menu
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choice = self._wait_for_choice(player, [attack_button, swap_button])

            if choice == attack_button:
                # Show skills with Back option
                skill_choices = [SelectThing(skill) for skill in player.active_creature.skills]
                back_button = Button("Back")
                skill_choice = self._wait_for_choice(player, skill_choices + [back_button])
                
                if skill_choice == back_button:
                    continue  # Return to main menu
                return ("attack", skill_choice.thing)
            else:
                # Show available creatures with Back option
                available = self.get_available_creatures(player)
                if not available:
                    return None
                    
                creature_choices = [SelectThing(creature) for creature in available]
                back_button = Button("Back")
                creature_choice = self._wait_for_choice(player, creature_choices + [back_button])
                
                if creature_choice == back_button:
                    continue  # Return to main menu
                return ("swap", creature_choice.thing)

    def run(self):
        while True:
            # Player turn
            player_action = self.handle_turn(self.player, self.bot)
            if not player_action:
                self._show_text(self.player, "You have no more creatures!")
                break

            # Bot turn
            bot_action = self.handle_turn(self.bot, self.player)
            if not bot_action:
                self._show_text(self.player, "Opponent has no more creatures!")
                break

            # Resolution phase
            self.resolve_actions(self.player, self.bot, player_action, bot_action)

            # Check for battle end
            if all(c.hp <= 0 for c in self.player.creatures):
                self._show_text(self.player, "You lost!")
                break
            elif all(c.hp <= 0 for c in self.bot.creatures):
                self._show_text(self.player, "You won!")
                break

        self._transition_to_scene("MainMenuScene")

    def resolve_actions(self, player: Player, bot: Player, player_action, bot_action):
        # Handle swaps first
        if player_action[0] == "swap":
            player.active_creature = player_action[1]
        if bot_action[0] == "swap":
            bot.active_creature = bot_action[1]

        # Then handle attacks
        if player_action[0] == "attack" and bot_action[0] == "attack":
            # Determine order
            if player.active_creature.speed > bot.active_creature.speed:
                first, second = (player, player_action[1]), (bot, bot_action[1])
            elif player.active_creature.speed < bot.active_creature.speed:
                first, second = (bot, bot_action[1]), (player, player_action[1])
            else:
                if random.random() < 0.5:
                    first, second = (player, player_action[1]), (bot, bot_action[1])
                else:
                    first, second = (bot, bot_action[1]), (player, player_action[1])

            # Execute attacks
            for attacker, skill in [first, second]:
                if attacker == player:
                    defender = bot
                else:
                    defender = player
                    
                damage = self.calculate_damage(attacker.active_creature, defender.active_creature, skill)
                defender.active_creature.hp = max(0, defender.active_creature.hp - damage)

                # Force swap if creature fainted
                if defender.active_creature.hp <= 0:
                    available = self.get_available_creatures(defender)
                    if available:
                        if defender == player:
                            creature_choices = [SelectThing(creature) for creature in available]
                            new_creature = self._wait_for_choice(defender, creature_choices).thing
                            defender.active_creature = new_creature
                        else:
                            defender.active_creature = available[0]
```

The key changes are:
1. Added a while loop in handle_turn() to allow returning to main menu
2. Added Back button to both skill selection and creature swap menus
3. When Back is selected, the loop continues to show the main menu again
4. Only returns from handle_turn() when a valid action is selected

This implements the "Back" functionality exactly as specified in the architecture documentation while maintaining all other functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
