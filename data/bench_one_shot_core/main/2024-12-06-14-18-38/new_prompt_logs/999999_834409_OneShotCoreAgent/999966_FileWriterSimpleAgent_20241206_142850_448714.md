Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
The issue is that the MainGameScene is not properly transitioning or quitting when the game ends. Looking at the error messages:

1. "Scene terminated without calling quit_whole_game or transition_to_scene"
2. "scene was not exited in an expected manner"

The problem is in MainGameScene.run() where we're using return statements instead of proper scene transitions. When a player wins or loses, we need to transition back to the MainMenuScene using _transition_to_scene() rather than returning.

Here's the fixed MainGameScene:

# Excerpt ID: e19360fe-f8f8-4182-8411-6d3e20eecc82
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        self.initialize_battle()

    def initialize_battle(self):
        # Reset creatures
        for creature in self.player.creatures:
            creature.hp = creature.max_hp
        for creature in self.bot.creatures:
            creature.hp = creature.max_hp
            
        # Set initial active creatures
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]

    def __str__(self):
        return f"""=== Battle ===
Your {self.player.active_creature.display_name}: {self.player.active_creature.hp}/{self.player.active_creature.max_hp} HP
Foe's {self.bot.active_creature.display_name}: {self.bot.active_creature.hp}/{self.bot.active_creature.max_hp} HP

> Attack
> Swap
"""

    def calculate_damage(self, attacker: Creature, defender: Creature, skill):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        # Type effectiveness
        effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        
        return int(raw_damage * effectiveness)

    def get_type_effectiveness(self, skill_type: str, defender_type: str) -> float:
        if skill_type == "normal" or defender_type == "normal":
            return 1.0
            
        effectiveness_chart = {
            "fire": {"water": 0.5, "leaf": 2.0},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness_chart.get(skill_type, {}).get(defender_type, 1.0)

    def get_available_creatures(self, player: Player) -> list[Creature]:
        return [c for c in player.creatures if c.hp > 0 and c != player.active_creature]

    def handle_turn(self, player: Player, opponent: Player):
        # Get player action
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        choice = self._wait_for_choice(player, [attack_button, swap_button])

        if choice == attack_button:
            # Show skills
            skill_choices = [SelectThing(skill) for skill in player.active_creature.skills]
            skill = self._wait_for_choice(player, skill_choices).thing
            return ("attack", skill)
        else:
            # Show available creatures
            available = self.get_available_creatures(player)
            if not available:
                return None
            creature_choices = [SelectThing(creature) for creature in available]
            new_creature = self._wait_for_choice(player, creature_choices).thing
            return ("swap", new_creature)

    def run(self):
        while True:
            # Player turn
            player_action = self.handle_turn(self.player, self.bot)
            if not player_action:
                self._show_text(self.player, "You have no more creatures!")
                self._show_text(self.player, "You lose!")
                self._transition_to_scene("MainMenuScene")
                return

            # Bot turn
            bot_action = self.handle_turn(self.bot, self.player)
            if not bot_action:
                self._show_text(self.player, "Opponent has no more creatures!")
                self._show_text(self.player, "You win!")
                self._transition_to_scene("MainMenuScene")
                return

            # Resolve actions
            actions = [(self.player, player_action), (self.bot, bot_action)]
            
            # Handle swaps first
            for player, action in actions:
                if action[0] == "swap":
                    player.active_creature = action[1]
                    self._show_text(self.player, f"{player.display_name} swapped to {action[1].display_name}!")

            # Then handle attacks
            random.shuffle(actions)  # Randomize order for same speed
            actions.sort(key=lambda x: x[0].active_creature.speed, reverse=True)

            for player, action in actions:
                if action[0] == "attack":
                    opponent = self.bot if player == self.player else self.player
                    damage = self.calculate_damage(player.active_creature, opponent.active_creature, action[1])
                    opponent.active_creature.hp -= damage
                    self._show_text(self.player, 
                        f"{player.display_name}'s {player.active_creature.display_name} used {action[1].display_name}! "
                        f"Dealt {damage} damage!")

                    if opponent.active_creature.hp <= 0:
                        opponent.active_creature.hp = 0
                        self._show_text(self.player, 
                            f"{opponent.display_name}'s {opponent.active_creature.display_name} was knocked out!")
                        
                        available = self.get_available_creatures(opponent)
                        if not available:
                            self._show_text(self.player, 
                                "You win!" if opponent == self.bot else "You lose!")
                            self._transition_to_scene("MainMenuScene")
                            return
                        
                        if opponent == self.player:
                            creature_choices = [SelectThing(creature) for creature in available]
                            new_creature = self._wait_for_choice(self.player, creature_choices).thing
                        else:
                            new_creature = random.choice(available)
                        
                        opponent.active_creature = new_creature
                        self._show_text(self.player, 
                            f"{opponent.display_name} sent out {new_creature.display_name}!")
```

The key changes are:

1. When a player has no more creatures, we now properly transition to MainMenuScene instead of just returning
2. When a player wins/loses, we now properly transition to MainMenuScene instead of just returning

This ensures the scene always exits through proper scene transitions rather than direct returns, following the engine's architecture requirements. The rest of the game logic remains unchanged.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
