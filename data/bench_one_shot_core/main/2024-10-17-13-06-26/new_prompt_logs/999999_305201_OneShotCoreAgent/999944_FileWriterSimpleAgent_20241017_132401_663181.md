Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for bringing this issue to my attention. I'll address the missing random resolution of ties in skill execution order.

1. To fix this issue, we need to modify the `resolution_phase` method in the `MainGameScene` class. We'll add a random tie-breaker when the speed of both creatures is equal. Here's how we'll do it:

   - In the `resolution_phase` method, we'll first compare the speeds of the player's creature and the opponent's creature.
   - If the speeds are equal, we'll use Python's `random.choice` to randomly select which creature goes first.
   - We'll then execute the skills in the order determined by either the speed comparison or the random tie-breaker.

This solution stays within the capabilities of the engine and doesn't require any changes to the models or the overall architecture.

2. Here's the rewritten `main_game_scene.py` file with the proposed solution:

# Excerpt ID: d710e479-7511-4b8e-bc87-39f76dbdc55c
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.player_skill = None
        self.opponent_skill = None

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Your turn! Choose a skill:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent.display_name} appeared!")
        self.game_loop()

    def game_loop(self):
        while True:
            self.player_choice_phase()
            self.foe_choice_phase()
            self.resolution_phase()

            if self.check_battle_end():
                break

    def player_choice_phase(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        self.player_skill = choice.thing

    def foe_choice_phase(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        self.opponent_skill = choice.thing

    def resolution_phase(self):
        if self.player_creature.speed > self.opponent_creature.speed:
            self.execute_skill(self.player, self.player_creature, self.player_skill, self.opponent_creature)
            if not self.check_battle_end():
                self.execute_skill(self.opponent, self.opponent_creature, self.opponent_skill, self.player_creature)
        elif self.player_creature.speed < self.opponent_creature.speed:
            self.execute_skill(self.opponent, self.opponent_creature, self.opponent_skill, self.player_creature)
            if not self.check_battle_end():
                self.execute_skill(self.player, self.player_creature, self.player_skill, self.opponent_creature)
        else:
            # Random tie-breaker when speeds are equal
            first_attacker, second_attacker = random.sample([
                (self.player, self.player_creature, self.player_skill),
                (self.opponent, self.opponent_creature, self.opponent_skill)
            ], 2)

            self.execute_skill(first_attacker[0], first_attacker[1], first_attacker[2], 
                               second_attacker[1])
            if not self.check_battle_end():
                self.execute_skill(second_attacker[0], second_attacker[1], second_attacker[2], 
                                   first_attacker[1])

    def execute_skill(self, attacker: Player, attacker_creature: Creature, skill: Skill, defender_creature: Creature):
        damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        damage = max(1, damage)  # Ensure at least 1 damage is dealt
        defender_creature.hp -= damage
        self._show_text(self.player, f"{attacker.display_name}'s {attacker_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender_creature.display_name} took {damage} damage!")

    def check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name}'s {self.player_creature.display_name} fainted! You lose!")
            self._transition_to_scene("MainMenuScene")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"{self.opponent.display_name}'s {self.opponent_creature.display_name} fainted! You win!")
            self._transition_to_scene("MainMenuScene")
            return True
        return False
```

This updated implementation now includes the random resolution of ties in skill execution order, as required. The `resolution_phase` method now handles three cases:
1. When the player's creature is faster
2. When the opponent's creature is faster
3. When both creatures have equal speed (the new tie-breaker case)

In the case of a tie, we use `random.sample` to randomly select the order of execution. This ensures that when creatures have the same speed, either creature has an equal chance of attacking first, meeting the specified requirement.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "d710e479-7511-4b8e-bc87-39f76dbdc55c", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
