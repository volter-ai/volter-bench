Role: system
Content: 
__________________
Role: user
Content: You are a professional programmer and code reviewer. Your task is to review a piece of code and determine whether it correctly implements the described architecture and logic of a game. Here are the files you need to consider:

```markdown main_game/docs/overview.md
# Overview

This is the overview document for a creature battler game. In this game, the player assembles a team of creatures to fight against another player's team of creatures to see who can reduce their opponent's health to zero first.

## Game Scenes

- **MainMenuScene** - This is the starting scene and where the player can choose to play or quit.
- **MainGameScene** - This is the scene where the action takes place. Here, the player does battle against a bot opponent.

## Game Entities

- **Player** - A thing that represents a human or bot within the game, and is controlled by the human or bot.
- **Creature** - A thing that does battle within the game. **Player**s manage a team of creatures in battle.
- **Skill** - A thing that represents the actions that the **Creature**s are able to take in battle.
```

```markdown main_game/docs/scenes/main_game_scene.md
# MainGameScene

The Main Game Scene is where the human player does battle against a bot player using their teams of creatures. This is a scene that can be played by one player, but should be treated like a symmetric multiplayer scene.

## Scene Logic

The scene starts off by putting the player's first creature out as the active creature participating in battle.

The scene plays through repeating turns with distinct phases. Turns consist of:
- Player Choice Phase
- Foe Choice Phase
- Resolution Phase

### Player Choice Phase

The player choice phase is a branching series of choices. It begins by offering the player two choices, which then leads to a new set of choices to get shown to the player.
- "Attack" - The player's active creature's skills are shown as choices. When the player chooses one of these skills, it is added to the queue of the actions for the turn and the turn proceeds to the next phase. The player also is shown the choice to go "Back", which sends the player back to the previous set of choices.
- "Swap" - The player's list of creatures are shown as a list of choices. The player's active creature and any creatures with zero hp are excluded from this list. When the player chooses one of the creatures, it is added to the queue of actions for the turn and the turn proceeds to the next phase. The player also is shown the choice to go "Back", which sends the player back to the previous set of choices.

### Foe Choice Phase

The foe choice phase is identical to the player choice phase, but instead is played by the bot player instead of the human player.

### Resolution Phase

During the resolution phase, the actions that were queued in the previous two steps are resolved. 

The order in which the skills are executed depends on the speed of the creature using the skill. The creature that has the higher speed stat executes their skill first. If the creatures have the same speed, then which creature goes first is decided randomly, with either creature having equal chance of being picked to go first.

However, if either player chooses to swap creatures, that is always executed before skills. The creature that gets swapped in gets hit by its opponent's queued skill.

#### Skill Execution

When executing a skill, the damage dealt is calculated in two passes. First, a raw damage value is calculated in one of two ways depending on whether the skill is physical or if it is a non-physical (special) skill.

If the skill is physical, then the raw damage is calculated as the skill's base damage plus the attacker's attack minus the defender's defense. In other words:
```
[raw damage] = [attacker attack] + [skill base damage] - [defender defense]
```

If the skill is non-physical (special), then the raw damage is calculated as the ratio between the attacker's sp. attack and the defender's sp. defense multiplied against the skill's base damage:
```
[raw damage] = [attacker sp. attack]/[defender sp. defense] * [skill base damage]
```

The final damage is then calculated by taking the raw damage and multiplying it by a weakness-resistance factor depending on the matchup of the skill type against the defender's creature type:
```
[final damage] = [weakness-resistance factor] * [raw damage]
```
All the damage formulas should be performed with floats, and then converted to an integer as the final damage. The final damage value is subtracted from the defender's hp. 

#### Type Relationships

When calculating the damage dealt by a skill, a weakness-resistance factor needs to be found by comparing the skill type against the defender's creature type. 
- If a skill type is effective against a creature type, the factor is 2 (the skill does double damage). 
- If a skill type is ineffective  against a creature type, the factor is 1/2 (the skill does half damage).

The following are the relationships between the handful of types in the game:
- "Normal" | Is neither effective nor ineffective against any other types.
- "Fire" | Effective against Leaf | Ineffective against Water
- "Water" | Effective against Fire | Ineffective against Leaf
- "Leaf" | Effective against Water | Ineffective against Fire

### Forced Swapping & Battle End

At any point when one creature's hp reaches zero (it is considered "knocked-out"), the creature's owner (a player) is asked to swap to another creature as long as they have any creatures with nonzero hp. This is presented as a list of choices of those creatures. If a player has no creatures available, then the battle ends. The player with all of their creatures knocked out is considered the loser and the other player is the winner. The player is then informed of their win or loss, depending on whether they still have creatures with nonzero hp.

When leaving this scene, reset the state of the player's creatures.
```

```markdown main_game/docs/scenes/main_menu_scene.md
# MainMenuScene

The Main Menu scene allows the player to play the game or quit.

## Scene Logic

At the start of the scene, the player is shown a welcome message and the scene then prompts the player to play or quit. 
- One choice that will take the player to the **MainGameScene**.
- One choice that quits the game entirely.

```

```markdown main_game/docs/feature_requests/03_player_prototypes.md
# Player Prototypes

This is a document describing the different players that exist in the game. Prototypes are the base instances of the thing.

## Prototypes

- "Default Player" | Creatures: ["bubwool", "dumbird"]
- "Basic Opponent" | Creatures: ["scizard", "dumbird"]
```

```markdown main_game/docs/feature_requests/02_creature_prototypes.md
# Creature Prototypes

This is a document describing the different creatures that exist in the game. Prototypes are the base instances of the thing.

## Prototypes

- "Bubwool" | "water" type | 32 hp | 11 attack | 10 defense | 12 sp. attack | 12 sp. defense | 13 speed | Skills: ["Tackle", "Lick"]
- "Scizard" | "fire" type | 40 hp | 11 attack | 13 defense | 11 sp. attack | 13 sp. defense | 11 speed | Skills: ["Tackle", "Fireball"]
- "Dumbird" | "normal" type | 17 hp | 7 attack | 9 defense | 7 sp. attack | 4 sp. defense | 17 speed | Skills ["Tackle"]
```

```markdown main_game/docs/feature_requests/01_skill_prototypes.md
# Skill Prototypes

This is a document describing the different skills that exist in the game. Prototypes are the base instances of the thing.

## Prototypes

- "Tackle" | "normal" type | physical | 7 damage | "Throw yourself at a foe, dealing damage."
- "Fireball" | "fire" type | special | 5 damage | "Throw fire at a foe, dealing damage."
- "Lick" | "water" type | physical | 5 damage | "Lick a foe with a wet tongue, dealing damage."
```

```markdown main_game/docs/models/skill.md
# Skill

Skill represents actions that creatures can take in battle.

## Additional Attributes

- `skill_type` - A string representing the elemental affinity of the skill. This is used in deciding whether the skill is effective or ineffective against a target.
- `is_physical` - A boolean indicating whether the skill is a physical skill or a non-physical (special) skill.
- `base_damage` - An integer representing the damage that is dealt to a foe when the skill is executed.
```

```markdown main_game/docs/models/player.md
# Player

The Player is an entity in the game "Creature Battle" that is controlled by a human or a bot. 

## Additional Attributes

- `creatures` - The collection of creatures that the player has at their disposal. 
- `active_creature` - The player's creature that is currently on the field and participating in battle.
```

```markdown main_game/docs/models/creature.md
# Creature

Creature is an entity in the creature battler game that participates in battles.

## Additional Attributes

- `creature_type` - A string representing the creature's elemental affinity. This decides the creature's weaknesses and resistances.
- `hp` - An integer representing the number of health points the creature has. The creature is knocked out when this number reaches zero.
- `max_hp` - An integer representing the maximum number of health points a creature can have.
- `attack` - An integer representing the added power behind the creature's physical attacks.
- `defense` - An integer representing the creature's physical resistance to physical attacks.
- `sp_attack` - An integer representing the added power behind the creature's non-physical attacks.
- `sp_defense` - An integer representing the creature's physical resistance to non-physical attacks.
- `speed` - An integer representing the creature's priority when deciding turn order.
- `skills` - A collection of the skills that the creature has access to in battle.
```

First create an exhaustive checklist that covers all the logic and functionality from the architecture docs above. This should be in the format of an acceptance criteria. Don't include anything in the checklist which is not explicitly written in the architecture doc. Each checklist should have a 'citation' of the line of the arch doc it refers to
__________________
Role: assistant
Content: Here is an exhaustive checklist based on the provided architecture documents. Each item includes a citation to the relevant part of the architecture documentation:

### Main Menu Scene
1. The Main Menu scene displays a welcome message at the start.  
   - Citation: `main_game/docs/scenes/main_menu_scene.md` - "At the start of the scene, the player is shown a welcome message..."
2. The Main Menu scene offers the player a choice to play the game, which transitions to the MainGameScene.  
   - Citation: `main_game/docs/scenes/main_menu_scene.md` - "One choice that will take the player to the **MainGameScene**."
3. The Main Menu scene offers the player a choice to quit the game.  
   - Citation: `main_game/docs/scenes/main_menu_scene.md` - "One choice that quits the game entirely."

### Main Game Scene
4. The Main Game Scene starts with the player's first creature as the active creature.  
   - Citation: `main_game/docs/scenes/main_game_scene.md` - "The scene starts off by putting the player's first creature out as the active creature..."
5. The Main Game Scene consists of repeating turns with Player Choice Phase, Foe Choice Phase, and Resolution Phase.  
   - Citation: `main_game/docs/scenes/main_game_scene.md` - "The scene plays through repeating turns with distinct phases. Turns consist of: Player Choice Phase, Foe Choice Phase, Resolution Phase."

#### Player Choice Phase
6. The Player Choice Phase offers the player the choice to "Attack" or "Swap".  
   - Citation: `main_game/docs/scenes/main_game_scene.md` - "The player choice phase is a branching series of choices. It begins by offering the player two choices..."
7. If "Attack" is chosen, the player's active creature's skills are shown as choices.  
   - Citation: `main_game/docs/scenes/main_game_scene.md` - "The player's active creature's skills are shown as choices."
8. If a skill is chosen, it is added to the queue of actions for the turn, and the turn proceeds to the next phase.  
   - Citation: `main_game/docs/scenes/main_game_scene.md` - "When the player chooses one of these skills, it is added to the queue of the actions for the turn and the turn proceeds to the next phase."
9. If "Swap" is chosen, the player's list of creatures (excluding the active creature and those with zero hp) is shown.  
   - Citation: `main_game/docs/scenes/main_game_scene.md` - "The player's list of creatures are shown as a list of choices. The player's active creature and any creatures with zero hp are excluded from this list."
10. If a creature is chosen to swap, it is added to the queue of actions for the turn, and the turn proceeds to the next phase.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "When the player chooses one of the creatures, it is added to the queue of actions for the turn and the turn proceeds to the next phase."
11. The player can choose to go "Back" to the previous set of choices.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "The player also is shown the choice to go 'Back', which sends the player back to the previous set of choices."

#### Foe Choice Phase
12. The Foe Choice Phase is identical to the Player Choice Phase but is controlled by the bot.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "The foe choice phase is identical to the player choice phase, but instead is played by the bot player instead of the human player."

#### Resolution Phase
13. Actions queued in the Player and Foe Choice Phases are resolved in the Resolution Phase.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "During the resolution phase, the actions that were queued in the previous two steps are resolved."
14. Skills are executed based on the speed of the creatures; higher speed goes first.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "The order in which the skills are executed depends on the speed of the creature using the skill."
15. If creatures have the same speed, the order is decided randomly.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "If the creatures have the same speed, then which creature goes first is decided randomly..."
16. Swapping creatures is executed before skills.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "However, if either player chooses to swap creatures, that is always executed before skills."
17. The creature swapped in gets hit by the opponent's queued skill.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "The creature that gets swapped in gets hit by its opponent's queued skill."

#### Skill Execution
18. Physical skill damage is calculated as `[attacker attack] + [skill base damage] - [defender defense]`.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "If the skill is physical, then the raw damage is calculated as the skill's base damage plus the attacker's attack minus the defender's defense."
19. Non-physical skill damage is calculated as `[attacker sp. attack]/[defender sp. defense] * [skill base damage]`.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "If the skill is non-physical (special), then the raw damage is calculated as the ratio between the attacker's sp. attack and the defender's sp. defense multiplied against the skill's base damage."
20. Final damage is calculated as `[weakness-resistance factor] * [raw damage]`.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "The final damage is then calculated by taking the raw damage and multiplying it by a weakness-resistance factor..."
21. All damage calculations are performed with floats and then converted to an integer.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "All the damage formulas should be performed with floats, and then converted to an integer as the final damage."
22. Final damage is subtracted from the defender's hp.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "The final damage value is subtracted from the defender's hp."

#### Type Relationships
23. Weakness-resistance factor is 2 if the skill type is effective against the creature type.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "If a skill type is effective against a creature type, the factor is 2..."
24. Weakness-resistance factor is 1/2 if the skill type is ineffective against the creature type.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "If a skill type is ineffective against a creature type, the factor is 1/2..."
25. "Normal" type is neither effective nor ineffective against any other types.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "Normal | Is neither effective nor ineffective against any other types."
26. "Fire" type is effective against "Leaf" and ineffective against "Water".  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "Fire | Effective against Leaf | Ineffective against Water"
27. "Water" type is effective against "Fire" and ineffective against "Leaf".  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "Water | Effective against Fire | Ineffective against Leaf"
28. "Leaf" type is effective against "Water" and ineffective against "Fire".  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "Leaf | Effective against Water | Ineffective against Fire"

### Forced Swapping & Battle End
29. When a creature's hp reaches zero, the owner is prompted to swap to another creature with nonzero hp.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "At any point when one creature's hp reaches zero... the creature's owner (a player) is asked to swap to another creature..."
30. If a player has no creatures with nonzero hp, the battle ends, and they lose.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "If a player has no creatures available, then the battle ends. The player with all of their creatures knocked out is considered the loser..."
31. The player is informed of their win or loss.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "The player is then informed of their win or loss..."
32. When leaving the Main Game Scene, the state of the player's creatures is reset.  
    - Citation: `main_game/docs/scenes/main_game_scene.md` - "When leaving this scene, reset the state of the player's creatures."

### Player Prototypes
33. "Default Player" has creatures "bubwool" and "dumbird".  
    - Citation: `main_game/docs/feature_requests/03_player_prototypes.md` - "Default Player | Creatures: ['bubwool', 'dumbird']"
34. "Basic Opponent" has creatures "scizard" and "dumbird".  
    - Citation: `main_game/docs/feature_requests/03_player_prototypes.md` - "Basic Opponent | Creatures: ['scizard', 'dumbird']"

### Creature Prototypes
35. "Bubwool" is a "water" type with 32 hp, 11 attack, 10 defense, 12 sp. attack, 12 sp. defense, 13 speed, and skills ["Tackle", "Lick"].  
    - Citation: `main_game/docs/feature_requests/02_creature_prototypes.md` - "Bubwool | 'water' type | 32 hp | 11 attack | 10 defense | 12 sp. attack | 12 sp. defense | 13 speed | Skills: ['Tackle', 'Lick']"
36. "Scizard" is a "fire" type with 40 hp, 11 attack, 13 defense, 11 sp. attack, 13 sp. defense, 11 speed, and skills ["Tackle", "Fireball"].  
    - Citation: `main_game/docs/feature_requests/02_creature_prototypes.md` - "Scizard | 'fire' type | 40 hp | 11 attack | 13 defense | 11 sp. attack | 13 sp. defense | 11 speed | Skills: ['Tackle', 'Fireball']"
37. "Dumbird" is a "normal" type with 17 hp, 7 attack, 9 defense, 7 sp. attack, 4 sp. defense, 17 speed, and skills ["Tackle"].  
    - Citation: `main_game/docs/feature_requests/02_creature_prototypes.md` - "Dumbird | 'normal' type | 17 hp | 7 attack | 9 defense | 7 sp. attack | 4 sp. defense | 17 speed | Skills ['Tackle']"

### Skill Prototypes
38. "Tackle" is a "normal" type, physical skill with 7 damage.  
    - Citation: `main_game/docs/feature_requests/01_skill_prototypes.md` - "Tackle | 'normal' type | physical | 7 damage"
39. "Fireball" is a "fire" type, special skill with 5 damage.  
    - Citation: `main_game/docs/feature_requests/01_skill_prototypes.md` - "Fireball | 'fire' type | special | 5 damage"
40. "Lick" is a "water" type, physical skill with 5 damage.  
    - Citation: `main_game/docs/feature_requests/01_skill_prototypes.md` - "Lick | 'water' type | physical | 5 damage"

### Skill Model
41. Skill has an attribute `skill_type` representing the elemental affinity.  
    - Citation: `main_game/docs/models/skill.md` - "`skill_type` - A string representing the elemental affinity of the skill."
42. Skill has an attribute `is_physical` indicating if it is a physical skill.  
    - Citation: `main_game/docs/models/skill.md` - "`is_physical` - A boolean indicating whether the skill is a physical skill..."
43. Skill has an attribute `base_damage` representing the damage dealt.  
    - Citation: `main_game/docs/models/skill.md` - "`base_damage` - An integer representing the damage that is dealt to a foe..."

### Player Model
44. Player has an attribute `creatures` representing the collection of creatures.  
    - Citation: `main_game/docs/models/player.md` - "`creatures` - The collection of creatures that the player has at their disposal."
45. Player has an attribute `active_creature` representing the creature currently in battle.  
    - Citation: `main_game/docs/models/player.md` - "`active_creature` - The player's creature that is currently on the field..."

### Creature Model
46. Creature has an attribute `creature_type` representing its elemental affinity.  
    - Citation: `main_game/docs/models/creature.md` - "`creature_type` - A string representing the creature's elemental affinity."
47. Creature has an attribute `hp` representing its current health points.  
    - Citation: `main_game/docs/models/creature.md` - "`hp` - An integer representing the number of health points the creature has."
48. Creature has an attribute `max_hp` representing its maximum health points.  
    - Citation: `main_game/docs/models/creature.md` - "`max_hp` - An integer representing the maximum number of health points a creature can have."
49. Creature has an attribute `attack` representing its physical attack power.  
    - Citation: `main_game/docs/models/creature.md` - "`attack` - An integer representing the added power behind the creature's physical attacks."
50. Creature has an attribute `defense` representing its physical defense.  
    - Citation: `main_game/docs/models/creature.md` - "`defense` - An integer representing the creature's physical resistance to physical attacks."
51. Creature has an attribute `sp_attack` representing its non-physical attack power.  
    - Citation: `main_game/docs/models/creature.md` - "`sp_attack` - An integer representing the added power behind the creature's non-physical attacks."
52. Creature has an attribute `sp_defense` representing its non-physical defense.  
    - Citation: `main_game/docs/models/creature.md` - "`sp_defense` - An integer representing the creature's physical resistance to non-physical attacks."
53. Creature has an attribute `speed` representing its turn order priority.  
    - Citation: `main_game/docs/models/creature.md` - "`speed` - An integer representing the creature's priority when deciding turn order."
54. Creature has an attribute `skills` representing the skills it can use in battle.  
    - Citation: `main_game/docs/models/creature.md` - "`skills` - A collection of the skills that the creature has access to in battle."
__________________
Role: user
Content: Game engine:
```python engine/lib.py
def make_uuid():
    return str(uuid.uuid4())




class AbstractGameEntity(BaseModel, ABC):  # external
    uid: str = Field(default_factory=make_uuid)  # external
    display_name: str  # external
    description: str = ""  # external
    prototype_id: str  # external




TAbstractThing = TypeVar('TAbstractThing', bound='AbstractThing')


class AbstractThing(AbstractGameEntity, ABC):
    prototype_id: str



    @classmethod
    def get_data(cls):
        file_path = os.path.join("main_game/content", f"{cls.__name__.lower()}.json")
        with open(file_path) as data:
            return json.load(data)

    @classmethod
    def get_ids(cls):
        return list(cls.get_data().get("prototypes").keys())

    def __hash__(self):
        raise FixableException(
            "Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id")


    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """ During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """
        try:
            data = cls.get_data().get("prototypes")[prototype_id]
            data["prototype_id"] = prototype_id
            data["category"] = cls.__name__
        except KeyError as e:
            raise Exception(
                f'The JSON file corresponding to the {cls.__name__} model does not have a prototype entry called: "{prototype_id}"') from e
        return cls._create_from_data(data)

    @classmethod

    @staticmethod
    def _process_value(annotation, value):
        origin = get_origin(annotation)
        if origin is list:
            item_type = get_args(annotation)[0]
            if issubclass(item_type, AbstractThing):
                return [item_type.from_prototype_id(item_prototype_id) for item_prototype_id in value]
        elif isinstance(annotation, type) and issubclass(annotation, AbstractThing):
            return annotation.from_prototype_id(value)
        return value




class AbstractChoice(ABC, BaseModel):
    id: str = Field(default_factory=make_uuid)


class Button(AbstractChoice):
    display_name: str = ""
    slug: str = ""

    def __init__(self, display_name: str):
        super().__init__(display_name=display_name)

    def __repr__(self):
        return f"Button({self.display_name})"


class SelectThing(AbstractChoice):
    select_action_type: str = "SelectThing"
    thing: "AbstractThing"
    label: Optional[str] = ""

    def __init__(self, thing: "AbstractThing", **kwargs):
        assert issubclass(thing.__class__, AbstractThing), (
            f"SelectThing can only be constructed with a Thing, not '{thing}'")
        super().__init__(thing=thing, **kwargs)

    def __repr__(self):
        return f"{self.select_action_type}({self.thing.__class__.__name__}({self.thing.prototype_id}))"


class AbstractPlayerListener(ABC):
    player: "AbstractPlayer" = None

    @abstractmethod
    def on_wait_for_choice(self, scene: "AbstractGameScene", choices: List[AbstractChoice]) -> AbstractChoice:
        pass

    @abstractmethod
    def on_show_event(self, event_type: str, event_data: Dict[str, Any]):
        pass

    @abstractmethod
    def on_go_to_single_player_scene(self, app: "AbstractApp", scene_name: str):
        pass

    @abstractmethod
    def on_show_scene(self, scene_name: str, view_data: Dict[str, Any]):
        pass


class GracefulExit(Exception):
    pass


class RandomModeGracefulExit(GracefulExit):
    def __init__(self):
        super().__init__(
            "HumanListener is in random mode and the current run is now over. This is exception is expected")


class HumanListener(AbstractPlayerListener):
    random_mode: bool = False
    random_mode_counter: int = 100  # number of moves to make in random mode

    def on_wait_for_choice(self, scene: "AbstractGameScene", choices: List[AbstractChoice]) -> AbstractChoice:
        if HumanListener.random_mode or self.random_mode:
            assert str(scene)
            self.random_mode_counter -= 1
            if self.random_mode_counter <= 0:
                raise RandomModeGracefulExit()
            return random.choice(choices)

        for i, choice in enumerate(choices):
            print(f"{i + 1}: {choice}")
        while True:
            try:
                choice_idx = int(input(f"Enter your choice: "))
                return choices[choice_idx - 1]
            except (IndexError, ValueError):
                continue

    def on_show_event(self, event_type: str, event_data: Dict[str, Any]):
        if event_type == "show_text":
            print(event_data.get('text'))
        else:
            print(f"{event_type}: {event_data}")

    def on_show_scene(self, scene_name: str, view_data: Dict[str, Any]):
        pass

    def on_go_to_single_player_scene(self, app: "AbstractApp", scene_id: str):
        app.transition_to_scene(scene_id, player=self.player)


class BotListener(AbstractPlayerListener):
    def on_wait_for_choice(self, scene: "AbstractGameScene", choices: List[AbstractChoice]) -> AbstractChoice:
        return random.choice(choices)

    def on_show_event(self, event_type: str, event_data: Dict[str, Any]):
        print(f"BotListener:on_show_event:{event_type}: {event_data}")
        # Bot doesn't need to print events, but we'll keep this method for consistency
        pass

    def on_show_scene(self, scene_name: str, view_data: Dict[str, Any]):
        # Bot doesn't need to print scene view data
        pass

    def on_go_to_single_player_scene(self, app: "AbstractApp", scene_name: str):
        print(f"bot {BotListener.player.display_name} is going to bot heaven")


class AbstractPlayer(AbstractThing, ABC):
    _listener: AbstractPlayerListener = None


    def set_listener(self, listener: AbstractPlayerListener):
        self._listener = listener
        self._listener.player = self

    def __repr__(self):
        return self.display_name


T = TypeVar('T', bound=AbstractPlayer)


class AbstractGameScene(AbstractGameEntity, Generic[T]):
    _app: "AbstractApp" = None
    player: AbstractPlayer = None

    def __init__(self, app: "AbstractApp", player: AbstractPlayer):
        super().__init__(display_name=self.__class__.__name__, prototype_id=self.__class__.__name__, player=player)
        self._app = app
        self.player = player

    @abstractmethod
    def __str__(self):
        """A user should be able to look at this str and see all the information they need to navigate the scene"""
        pass

    @abstractmethod
    def run(self):
        pass

    def _wait_for_choice(self, player: AbstractPlayer, choices: List[AbstractChoice]) -> AbstractChoice:
        assert len(choices) > 0, "`_wait_for_choice` was called with no choices"
        if isinstance(self, AbstractMultiplayerScene):
            for p in self.players:
                if p != player:
                    p._listener.on_show_event(event_type="OnGamePending",
                                              event_data=OnGamePending(text=f"Waiting for {player}...").model_dump()
                                              )

        # print(f"{self.__class__.__name__}:_wait_for_choice({player.display_name}, {str(choices)})")
        choice = player._listener.on_wait_for_choice(self, choices)
        # print(f"{self.__class__.__name__}:_wait_for_choice received choice {str(choice)}")
        return choice

    def _show_text(self, player: AbstractPlayer, text: str):
        """ this shows text as a popup """
        player._listener.on_show_event("show_text", {"text": text})

    def _quit_whole_game(self):
        self._app.quit_whole_game()

    def _transition_to_scene(self, scene_name: str):
        self._app.transition_to_scene(scene_name, player=self.player)






TGameScene = TypeVar('TGameScene', bound=AbstractGameScene)




class AbstractApp(ABC):
    class _QuitWholeGame(GracefulExit):
        def __init__(self,
                     message: str = "Game terminated gracefully. If you intended to quit the game, this exception is expected and should be caught"):
            super().__init__(message)

    scene_registry: Dict[str, Type[TGameScene]]
    entry_point_scene_id: str
    matchmaking_wait_time = 0


    def __init__(self):
        self.scene_registry = {}

    def register_scene(self, scene_id: str, scene_factory: Type[TGameScene], is_entry_point: bool = False):
        self.scene_registry[scene_id] = scene_factory
        if is_entry_point:
            assert not issubclass(scene_factory, AbstractMultiplayerScene), "Cannot start with multiplayer scene"
            self.entry_point_scene_id = scene_id

    def quit_whole_game(self):
        raise AbstractApp._QuitWholeGame()

    def run(self, player: AbstractPlayer):
        try:
            self.transition_to_scene(self.entry_point_scene_id, player=player)
        except AbstractApp._QuitWholeGame:
            AbstractApp.broadcast_event(OnGameEnd())
            print("game exited gracefully")



    def go_to_lobby(self, scene_factory, player: AbstractPlayer):
        self.__run_scene(
            LobbyScene(self, player, scene_target=scene_factory, matchmaking_wait_time=self.matchmaking_wait_time))


        # TODO: allow kwargs


    def transition_to_scene(self, scene_id: str, **kwargs):
        scene_factory = self.scene_registry[scene_id]
        scene = scene_factory(app=self, **kwargs)
        self.__run_scene(scene)




    def __run_scene(self, scene: AbstractGameScene):
        if len(self._scene_stack) == 1:
            AbstractApp.broadcast_event(OnGameStart())

        self._show_changes()

        scene.run()



    @abstractmethod
    def create_player(self, player_id: str) -> AbstractPlayer:
        pass

    @abstractmethod
    def create_bot(self, prototype_id: str) -> AbstractPlayer:
        pass














































```

Game codebase:
```python main_game/models.py
from __future__ import annotations
from typing import List
from mini_game_engine.engine.lib import AbstractThing, AbstractPlayer, Field


class Skill(AbstractThing):
    category: str = "Skill"
    skill_type: str
    is_physical: bool
    base_damage: int

class Creature(AbstractThing):
    category: str = "Creature"
    creature_type: str
    hp: int
    max_hp: int
    attack: int
    defense: int
    sp_attack: int
    sp_defense: int
    speed: int
    skills: List[Skill]

class Player(AbstractPlayer):
    category: str = "Player"
    creatures: List[Creature]
    active_creature: Creature = Field(default=None)

```

```python main_game/main.py
import uuid
from mini_game_engine.engine.lib import AbstractApp, HumanListener, BotListener
from main_game.models import Player
from main_game.scenes.main_menu_scene import MainMenuScene
from main_game.scenes.main_game_scene import MainGameScene


class App(AbstractApp):
    def __init__(self):
        super().__init__()
        self.register_scene("MainMenuScene", MainMenuScene, is_entry_point=True)
        self.register_scene("MainGameScene", MainGameScene)

    def create_player(self, player_id: str):
        player = Player.from_prototype_id(prototype_id="default_player")
        player.uid = player_id
        player.set_listener(HumanListener())
        return player

    def create_bot(self, prototype_id: str):
        bot = Player.from_prototype_id(prototype_id=prototype_id)
        bot.uid = str(uuid.uuid4())
        bot.set_listener(BotListener())
        return bot

if __name__ == '__main__':
    app = App()
    app.run(app.create_player("just_a_guy"))

```

```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random


class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = self._app.create_bot("basic_opponent")
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]
        self.player_action = None
        self.bot_action = None

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}: {self.player.active_creature.display_name} (HP: {self.player.active_creature.hp}/{self.player.active_creature.max_hp})
{self.bot.display_name}: {self.bot.active_creature.display_name} (HP: {self.bot.active_creature.hp}/{self.bot.active_creature.max_hp})

> Attack
> Swap
"""

    def run(self):
        while True:
            self.player_turn()
            if self.check_battle_end():
                break
            self.bot_turn()
            if self.check_battle_end():
                break
            self.resolution_phase()
            if self.check_battle_end():
                break
        self._transition_to_scene("MainMenuScene")

    def player_turn(self):
        while True:
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choices = [attack_button, swap_button]
            choice = self._wait_for_choice(self.player, choices)

            if choice == attack_button:
                skill = self.choose_skill(self.player)
                if skill:
                    self.player_action = ("attack", skill)
                    return
            elif choice == swap_button:
                creature = self.choose_creature(self.player)
                if creature:
                    self.player_action = ("swap", creature)
                    return

    def bot_turn(self):
        if random.random() < 0.2 and len([c for c in self.bot.creatures if c.hp > 0]) > 1:
            available_creatures = [c for c in self.bot.creatures if c != self.bot.active_creature and c.hp > 0]
            self.bot_action = ("swap", random.choice(available_creatures))
        else:
            self.bot_action = ("attack", random.choice(self.bot.active_creature.skills))

    def choose_skill(self, player):
        skills = [SelectThing(skill) for skill in player.active_creature.skills]
        back_button = Button("Back")
        choices = skills + [back_button]
        choice = self._wait_for_choice(player, choices)
        return choice.thing if choice != back_button else None

    def choose_creature(self, player):
        creatures = [SelectThing(creature) for creature in player.creatures if creature != player.active_creature and creature.hp > 0]
        back_button = Button("Back")
        choices = creatures + [back_button]
        choice = self._wait_for_choice(player, choices)
        return choice.thing if choice != back_button else None

    def resolution_phase(self):
        actions = [
            (self.player, self.player.active_creature, self.player_action),
            (self.bot, self.bot.active_creature, self.bot_action)
        ]

        actions.sort(key=lambda x: (x[2][0] != "swap", -x[1].speed))

        for player, creature, action in actions:
            if action[0] == "swap":
                self._show_text(self.player, f"{player.display_name} swaps {creature.display_name} with {action[1].display_name}")
                player.active_creature = action[1]
            elif action[0] == "attack":
                self.execute_skill(player, action[1])

        self.player_action = None
        self.bot_action = None

    def execute_skill(self, attacker, skill):
        defender = self.bot if attacker == self.player else self.player
        defender_creature = defender.active_creature

        self._show_text(self.player, f"{attacker.display_name}'s {attacker.active_creature.display_name} uses {skill.display_name}")

        if skill.is_physical:
            raw_damage = attacker.active_creature.attack + skill.base_damage - defender_creature.defense
        else:
            raw_damage = (attacker.active_creature.sp_attack / defender_creature.sp_defense) * skill.base_damage

        type_effectiveness = self.get_type_effectiveness(skill.skill_type, defender_creature.creature_type)
        final_damage = int(raw_damage * type_effectiveness)

        defender_creature.hp = max(0, defender_creature.hp - final_damage)
        self._show_text(self.player, f"{defender.display_name}'s {defender_creature.display_name} takes {final_damage} damage")

        if defender_creature.hp == 0:
            self._show_text(self.player, f"{defender.display_name}'s {defender_creature.display_name} is knocked out!")
            self.force_swap(defender)

    def get_type_effectiveness(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("water", "fire"): 2,
            ("leaf", "water"): 2,
            ("fire", "water"): 0.5,
            ("water", "leaf"): 0.5,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def force_swap(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if not available_creatures:
            self._show_text(self.player, f"{player.display_name} has no more creatures available!")
            return

        if player == self.player:
            self._show_text(self.player, "Choose a creature to swap in:")
            new_creature = self.choose_creature(player)
        else:
            new_creature = random.choice(available_creatures)

        if new_creature is None:
            self._show_text(self.player, f"{player.display_name} has no more creatures available!")
            return

        player.active_creature = new_creature
        self._show_text(self.player, f"{player.display_name} sends out {new_creature.display_name}")

    def check_battle_end(self):
        if all(creature.hp <= 0 for creature in self.player.creatures):
            self._show_text(self.player, "You lost the battle!")
            return True
        if all(creature.hp <= 0 for creature in self.bot.creatures):
            self._show_text(self.player, "You won the battle!")
            return True
        return False

```

```python main_game/scenes/main_menu_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button


class MainMenuScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)

    def __str__(self):
        return """===Main Menu===
Welcome to Creature Battler!

> Play
> Quit
"""

    def run(self):
        while True:
            play_button = Button("Play")
            quit_button = Button("Quit")
            choices = [play_button, quit_button]
            choice = self._wait_for_choice(self.player, choices)

            if choice == play_button:
                self._transition_to_scene("MainGameScene")
            elif choice == quit_button:
                self._quit_whole_game()

```

```python main_game/tests/test_whole_game.py
import os
import sys

from mini_game_engine.engine.lib import HumanListener, RandomModeGracefulExit
from main_game.main import App


def test_full_game_flow_random_with_bots():
    for i in range(10):
        print(f"starting random run iteration {i}")
        HumanListener.random_mode = True
        HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
        App.matchmaking_wait_time = 0
        original_wait_time = App.matchmaking_wait_time

        app = App()

        # Create a human player
        human_player = app.create_player("HumanPlayer")
        human_player.set_listener(HumanListener())

        try:
            app.run(human_player)
        except RandomModeGracefulExit as e:
            # exited gracefully
            pass
        finally:
            App.matchmaking_wait_time = original_wait_time


```

```python main_game/tests/test_main_menu_scene.py
import pytest
from unittest.mock import patch
from mini_game_engine.engine.lib import HumanListener, RandomModeGracefulExit
from main_game.main import App
from main_game.scenes.main_menu_scene import MainMenuScene


class TestMainMenuSceneRandomRun:
    @pytest.fixture
    def app(self):
        return App()

    def test_main_menu_scene_random_run(self, app):
        for i in range(10):
            print(f"starting random run iteration {i}")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 10

            player = app.create_player(f"player_{i}")
            main_menu_scene = MainMenuScene(app, player)

            class TransitionFromScene(Exception):
                pass

            def exit_scene(*args, **kwargs):
                raise TransitionFromScene()

            with patch.object(MainMenuScene, '_transition_to_scene', side_effect=exit_scene) as mock_transition, \
                    patch.object(MainMenuScene, '_quit_whole_game') as mock_quit:

                try:
                    main_menu_scene.run()
                except TransitionFromScene:
                    print(f"exiting target scene `MainMenuScene` so ending run {i}")
                except RandomModeGracefulExit:
                    print(f"`random_mode_counter` reached 0 and the game did not crash. Ending run {i} gracefully")
                else:
                    assert mock_transition.called or mock_quit.called, "scene was not exited in an expected manner"

                    if mock_quit.called:
                        print("_quit_whole_game called")
                    if mock_transition.called:
                        print("_transition_to_scene called")
                finally:
                    mock_transition.reset_mock()
                    mock_quit.reset_mock()

```

```python main_game/tests/test_main_game_scene.py
import pytest
from unittest.mock import patch
from mini_game_engine.engine.lib import HumanListener, RandomModeGracefulExit
from main_game.main import App
from main_game.scenes.main_game_scene import MainGameScene


class TestMainGameSceneRandomRun:
    @pytest.fixture
    def app(self):
        return App()

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f"starting random run iteration {i}")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # Increased to 30 for more complex scene

            player = app.create_player(f"player_{i}")
            main_game_scene = MainGameScene(app, player)

            class TransitionFromScene(Exception):
                pass

            def exit_scene(*args, **kwargs):
                raise TransitionFromScene()

            with patch.object(MainGameScene, '_transition_to_scene', side_effect=exit_scene) as mock_transition, \
                    patch.object(MainGameScene, '_quit_whole_game') as mock_quit:

                try:
                    main_game_scene.run()
                except TransitionFromScene:
                    print(f"exiting target scene `MainGameScene` so ending run {i}")
                except RandomModeGracefulExit:
                    print(f"`random_mode_counter` reached 0 and the game did not crash. Ending run {i} gracefully")
                else:
                    assert mock_transition.called or mock_quit.called, "scene was not exited in an expected manner"

                    if mock_quit.called:
                        print("_quit_whole_game called")
                    if mock_transition.called:
                        print("_transition_to_scene called")
                finally:
                    mock_transition.reset_mock()
                    mock_quit.reset_mock()

```

```json main_game/content/skill.json
{
  "prototypes": {
    "tackle": {
      "display_name": "Tackle",
      "description": "Throw yourself at a foe, dealing damage.",
      "skill_type": "normal",
      "is_physical": true,
      "base_damage": 7
    },
    "fireball": {
      "display_name": "Fireball",
      "description": "Throw fire at a foe, dealing damage.",
      "skill_type": "fire",
      "is_physical": false,
      "base_damage": 5
    },
    "lick": {
      "display_name": "Lick",
      "description": "Lick a foe with a wet tongue, dealing damage.",
      "skill_type": "water",
      "is_physical": true,
      "base_damage": 5
    }
  }
}

```

```json main_game/content/player.json
{
  "prototypes": {
    "default_player": {
      "display_name": "Default Player",
      "description": "The default human player",
      "creatures": ["bubwool", "dumbird"]
    },
    "basic_opponent": {
      "display_name": "Basic Opponent",
      "description": "A basic bot opponent",
      "creatures": ["scizard", "dumbird"]
    }
  }
}

```

```json main_game/content/creature.json
{
  "prototypes": {
    "bubwool": {
      "display_name": "Bubwool",
      "description": "A water-type creature",
      "creature_type": "water",
      "hp": 32,
      "max_hp": 32,
      "attack": 11,
      "defense": 10,
      "sp_attack": 12,
      "sp_defense": 12,
      "speed": 13,
      "skills": ["tackle", "lick"]
    },
    "scizard": {
      "display_name": "Scizard",
      "description": "A fire-type creature",
      "creature_type": "fire",
      "hp": 40,
      "max_hp": 40,
      "attack": 11,
      "defense": 13,
      "sp_attack": 11,
      "sp_defense": 13,
      "speed": 11,
      "skills": ["tackle", "fireball"]
    },
    "dumbird": {
      "display_name": "Dumbird",
      "description": "A normal-type creature",
      "creature_type": "normal",
      "hp": 17,
      "max_hp": 17,
      "attack": 7,
      "defense": 9,
      "sp_attack": 7,
      "sp_defense": 4,
      "speed": 17,
      "skills": ["tackle"]
    }
  }
}

```



Now check each of the checklist items against the code. Note any discrepancies, missing elements, or extra implementations that don't align with the described architecture.



Guidelines:

1. Only check the behavior which is explicitly described in the markdown files

2. Assume the engine module is correct, the only mistakes you should note should be in the `main_game` folder
__________________
Role: assistant
Content: Let's go through the checklist and verify each item against the code in the `main_game` folder. I'll note any discrepancies, missing elements, or extra implementations that don't align with the described architecture.

### Main Menu Scene
1. **Welcome Message**: The `MainMenuScene` class correctly displays a welcome message at the start.  
   - **Code Check**: `main_game/scenes/main_menu_scene.py` - `__str__` method contains the welcome message.
   - **Status**: Correct

2. **Choice to Play**: The `MainMenuScene` offers a choice to play the game, transitioning to `MainGameScene`.  
   - **Code Check**: `main_game/scenes/main_menu_scene.py` - `run` method handles the "Play" button.
   - **Status**: Correct

3. **Choice to Quit**: The `MainMenuScene` offers a choice to quit the game.  
   - **Code Check**: `main_game/scenes/main_menu_scene.py` - `run` method handles the "Quit" button.
   - **Status**: Correct

### Main Game Scene
4. **First Creature Active**: The `MainGameScene` starts with the player's first creature as the active creature.  
   - **Code Check**: `main_game/scenes/main_game_scene.py` - `__init__` method sets `self.player.active_creature`.
   - **Status**: Correct

5. **Repeating Turns**: The `MainGameScene` consists of repeating turns with Player Choice Phase, Foe Choice Phase, and Resolution Phase.  
   - **Code Check**: `main_game/scenes/main_game_scene.py` - `run` method implements the turn phases.
   - **Status**: Correct

#### Player Choice Phase
6. **Choice to "Attack" or "Swap"**: The Player Choice Phase offers the player the choice to "Attack" or "Swap".  
   - **Code Check**: `main_game/scenes/main_game_scene.py` - `player_turn` method offers these choices.
   - **Status**: Correct

7. **Show Skills on "Attack"**: If "Attack" is chosen, the player's active creature's skills are shown as choices.  
   - **Code Check**: `main_game/scenes/main_game_scene.py` - `choose_skill` method shows skills.
   - **Status**: Correct

8. **Queue Skill and Proceed**: If a skill is chosen, it is added to the queue of actions for the turn, and the turn proceeds to the next phase.  
   - **Code Check**: `main_game/scenes/main_game_scene.py` - `player_turn` method sets `self.player_action`.
   - **Status**: Correct

9. **Show Creatures on "Swap"**: If "Swap" is chosen, the player's list of creatures (excluding the active creature and those with zero hp) is shown.  
   - **Code Check**: `main_game/scenes/main_game_scene.py` - `choose_creature` method shows creatures.
   - **Status**: Correct

10. **Queue Creature and Proceed**: If a creature is chosen to swap, it is added to the queue of actions for the turn, and the turn proceeds to the next phase.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `player_turn` method sets `self.player_action`.
    - **Status**: Correct

11. **Choice to Go "Back"**: The player can choose to go "Back" to the previous set of choices.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `choose_skill` and `choose_creature` methods include a "Back" button.
    - **Status**: Correct

#### Foe Choice Phase
12. **Bot Choice Phase**: The Foe Choice Phase is identical to the Player Choice Phase but is controlled by the bot.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `bot_turn` method implements bot choices.
    - **Status**: Correct

#### Resolution Phase
13. **Resolve Actions**: Actions queued in the Player and Foe Choice Phases are resolved in the Resolution Phase.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `resolution_phase` method resolves actions.
    - **Status**: Correct

14. **Skill Execution Order by Speed**: Skills are executed based on the speed of the creatures; higher speed goes first.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `resolution_phase` method sorts actions by speed.
    - **Status**: Correct

15. **Random Order on Same Speed**: If creatures have the same speed, the order is decided randomly.  
    - **Code Check**: Not explicitly implemented in `resolution_phase`.
    - **Status**: Missing

16. **Swapping Before Skills**: Swapping creatures is executed before skills.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `resolution_phase` method prioritizes swaps.
    - **Status**: Correct

17. **Swapped Creature Hit by Skill**: The creature swapped in gets hit by the opponent's queued skill.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `resolution_phase` method handles this.
    - **Status**: Correct

#### Skill Execution
18. **Physical Skill Damage Calculation**: Physical skill damage is calculated as `[attacker attack] + [skill base damage] - [defender defense]`.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `execute_skill` method implements this.
    - **Status**: Correct

19. **Non-Physical Skill Damage Calculation**: Non-physical skill damage is calculated as `[attacker sp. attack]/[defender sp. defense] * [skill base damage]`.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `execute_skill` method implements this.
    - **Status**: Correct

20. **Final Damage Calculation**: Final damage is calculated as `[weakness-resistance factor] * [raw damage]`.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `execute_skill` method implements this.
    - **Status**: Correct

21. **Damage Calculations with Floats**: All damage calculations are performed with floats and then converted to an integer.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `execute_skill` method uses floats.
    - **Status**: Correct

22. **Subtract Final Damage from HP**: Final damage is subtracted from the defender's hp.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `execute_skill` method implements this.
    - **Status**: Correct

#### Type Relationships
23. **Effective Skill Type Factor**: Weakness-resistance factor is 2 if the skill type is effective against the creature type.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `get_type_effectiveness` method implements this.
    - **Status**: Correct

24. **Ineffective Skill Type Factor**: Weakness-resistance factor is 1/2 if the skill type is ineffective against the creature type.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `get_type_effectiveness` method implements this.
    - **Status**: Correct

25. **Normal Type Neutrality**: "Normal" type is neither effective nor ineffective against any other types.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `get_type_effectiveness` method implements this.
    - **Status**: Correct

26. **Fire Type Effectiveness**: "Fire" type is effective against "Leaf" and ineffective against "Water".  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `get_type_effectiveness` method implements this.
    - **Status**: Correct

27. **Water Type Effectiveness**: "Water" type is effective against "Fire" and ineffective against "Leaf".  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `get_type_effectiveness` method implements this.
    - **Status**: Correct

28. **Leaf Type Effectiveness**: "Leaf" type is effective against "Water" and ineffective against "Fire".  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `get_type_effectiveness` method implements this.
    - **Status**: Correct

### Forced Swapping & Battle End
29. **Prompt Swap on Knockout**: When a creature's hp reaches zero, the owner is prompted to swap to another creature with nonzero hp.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `force_swap` method implements this.
    - **Status**: Correct

30. **Battle Ends with No Creatures**: If a player has no creatures with nonzero hp, the battle ends, and they lose.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `check_battle_end` method implements this.
    - **Status**: Correct

31. **Inform Player of Win/Loss**: The player is informed of their win or loss.  
    - **Code Check**: `main_game/scenes/main_game_scene.py` - `check_battle_end` method implements this.
    - **Status**: Correct

32. **Reset Creature State on Exit**: When leaving the Main Game Scene, the state of the player's creatures is reset.  
    - **Code Check**: Not explicitly implemented.
    - **Status**: Missing

### Player Prototypes
33. **Default Player Creatures**: "Default Player" has creatures "bubwool" and "dumbird".  
    - **Code Check**: `main_game/content/player.json` - Correctly lists these creatures.
    - **Status**: Correct

34. **Basic Opponent Creatures**: "Basic Opponent" has creatures "scizard" and "dumbird".  
    - **Code Check**: `main_game/content/player.json` - Correctly lists these creatures.
    - **Status**: Correct

### Creature Prototypes
35. **Bubwool Attributes**: "Bubwool" is a "water" type with specified attributes and skills.  
    - **Code Check**: `main_game/content/creature.json` - Correctly defines Bubwool.
    - **Status**: Correct

36. **Scizard Attributes**: "Scizard" is a "fire" type with specified attributes and skills.  
    - **Code Check**: `main_game/content/creature.json` - Correctly defines Scizard.
    - **Status**: Correct

37. **Dumbird Attributes**: "Dumbird" is a "normal" type with specified attributes and skills.  
    - **Code Check**: `main_game/content/creature.json` - Correctly defines Dumbird.
    - **Status**: Correct

### Skill Prototypes
38. **Tackle Skill**: "Tackle" is a "normal" type, physical skill with 7 damage.  
    - **Code Check**: `main_game/content/skill.json` - Correctly defines Tackle.
    - **Status**: Correct

39. **Fireball Skill**: "Fireball" is a "fire" type, special skill with 5 damage.  
    - **Code Check**: `main_game/content/skill.json` - Correctly defines Fireball.
    - **Status**: Correct

40. **Lick Skill**: "Lick" is a "water" type, physical skill with 5 damage.  
    - **Code Check**: `main_game/content/skill.json` - Correctly defines Lick.
    - **Status**: Correct

### Skill Model
41. **Skill Type Attribute**: Skill has an attribute `skill_type` representing the elemental affinity.  
    - **Code Check**: `main_game/models.py` - `Skill` class defines `skill_type`.
    - **Status**: Correct

42. **Physical Skill Attribute**: Skill has an attribute `is_physical` indicating if it is a physical skill.  
    - **Code Check**: `main_game/models.py` - `Skill` class defines `is_physical`.
    - **Status**: Correct

43. **Base Damage Attribute**: Skill has an attribute `base_damage` representing the damage dealt.  
    - **Code Check**: `main_game/models.py` - `Skill` class defines `base_damage`.
    - **Status**: Correct

### Player Model
44. **Creatures Attribute**: Player has an attribute `creatures` representing the collection of creatures.  
    - **Code Check**: `main_game/models.py` - `Player` class defines `creatures`.
    - **Status**: Correct

45. **Active Creature Attribute**: Player has an attribute `active_creature` representing the creature currently in battle.  
    - **Code Check**: `main_game/models.py` - `Player` class defines `active_creature`.
    - **Status**: Correct

### Creature Model
46. **Creature Type Attribute**: Creature has an attribute `creature_type` representing its elemental affinity.  
    - **Code Check**: `main_game/models.py` - `Creature` class defines `creature_type`.
    - **Status**: Correct

47. **HP Attribute**: Creature has an attribute `hp` representing its current health points.  
    - **Code Check**: `main_game/models.py` - `Creature` class defines `hp`.
    - **Status**: Correct

48. **Max HP Attribute**: Creature has an attribute `max_hp` representing its maximum health points.  
    - **Code Check**: `main_game/models.py` - `Creature` class defines `max_hp`.
    - **Status**: Correct

49. **Attack Attribute**: Creature has an attribute `attack` representing its physical attack power.  
    - **Code Check**: `main_game/models.py` - `Creature` class defines `attack`.
    - **Status**: Correct

50. **Defense Attribute**: Creature has an attribute `defense` representing its physical defense.  
    - **Code Check**: `main_game/models.py` - `Creature` class defines `defense`.
    - **Status**: Correct

51. **Special Attack Attribute**: Creature has an attribute `sp_attack` representing its non-physical attack power.  
    - **Code Check**: `main_game/models.py` - `Creature` class defines `sp_attack`.
    - **Status**: Correct

52. **Special Defense Attribute**: Creature has an attribute `sp_defense` representing its non-physical defense.  
    - **Code Check**: `main_game/models.py` - `Creature` class defines `sp_defense`.
    - **Status**: Correct

53. **Speed Attribute**: Creature has an attribute `speed` representing its turn order priority.  
    - **Code Check**: `main_game/models.py` - `Creature` class defines `speed`.
    - **Status**: Correct

54. **Skills Attribute**: Creature has an attribute `skills` representing the skills it can use in battle.  
    - **Code Check**: `main_game/models.py` - `Creature` class defines `skills`.
    - **Status**: Correct

### Summary of Discrepancies
- **15. Random Order on Same Speed**: The code does not explicitly implement random order when creatures have the same speed.
- **32. Reset Creature State on Exit**: The code does not explicitly reset the state of the player's creatures when leaving the Main Game Scene.
__________________
Role: user
Content: if you think the code is correct, set qa_result to 'passed' otherwise set it to 'failed'. Set it to 'unknown' only when you really have no idea
__________________
Role: assistant
Content: ```json
{
  "qa_result": "failed",
  "explanation": "The code does not implement random order when creatures have the same speed, and it does not reset the state of the player's creatures when leaving the Main Game Scene."
}
```
__________________
