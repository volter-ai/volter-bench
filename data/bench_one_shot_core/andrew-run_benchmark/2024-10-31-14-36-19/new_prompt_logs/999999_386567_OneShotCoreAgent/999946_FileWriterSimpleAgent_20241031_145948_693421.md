Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for bringing this issue to my attention. I apologize for missing this detail in the initial implementation. Let's address this problem by modifying the MainGameScene to handle the case where both creatures have the same speed.

1. To fix this issue, we will:
   - Add a method to determine which creature goes first, taking into account the possibility of equal speeds.
   - Modify the _resolution_phase method to use this new method for determining the order of skill execution.
   - Use the random module to decide which creature goes first when their speeds are equal.

This solution aligns with the architecture documents and stays within the capabilities of the engine. It doesn't require any changes to the models, keeping them as pure data schemas.

2. Here's the rewritten main_game_scene.py file with the proposed solution:

# Excerpt ID: a326a9f4-ea0d-40a1-b90a-ba21d8b29530
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available skills:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appeared!")
        
        while True:
            # Player Choice Phase
            player_skill = self._player_choice_phase()
            
            # Foe Choice Phase
            foe_skill = self._foe_choice_phase()
            
            # Resolution Phase
            self._resolution_phase(player_skill, foe_skill)
            
            # Check for battle end
            if self._check_battle_end():
                self._handle_battle_end()
                break

    def _player_choice_phase(self):
        choices = [SelectThing(skill) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def _foe_choice_phase(self):
        choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def _determine_first_attacker(self):
        if self.player_creature.speed > self.opponent_creature.speed:
            return self.player_creature, self.opponent_creature
        elif self.opponent_creature.speed > self.player_creature.speed:
            return self.opponent_creature, self.player_creature
        else:
            # If speeds are equal, randomly choose who goes first
            creatures = [self.player_creature, self.opponent_creature]
            random.shuffle(creatures)
            return creatures[0], creatures[1]

    def _resolution_phase(self, player_skill, foe_skill):
        first_attacker, second_attacker = self._determine_first_attacker()
        
        if first_attacker == self.player_creature:
            first_skill, second_skill = player_skill, foe_skill
        else:
            first_skill, second_skill = foe_skill, player_skill

        self._execute_skill(first_attacker, second_attacker, first_skill)
        if second_attacker.hp > 0:
            self._execute_skill(second_attacker, first_attacker, second_skill)

    def _execute_skill(self, attacker: Creature, defender: Creature, skill: Skill):
        damage = max(0, attacker.attack + skill.base_damage - defender.defense)
        defender.hp = max(0, defender.hp - damage)
        self._show_text(self.player, f"{attacker.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender.display_name} took {damage} damage!")

    def _check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player_creature.display_name} fainted! You lose!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"{self.opponent_creature.display_name} fainted! You win!")
            return True
        return False

    def _handle_battle_end(self):
        play_again_button = Button("Play Again")
        quit_button = Button("Quit")
        choices = [play_again_button, quit_button]
        
        self._show_text(self.player, "Battle ended! What would you like to do?")
        choice = self._wait_for_choice(self.player, choices)

        if choice == play_again_button:
            self._transition_to_scene("MainMenuScene")
        elif choice == quit_button:
            self._quit_whole_game()
```

This updated version of the MainGameScene addresses the issue by:

1. Adding a new `_determine_first_attacker` method that handles the logic for deciding which creature attacks first, including the case where both creatures have the same speed.
2. Modifying the `_resolution_phase` method to use the `_determine_first_attacker` method, ensuring that the order of skill execution is correctly determined based on speed, with a random decision made when speeds are equal.

These changes align with the architecture documents and implement the missing functionality for handling equal speeds. The solution stays within the capabilities of the engine and doesn't require any changes to the models, maintaining them as pure data schemas.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "a326a9f4-ea0d-40a1-b90a-ba21d8b29530", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
