Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for bringing this issue to my attention. I apologize for missing this important detail in the initial implementation. Let's address this issue and implement the correct behavior as specified in the architecture documents.

1. Description of the fix:

To address the issue of not randomizing the order of skill execution when creatures have the same speed, we'll modify the `resolution_phase` method in the `MainGameScene` class. We'll introduce a check to compare the speeds of the player's creature and the opponent's creature. If they have the same speed, we'll use Python's `random.choice()` function to randomly determine which creature goes first.

This change will ensure that when creatures have equal speed, there's a 50% chance for either creature to act first, aligning with the specified architecture.

2. Rewritten file with the proposed solution:

# Excerpt ID: a840ffc2-7b74-4452-80dc-5af5804b9b49
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Player's turn:
> {self.player_creature.skills[0].display_name}
"""

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appears!")
        self.battle_loop()

    def battle_loop(self):
        while True:
            player_skill = self.player_choice_phase()
            opponent_skill = self.opponent_choice_phase()
            self.resolution_phase(player_skill, opponent_skill)

            if self.check_battle_end():
                self.end_battle()
                break

    def player_choice_phase(self):
        choices = [SelectThing(skill) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def opponent_choice_phase(self):
        choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def resolution_phase(self, player_skill, opponent_skill):
        if self.player_creature.speed > self.opponent_creature.speed:
            self.execute_skill(self.player, self.player_creature, player_skill, self.opponent_creature)
            if not self.check_battle_end():
                self.execute_skill(self.opponent, self.opponent_creature, opponent_skill, self.player_creature)
        elif self.player_creature.speed < self.opponent_creature.speed:
            self.execute_skill(self.opponent, self.opponent_creature, opponent_skill, self.player_creature)
            if not self.check_battle_end():
                self.execute_skill(self.player, self.player_creature, player_skill, self.opponent_creature)
        else:
            # If speeds are equal, randomly choose who goes first
            if random.choice([True, False]):
                self.execute_skill(self.player, self.player_creature, player_skill, self.opponent_creature)
                if not self.check_battle_end():
                    self.execute_skill(self.opponent, self.opponent_creature, opponent_skill, self.player_creature)
            else:
                self.execute_skill(self.opponent, self.opponent_creature, opponent_skill, self.player_creature)
                if not self.check_battle_end():
                    self.execute_skill(self.player, self.player_creature, player_skill, self.opponent_creature)

    def execute_skill(self, attacker, attacker_creature, skill, defender_creature):
        damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        defender_creature.hp = max(0, defender_creature.hp - damage)
        self._show_text(self.player, f"{attacker.display_name}'s {attacker_creature.display_name} uses {skill.display_name}!")
        self._show_text(self.player, f"{defender_creature.display_name} takes {damage} damage!")

    def check_battle_end(self):
        return self.player_creature.hp <= 0 or self.opponent_creature.hp <= 0

    def end_battle(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name}'s {self.player_creature.display_name} fainted! You lose!")
        else:
            self._show_text(self.player, f"{self.opponent.display_name}'s {self.opponent_creature.display_name} fainted! You win!")
        
        self._show_text(self.player, "Returning to main menu...")
        self._transition_to_scene("MainMenuScene")
```

This updated implementation now correctly handles the case where creatures have equal speed by randomly determining which creature acts first. This aligns with the specified architecture and ensures fairness in the gameplay when speed values are equal.

The rest of the implementation remains unchanged, maintaining the existing model structure and adhering to the engine's capabilities. This solution should resolve the issue raised during QA/testing while keeping the overall structure and functionality of the game intact.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "a840ffc2-7b74-4452-80dc-5af5804b9b49", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
