Role: system
Content: 
__________________
Role: user
Content: You are a professional programmer and code reviewer. Your task is to review a piece of code and determine whether it correctly implements the described architecture and logic of a game. Here are the files you need to consider:

```markdown main_game/docs/overview.md
# Overview

This is the overview document for a creature battler game. In this game, the player assembles a team of creatures to fight against another player's team of creatures to see who can reduce their opponent's health to zero first.

## Game Scenes

- **MainMenuScene** - This is the starting scene and where the player can choose to play or quit.
- **MainGameScene** - This is the scene where the action takes place. Here, the player does battle against a bot opponent.

## Game Entities

- **Player** - A thing that represents a human or bot within the game, and is controlled by the human or bot.
- **Creature** - A thing that does battle within the game. **Player**s manage a team of creatures in battle.
- **Skill** - A thing that represents the actions that the **Creature**s are able to take in battle.
```

```markdown main_game/docs/scenes/main_menu_scene.md
# MainMenuScene

The Main Menu scene allows the player to play the game or quit.

## Scene Logic

At the start of the scene, the player is shown a welcome message and the scene then prompts the player to play or quit. 
- One choice that will take the player to the **MainGameScene**.
- One choice that quits the game entirely.

```

```markdown main_game/docs/scenes/main_game_scene.md
# MainGameScene

The Main Game Scene is where the human player does battle against a bot player using their teams of creatures. This is a scene that can be played by one player, but should be treated like a symmetric multiplayer scene.

## Scene Logic

The scene plays through repeating turns with distinct phases. Turns consist of:
- Player Choice Phase
- Foe Choice Phase
- Resolution Phase

### Player Choice Phase

During the player choice phase, the player is shown their creature's list of available skills. The player is able to choose one of those skills and that is queued for the resolution phase.

### Foe Choice Phase

During the foe choice phase, the opposing player is shown their own creature's list of available skills and chooses one from that list. This skill is also queued for the resolution phase.

### Resolution Phase

During the resolution phase, the skills that were queued in the previous two steps are resolved. 

The order in which the skills are executed depends on the speed of the creature using the skill. The creature that has the higher speed stat executes their skill first. If the creatures have the same speed, then which creature goes first is decided randomly, with either creature having equal chance of being picked to go first.

#### Skill Execution

When executing a skill, the damage dealt is calculated in two passes. First, a raw damage value is calculated as the skill's base damage plus the attacker's attack minus the defender's defense. In other words:
```
[raw damage] = [attacker attack] + [skill base damage] - [defender defense]
```

The final damage is then calculated by taking the raw damage and multiplying it by a weakness-resistance factor depending on the matchup of the skill type against the defender's creature type:
```
[final damage] = [weakness-resistance factor] * [raw damage]
```

All the damage formulas should be performed with floats, and then converted to an integer as the final damage. The final damage value is subtracted from the defender's hp. 

#### Type Relationships

When calculating the damage dealt by a skill, a weakness-resistance factor needs to be found by comparing the skill type against the defender's creature type. 
- If a skill type is effective against a creature type, the factor is 2 (the skill does double damage). 
- If a skill type is ineffective  against a creature type, the factor is 1/2 (the skill does half damage).

The following are the relationships between the handful of types in the game:
- "Normal" | Is neither effective nor ineffective against any other types.
- "Fire" | Effective against Leaf | Ineffective against Water
- "Water" | Effective against Fire | Ineffective against Leaf
- "Leaf" | Effective against Water | Ineffective against Fire

### Battle End Condition

At any point when one creature's hp reaches zero, the battle ends. At that point, a message is shown informing the player whether they have won or lost depending on which creature was knocked out.
- If the player's creature was defeated, then they are informed that they are the loser.
- If the opponent's creature's hp is reduced to zero, then the player is informed that they are the winner.
```

```markdown main_game/docs/models/player.md
# Player

The Player is an entity in the game "Creature Battle" that is controlled by a human or a bot. 

## Additional Attributes

- `creatures` - The collection of creatures that the player has at their disposal. 
```

```markdown main_game/docs/models/skill.md
# Skill

Skill represents actions that creatures can take in battle.

## Additional Attributes

- `skill_type` - A string representing the elemental affinity of the skill. This is used in deciding whether the skill is effective or ineffective against a target.
- `base_damage` - An integer representing the damage that is dealt to a foe when the skill is executed.
```

```markdown main_game/docs/models/creature.md
# Creature

Creature is an entity in the creature battler game that participates in battles.

## Additional Attributes

- `creature_type` - A string representing the creature's elemental affinity. This decides the creature's weaknesses and resistances.
- `hp` - An integer representing the number of health points the creature has. The creature is knocked out when this number reaches zero.
- `max_hp` - An integer representing the maximum number of health points a creature can have.
- `attack` - An integer representing the added power behind the creature's attacks.
- `defense` - An integer representing the creature's resistance to damage against attacks.
- `speed` - An integer representing the creature's priority when deciding turn order.
- `skills` - A collection of the skills that the creature has access to in battle.
```

```markdown main_game/docs/feature_requests/02_creature_prototypes.md
# Creature Prototypes

This is a document describing the different creatures that exist in the game. Prototypes are the base instances of the thing.

## Prototypes

- "Bubwool" | "water" type | 10 hp | 3 attack | 2 defense | 4 speed | Skills: ["Tackle", "Lick"]
- "Scizard" | "fire" type | 11 hp | 3 attack | 3 defense | 3 speed | Skills: ["Tackle", "Fireball"]
```

```markdown main_game/docs/feature_requests/03_player_prototypes.md
# Player Prototypes

This is a document describing the different players that exist in the game. Prototypes are the base instances of the thing.

## Prototypes

- "Default Player" | Has a bubwool
- "Basic Opponent" | Has a scizard

```

```markdown main_game/docs/feature_requests/01_skill_prototypes.md
# Skill Prototypes

This is a document describing the different skills that exist in the game. Prototypes are the base instances of the thing.

## Prototypes

- "Tackle" | "normal" type | 3 damage | "Throw yourself at a foe, dealing damage."
- "Fireball" | "fire" type | 2 damage | "Throw fire at a foe, dealing damage."
- "Lick" | "water" type | 2 damage | "Lick a foe with a wet tongue, dealing damage."
```

First create an exhaustive checklist that covers all the logic and functionality from the architecture docs above. This should be in the format of an acceptance criteria. Don't include anything in the checklist which is not explicitly written in the architecture doc. Each checklist should have a 'citation' of the line of the arch doc it refers to
__________________
Role: assistant
Content: Certainly! Below is an exhaustive checklist in the format of acceptance criteria, based on the architecture and logic described in the provided documentation. Each item includes a citation to the relevant part of the documentation.

### MainMenuScene

- [ ] The Main Menu scene displays a welcome message to the player.  
  *Citation: `main_game/docs/scenes/main_menu_scene.md` - "At the start of the scene, the player is shown a welcome message..."*
- [ ] The Main Menu scene provides an option for the player to start the game, which transitions to the MainGameScene.  
  *Citation: `main_game/docs/scenes/main_menu_scene.md` - "One choice that will take the player to the MainGameScene."*
- [ ] The Main Menu scene provides an option for the player to quit the game.  
  *Citation: `main_game/docs/scenes/main_menu_scene.md` - "One choice that quits the game entirely."*

### MainGameScene

- [ ] The Main Game Scene allows a human player to battle against a bot player.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "The Main Game Scene is where the human player does battle against a bot player..."*
- [ ] The game consists of repeating turns with the phases: Player Choice Phase, Foe Choice Phase, and Resolution Phase.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "The scene plays through repeating turns with distinct phases..."*

#### Player Choice Phase

- [ ] During the Player Choice Phase, the player is shown their creature's list of available skills.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "During the player choice phase, the player is shown their creature's list of available skills..."*
- [ ] The player can choose one skill, which is queued for the resolution phase.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "...The player is able to choose one of those skills and that is queued for the resolution phase."*

#### Foe Choice Phase

- [ ] During the Foe Choice Phase, the bot player is shown their creature's list of available skills.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "During the foe choice phase, the opposing player is shown their own creature's list of available skills..."*
- [ ] The bot player chooses one skill, which is queued for the resolution phase.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "...and chooses one from that list. This skill is also queued for the resolution phase."*

#### Resolution Phase

- [ ] Skills queued in the Player and Foe Choice Phases are resolved in the Resolution Phase.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "During the resolution phase, the skills that were queued in the previous two steps are resolved."*
- [ ] Skills are executed based on the speed of the creature using the skill.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "The order in which the skills are executed depends on the speed of the creature using the skill."*
- [ ] If creatures have the same speed, the order is decided randomly with equal probability.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "If the creatures have the same speed, then which creature goes first is decided randomly..."*

##### Skill Execution

- [ ] Raw damage is calculated as the skill's base damage plus the attacker's attack minus the defender's defense.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "First, a raw damage value is calculated as the skill's base damage plus the attacker's attack minus the defender's defense."*
- [ ] Final damage is calculated by multiplying raw damage by a weakness-resistance factor.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "The final damage is then calculated by taking the raw damage and multiplying it by a weakness-resistance factor..."*
- [ ] All damage calculations are performed with floats and converted to an integer for final damage.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "All the damage formulas should be performed with floats, and then converted to an integer as the final damage."*
- [ ] Final damage is subtracted from the defender's hp.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "The final damage value is subtracted from the defender's hp."*

##### Type Relationships

- [ ] A skill type effective against a creature type has a factor of 2.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "If a skill type is effective against a creature type, the factor is 2..."*
- [ ] A skill type ineffective against a creature type has a factor of 1/2.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "If a skill type is ineffective against a creature type, the factor is 1/2..."*
- [ ] "Normal" type skills are neither effective nor ineffective against any types.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "Normal | Is neither effective nor ineffective against any other types."*
- [ ] "Fire" type skills are effective against "Leaf" and ineffective against "Water".  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "Fire | Effective against Leaf | Ineffective against Water"*
- [ ] "Water" type skills are effective against "Fire" and ineffective against "Leaf".  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "Water | Effective against Fire | Ineffective against Leaf"*
- [ ] "Leaf" type skills are effective against "Water" and ineffective against "Fire".  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "Leaf | Effective against Water | Ineffective against Fire"*

### Battle End Condition

- [ ] The battle ends when a creature's hp reaches zero.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "At any point when one creature's hp reaches zero, the battle ends."*
- [ ] A message is shown indicating whether the player has won or lost.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "...a message is shown informing the player whether they have won or lost..."*
- [ ] If the player's creature is defeated, they are informed they are the loser.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "If the player's creature was defeated, then they are informed that they are the loser."*
- [ ] If the opponent's creature is defeated, the player is informed they are the winner.  
  *Citation: `main_game/docs/scenes/main_game_scene.md` - "If the opponent's creature's hp is reduced to zero, then the player is informed that they are the winner."*

### Game Entities

#### Player

- [ ] A Player represents a human or bot within the game.  
  *Citation: `main_game/docs/models/player.md` - "The Player is an entity in the game 'Creature Battle' that is controlled by a human or a bot."*
- [ ] A Player has a collection of creatures at their disposal.  
  *Citation: `main_game/docs/models/player.md` - "`creatures` - The collection of creatures that the player has at their disposal."*

#### Creature

- [ ] A Creature has a `creature_type` attribute representing its elemental affinity.  
  *Citation: `main_game/docs/models/creature.md` - "`creature_type` - A string representing the creature's elemental affinity."*
- [ ] A Creature has an `hp` attribute representing its health points.  
  *Citation: `main_game/docs/models/creature.md` - "`hp` - An integer representing the number of health points the creature has."*
- [ ] A Creature has a `max_hp` attribute representing its maximum health points.  
  *Citation: `main_game/docs/models/creature.md` - "`max_hp` - An integer representing the maximum number of health points a creature can have."*
- [ ] A Creature has an `attack` attribute representing its attack power.  
  *Citation: `main_game/docs/models/creature.md` - "`attack` - An integer representing the added power behind the creature's attacks."*
- [ ] A Creature has a `defense` attribute representing its resistance to damage.  
  *Citation: `main_game/docs/models/creature.md` - "`defense` - An integer representing the creature's resistance to damage against attacks."*
- [ ] A Creature has a `speed` attribute representing its priority in turn order.  
  *Citation: `main_game/docs/models/creature.md` - "`speed` - An integer representing the creature's priority when deciding turn order."*
- [ ] A Creature has a `skills` attribute representing the skills it can use in battle.  
  *Citation: `main_game/docs/models/creature.md` - "`skills` - A collection of the skills that the creature has access to in battle."*

#### Skill

- [ ] A Skill has a `skill_type` attribute representing its elemental affinity.  
  *Citation: `main_game/docs/models/skill.md` - "`skill_type` - A string representing the elemental affinity of the skill."*
- [ ] A Skill has a `base_damage` attribute representing the damage it deals.  
  *Citation: `main_game/docs/models/skill.md` - "`base_damage` - An integer representing the damage that is dealt to a foe when the skill is executed."*

### Prototypes

#### Creature Prototypes

- [ ] "Bubwool" is a "water" type creature with 10 hp, 3 attack, 2 defense, 4 speed, and skills ["Tackle", "Lick"].  
  *Citation: `main_game/docs/feature_requests/02_creature_prototypes.md` - "Bubwool | water type | 10 hp | 3 attack | 2 defense | 4 speed | Skills: ['Tackle', 'Lick']"*
- [ ] "Scizard" is a "fire" type creature with 11 hp, 3 attack, 3 defense, 3 speed, and skills ["Tackle", "Fireball"].  
  *Citation: `main_game/docs/feature_requests/02_creature_prototypes.md` - "Scizard | fire type | 11 hp | 3 attack | 3 defense | 3 speed | Skills: ['Tackle', 'Fireball']"*

#### Player Prototypes

- [ ] "Default Player" has a Bubwool.  
  *Citation: `main_game/docs/feature_requests/03_player_prototypes.md` - "Default Player | Has a bubwool"*
- [ ] "Basic Opponent" has a Scizard.  
  *Citation: `main_game/docs/feature_requests/03_player_prototypes.md` - "Basic Opponent | Has a scizard"*

#### Skill Prototypes

- [ ] "Tackle" is a "normal" type skill with 3 damage.  
  *Citation: `main_game/docs/feature_requests/01_skill_prototypes.md` - "Tackle | normal type | 3 damage"*
- [ ] "Fireball" is a "fire" type skill with 2 damage.  
  *Citation: `main_game/docs/feature_requests/01_skill_prototypes.md` - "Fireball | fire type | 2 damage"*
- [ ] "Lick" is a "water" type skill with 2 damage.  
  *Citation: `main_game/docs/feature_requests/01_skill_prototypes.md` - "Lick | water type | 2 damage"*

This checklist should cover all the logic and functionality described in the architecture documentation.
__________________
Role: user
Content: Game engine:
```python engine/lib.py
def make_uuid():
    return str(uuid.uuid4())




class AbstractGameEntity(BaseModel, ABC):  # external
    uid: str = Field(default_factory=make_uuid)  # external
    display_name: str  # external
    description: str = ""  # external
    prototype_id: str  # external




TAbstractThing = TypeVar('TAbstractThing', bound='AbstractThing')


class AbstractThing(AbstractGameEntity, ABC):
    prototype_id: str



    @classmethod
    def get_data(cls):
        file_path = os.path.join("main_game/content", f"{cls.__name__.lower()}.json")
        with open(file_path) as data:
            return json.load(data)

    @classmethod
    def get_ids(cls):
        return list(cls.get_data().get("prototypes").keys())

    def __hash__(self):
        raise FixableException(
            "Attempt detected to use an AbstractThing as a hashable ID.  Instead, you should use [obj].prototype_id")


    @classmethod
    def from_prototype_id(cls: Type[TAbstractThing], prototype_id: str) -> TAbstractThing:
        """ During deserialization, any field which contains prototype_id will be automatically deserialized directly as the object.
        so in the json, all models should be written as a str of their prototype_id but in Python, they must be objects
        """
        try:
            data = cls.get_data().get("prototypes")[prototype_id]
            data["prototype_id"] = prototype_id
            data["category"] = cls.__name__
        except KeyError as e:
            raise Exception(
                f'The JSON file corresponding to the {cls.__name__} model does not have a prototype entry called: "{prototype_id}"') from e
        return cls._create_from_data(data)


    @classmethod
    def to_instantiated_list(cls) -> List[TAbstractThing]:
        return [cls.from_prototype_id(t_id) for t_id in cls.get_ids()]

    @classmethod

    @staticmethod
    def _process_value(annotation, value):
        origin = get_origin(annotation)
        if origin is list:
            item_type = get_args(annotation)[0]
            if issubclass(item_type, AbstractThing):
                return [item_type.from_prototype_id(item_prototype_id) for item_prototype_id in value]
        elif isinstance(annotation, type) and issubclass(annotation, AbstractThing):
            return annotation.from_prototype_id(value)
        return value




class AbstractChoice(ABC, BaseModel):
    id: str = Field(default_factory=make_uuid)


class Button(AbstractChoice):
    display_name: str = ""
    slug: str = ""

    def __init__(self, display_name: str):
        super().__init__(display_name=display_name)

    def __repr__(self):
        return f"Button({self.display_name})"


class SelectThing(AbstractChoice):
    select_action_type: str = "SelectThing"
    thing: "AbstractThing"
    label: Optional[str] = ""

    def __init__(self, thing: "AbstractThing", **kwargs):
        assert issubclass(thing.__class__, AbstractThing), (
            f"SelectThing can only be constructed with a Thing, not '{thing}'")
        super().__init__(thing=thing, **kwargs)

    def __repr__(self):
        return f"{self.select_action_type}({self.thing.__class__.__name__}({self.thing.prototype_id}))"


class AbstractPlayerListener(ABC):
    player: "AbstractPlayer" = None

    @abstractmethod
    def on_wait_for_choice(self, scene: "AbstractGameScene", choices: List[AbstractChoice]) -> AbstractChoice:
        pass

    @abstractmethod
    def on_show_event(self, event_type: str, event_data: Dict[str, Any]):
        pass

    @abstractmethod
    def on_go_to_single_player_scene(self, app: "AbstractApp", scene_name: str):
        pass

    @abstractmethod
    def on_show_scene(self, scene_name: str, view_data: Dict[str, Any]):
        pass


class GracefulExit(Exception):
    pass


class RandomModeGracefulExit(GracefulExit):
    def __init__(self):
        super().__init__(
            "HumanListener is in random mode and the current run is now over. This is exception is expected")


class HumanListener(AbstractPlayerListener):
    random_mode: bool = False
    random_mode_counter: int = 100  # number of moves to make in random mode

    def on_wait_for_choice(self, scene: "AbstractGameScene", choices: List[AbstractChoice]) -> AbstractChoice:
        if HumanListener.random_mode or self.random_mode:
            assert str(scene)
            self.random_mode_counter -= 1
            if self.random_mode_counter <= 0:
                raise RandomModeGracefulExit()
            return random.choice(choices)

        for i, choice in enumerate(choices):
            print(f"{i + 1}: {choice}")
        while True:
            try:
                choice_idx = int(input(f"Enter your choice: "))
                return choices[choice_idx - 1]
            except (IndexError, ValueError):
                continue

    def on_show_event(self, event_type: str, event_data: Dict[str, Any]):
        if event_type == "show_text":
            print(event_data.get('text'))
        else:
            print(f"{event_type}: {event_data}")

    def on_show_scene(self, scene_name: str, view_data: Dict[str, Any]):
        pass

    def on_go_to_single_player_scene(self, app: "AbstractApp", scene_id: str):
        app.transition_to_scene(scene_id, player=self.player)


class BotListener(AbstractPlayerListener):
    def on_wait_for_choice(self, scene: "AbstractGameScene", choices: List[AbstractChoice]) -> AbstractChoice:
        return random.choice(choices)

    def on_show_event(self, event_type: str, event_data: Dict[str, Any]):
        print(f"BotListener:on_show_event:{event_type}: {event_data}")
        # Bot doesn't need to print events, but we'll keep this method for consistency
        pass

    def on_show_scene(self, scene_name: str, view_data: Dict[str, Any]):
        # Bot doesn't need to print scene view data
        pass

    def on_go_to_single_player_scene(self, app: "AbstractApp", scene_name: str):
        print(f"bot {BotListener.player.display_name} is going to bot heaven")


class AbstractPlayer(AbstractThing, ABC):
    _listener: AbstractPlayerListener = None


    def set_listener(self, listener: AbstractPlayerListener):
        self._listener = listener
        self._listener.player = self

    def __repr__(self):
        return self.display_name


T = TypeVar('T', bound=AbstractPlayer)


class AbstractGameScene(AbstractGameEntity, Generic[T]):
    _app: "AbstractApp" = None
    player: AbstractPlayer = None

    def __init__(self, app: "AbstractApp", player: AbstractPlayer):
        super().__init__(display_name=self.__class__.__name__, prototype_id=self.__class__.__name__, player=player)
        self._app = app
        self.player = player

    @abstractmethod
    def __str__(self):
        """A user should be able to look at this str and see all the information they need to navigate the scene"""
        pass

    @abstractmethod
    def run(self):
        pass

    def _wait_for_choice(self, player: AbstractPlayer, choices: List[AbstractChoice]) -> AbstractChoice:
        assert len(choices) > 0, "`_wait_for_choice` was called with no choices"

        # print(f"{self.__class__.__name__}:_wait_for_choice({player.display_name}, {str(choices)})")
        choice = player._listener.on_wait_for_choice(self, choices)
        # print(f"{self.__class__.__name__}:_wait_for_choice received choice {str(choice)}")
        return choice

    def _show_text(self, player: AbstractPlayer, text: str):
        """ this shows text as a popup """
        player._listener.on_show_event("show_text", {"text": text})

    def _quit_whole_game(self):
        self._app.quit_whole_game()

    def _transition_to_scene(self, scene_name: str):
        self._app.transition_to_scene(scene_name, player=self.player)






TGameScene = TypeVar('TGameScene', bound=AbstractGameScene)




class AbstractApp(ABC):
    class _QuitWholeGame(GracefulExit):
        def __init__(self,
                     message: str = "Game terminated gracefully. If you intended to quit the game, this exception is expected and should be caught"):
            super().__init__(message)

    scene_registry: Dict[str, Type[TGameScene]]
    entry_point_scene_id: str
    matchmaking_wait_time = 0
    terminated: bool = False


    def __init__(self):
        self.scene_registry = {}

    def register_scene(self, scene_id: str, scene_factory: Type[TGameScene], is_entry_point: bool = False):
        self.scene_registry[scene_id] = scene_factory
        if is_entry_point:
            assert not issubclass(scene_factory, AbstractMultiplayerScene), "Cannot start with multiplayer scene"
            self.entry_point_scene_id = scene_id

    def quit_whole_game(self):
        self.terminated = True
        raise AbstractApp._QuitWholeGame()

    def run(self, player: AbstractPlayer):
        try:
            self.transition_to_scene(self.entry_point_scene_id, player=player)
        except AbstractApp._QuitWholeGame:
            AbstractApp.broadcast_event(OnGameEnd())
            print("game exited gracefully")



    def go_to_lobby(self, scene_factory, player: AbstractPlayer):
        self.__run_scene(
            LobbyScene(self, player, scene_target=scene_factory, matchmaking_wait_time=self.matchmaking_wait_time))


        # TODO: allow kwargs


    def transition_to_scene(self, scene_id: str, **kwargs):
        scene_factory = self.scene_registry[scene_id]
        scene = scene_factory(app=self, **kwargs)
        self.__run_scene(scene)




    def __run_scene(self, scene: AbstractGameScene):
        if len(self._scene_stack) == 1:
            AbstractApp.broadcast_event(OnGameStart())

        self._show_changes()

        scene.run()



    @abstractmethod
    def create_player(self, player_id: str) -> AbstractPlayer:
        pass

    @abstractmethod
    def create_bot(self, prototype_id: str) -> AbstractPlayer:
        pass
















































AT = TypeVar('AT', bound='AbstractThing')
def create_from_game_database(game_thing_prototype_id: str, game_thing_class: type[AT]) -> AT:
    """Takes in a prototype_id and uses the content JSON files to bootstrap a hydrated game entity
    For example, `create_from_game_database("some_id_from_some_data_json", SomeGameThing)`
    """
    return game_thing_class.from_prototype_id(game_thing_prototype_id)
```

Game codebase:
```python main_game/models.py
from __future__ import annotations
from mini_game_engine.engine.lib import AbstractThing, AbstractPlayer
from typing import List


class Skill(AbstractThing):
    category: str = "Skill"
    skill_type: str
    base_damage: int

class Creature(AbstractThing):
    category: str = "Creature"
    creature_type: str
    hp: int
    max_hp: int
    attack: int
    defense: int
    speed: int
    skills: List[Skill]

class Player(AbstractPlayer):
    category: str = "Player"
    creatures: List[Creature]

```

```python main_game/main.py
import uuid
from mini_game_engine.engine.lib import AbstractApp, HumanListener, BotListener
from main_game.models import Player
from main_game.scenes.main_menu_scene import MainMenuScene
from main_game.scenes.main_game_scene import MainGameScene


class App(AbstractApp):
    def __init__(self):
        super().__init__()
        self.register_scene("MainMenuScene", MainMenuScene, is_entry_point=True)
        self.register_scene("MainGameScene", MainGameScene)

    def create_player(self, player_id: str):
        player = Player.from_prototype_id(prototype_id="default_player")
        player.uid = player_id
        player.set_listener(HumanListener())
        return player

    def create_bot(self, prototype_id: str):
        bot = Player.from_prototype_id(prototype_id=prototype_id)
        bot.uid = str(uuid.uuid4())
        bot.set_listener(BotListener())
        return bot

if __name__ == '__main__':
    app = App()
    app.run(app.create_player("just_a_guy"))

```

```json main_game/content/player.json
{
  "prototypes": {
    "default_player": {
      "display_name": "Default Player",
      "description": "A player with a Bubwool",
      "creatures": ["bubwool"]
    },
    "basic_opponent": {
      "display_name": "Basic Opponent",
      "description": "An opponent with a Scizard",
      "creatures": ["scizard"]
    }
  }
}

```

```json main_game/content/skill.json
{
  "prototypes": {
    "tackle": {
      "display_name": "Tackle",
      "description": "Throw yourself at a foe, dealing damage.",
      "skill_type": "normal",
      "base_damage": 3
    },
    "fireball": {
      "display_name": "Fireball",
      "description": "Throw fire at a foe, dealing damage.",
      "skill_type": "fire",
      "base_damage": 2
    },
    "lick": {
      "display_name": "Lick",
      "description": "Lick a foe with a wet tongue, dealing damage.",
      "skill_type": "water",
      "base_damage": 2
    }
  }
}

```

```json main_game/content/creature.json
{
  "prototypes": {
    "bubwool": {
      "display_name": "Bubwool",
      "description": "A water-type creature",
      "creature_type": "water",
      "hp": 10,
      "max_hp": 10,
      "attack": 3,
      "defense": 2,
      "speed": 4,
      "skills": ["tackle", "lick"]
    },
    "scizard": {
      "display_name": "Scizard",
      "description": "A fire-type creature",
      "creature_type": "fire",
      "hp": 11,
      "max_hp": 11,
      "attack": 3,
      "defense": 3,
      "speed": 3,
      "skills": ["tackle", "fireball"]
    }
  }
}

```

```python main_game/scenes/main_menu_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button


class MainMenuScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)

    def __str__(self):
        return """===Main Menu===
Welcome to Creature Battler!

> Play
> Quit
"""

    def run(self):
        while True:
            play_button = Button("Play")
            quit_button = Button("Quit")
            choices = [play_button, quit_button]
            choice = self._wait_for_choice(self.player, choices)

            if play_button == choice:
                self._transition_to_scene("MainGameScene")
            elif quit_button == choice:
                self._quit_whole_game()

```

```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Creature, Skill
import random


class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

> Use Skill
> Back to Main Menu
"""

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appeared!")
        while True:
            choices = [
                Button("Use Skill"),
                Button("Back to Main Menu")
            ]
            choice = self._wait_for_choice(self.player, choices)

            if choice.display_name == "Use Skill":
                if self.player_turn():
                    if self.check_battle_end():
                        break
                if self.opponent_turn():
                    if self.check_battle_end():
                        break
            elif choice.display_name == "Back to Main Menu":
                self._transition_to_scene("MainMenuScene")
                return

    def player_turn(self):
        self._show_text(self.player, f"It's your turn! Choose a skill:")
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return self.execute_skill(self.player_creature, self.opponent_creature, choice.thing)

    def opponent_turn(self):
        opponent_skill = random.choice(self.opponent_creature.skills)
        self._show_text(self.player, f"{self.opponent_creature.display_name} uses {opponent_skill.display_name}!")
        return self.execute_skill(self.opponent_creature, self.player_creature, opponent_skill)

    def execute_skill(self, attacker: Creature, defender: Creature, skill: Skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        weakness_factor = self.calculate_weakness_factor(skill.skill_type, defender.creature_type)
        final_damage = int(weakness_factor * raw_damage)
        defender.hp = max(0, defender.hp - final_damage)
        self._show_text(self.player, f"{defender.display_name} took {final_damage} damage!")
        return defender.hp == 0

    def calculate_weakness_factor(self, skill_type: str, defender_type: str):
        if skill_type == defender_type:
            return 1
        elif (skill_type == "fire" and defender_type == "leaf") or \
             (skill_type == "water" and defender_type == "fire") or \
             (skill_type == "leaf" and defender_type == "water"):
            return 2
        elif (skill_type == "fire" and defender_type == "water") or \
             (skill_type == "water" and defender_type == "leaf") or \
             (skill_type == "leaf" and defender_type == "fire"):
            return 0.5
        else:
            return 1

    def check_battle_end(self):
        if self.player_creature.hp == 0:
            self._show_text(self.player, f"Your {self.player_creature.display_name} fainted! You lose!")
            self.end_battle()
            return True
        elif self.opponent_creature.hp == 0:
            self._show_text(self.player, f"The opponent's {self.opponent_creature.display_name} fainted! You win!")
            self.end_battle()
            return True
        return False

    def end_battle(self):
        choices = [Button("Back to Main Menu")]
        choice = self._wait_for_choice(self.player, choices)
        self._transition_to_scene("MainMenuScene")

```

```python main_game/tests/test_main_game_scene.py
import pytest
from unittest.mock import patch
from mini_game_engine.engine.lib import HumanListener, RandomModeGracefulExit
from main_game.main import App
from main_game.scenes.main_game_scene import MainGameScene


class TestMainGameSceneRandomRun:
    @pytest.fixture
    def app(self):
        return App()

    def test_main_game_scene_random_run(self, app):
        for i in range(10):
            print(f"starting random run iteration {i}")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 30  # Increased to 30 for more complex scene

            player = app.create_player(f"player_{i}")
            main_game_scene = MainGameScene(app, player)

            class TransitionFromScene(Exception):
                pass

            def exit_scene(*args, **kwargs):
                raise TransitionFromScene()

            with patch.object(MainGameScene, '_transition_to_scene', side_effect=exit_scene) as mock_transition, \
                    patch.object(MainGameScene, '_quit_whole_game') as mock_quit:

                try:
                    main_game_scene.run()
                except TransitionFromScene:
                    print(f"exiting target scene `MainGameScene` so ending run {i}")
                except RandomModeGracefulExit:
                    print(f"`random_mode_counter` reached 0 and the game did not crash. Ending run {i} gracefully")
                else:
                    assert mock_transition.called or mock_quit.called, "scene was not exited in an expected manner"

                    if mock_quit.called:
                        print("_quit_whole_game called")
                    if mock_transition.called:
                        print("_transition_to_scene called")
                finally:
                    mock_transition.reset_mock()
                    mock_quit.reset_mock()

```

```python main_game/tests/test_main_menu_scene.py
import pytest
from unittest.mock import patch
from mini_game_engine.engine.lib import HumanListener, RandomModeGracefulExit
from main_game.main import App
from main_game.scenes.main_menu_scene import MainMenuScene


class TestMainMenuSceneRandomRun:
    @pytest.fixture
    def app(self):
        return App()

    def test_main_menu_scene_random_run(self, app):
        for i in range(10):
            print(f"starting random run iteration {i}")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 10

            player = app.create_player(f"player_{i}")
            main_menu_scene = MainMenuScene(app, player)

            class TransitionFromScene(Exception):
                pass

            def exit_scene(*args, **kwargs):
                raise TransitionFromScene()

            with patch.object(MainMenuScene, '_transition_to_scene', side_effect=exit_scene) as mock_transition, \
                    patch.object(MainMenuScene, '_quit_whole_game') as mock_quit:

                try:
                    main_menu_scene.run()
                except TransitionFromScene:
                    print(f"exiting target scene `MainMenuScene` so ending run {i}")
                except RandomModeGracefulExit:
                    print(f"`random_mode_counter` reached 0 and the game did not crash. Ending run {i} gracefully")
                else:
                    assert mock_transition.called or mock_quit.called, "scene was not exited in an expected manner"

                    if mock_quit.called:
                        print("_quit_whole_game called")
                    if mock_transition.called:
                        print("_transition_to_scene called")
                finally:
                    mock_transition.reset_mock()
                    mock_quit.reset_mock()

```

```python main_game/tests/test_whole_game.py
import os
import sys

from mini_game_engine.engine.lib import HumanListener, RandomModeGracefulExit
from main_game.main import App


def test_full_game_flow_random_with_bots():
    for i in range(10):
        print(f"starting random run iteration {i}")
        HumanListener.random_mode = True
        HumanListener.random_mode_counter = 100  # 100 moves suffice for running through some common scenarios in the game
        App.matchmaking_wait_time = 0
        original_wait_time = App.matchmaking_wait_time

        app = App()

        # Create a human player
        human_player = app.create_player("HumanPlayer")
        human_player.set_listener(HumanListener())

        try:
            app.run(human_player)
        except RandomModeGracefulExit as e:
            # exited gracefully
            pass
        finally:
            App.matchmaking_wait_time = original_wait_time


```



Now check each of the checklist items against the code. Note any discrepancies, missing elements, or extra implementations that don't align with the described architecture.



Guidelines:

1. Only check the behavior which is explicitly described in the markdown files

2. Assume the engine module is correct, the only mistakes you should note should be in the `main_game` folder
__________________
Role: assistant
Content: Let's go through the checklist and verify each item against the provided code in the `main_game` folder. I'll note any discrepancies, missing elements, or extra implementations that don't align with the described architecture.

### MainMenuScene

- [x] The Main Menu scene displays a welcome message to the player.
  - **Code Check**: The `__str__` method in `MainMenuScene` displays a welcome message. (File: `main_game/scenes/main_menu_scene.py`)
  
- [x] The Main Menu scene provides an option for the player to start the game, which transitions to the MainGameScene.
  - **Code Check**: The `run` method in `MainMenuScene` includes a "Play" button that transitions to `MainGameScene`. (File: `main_game/scenes/main_menu_scene.py`)
  
- [x] The Main Menu scene provides an option for the player to quit the game.
  - **Code Check**: The `run` method in `MainMenuScene` includes a "Quit" button that calls `_quit_whole_game`. (File: `main_game/scenes/main_menu_scene.py`)

### MainGameScene

- [x] The Main Game Scene allows a human player to battle against a bot player.
  - **Code Check**: The `MainGameScene` initializes with a human player and a bot opponent. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] The game consists of repeating turns with the phases: Player Choice Phase, Foe Choice Phase, and Resolution Phase.
  - **Code Check**: The `run` method in `MainGameScene` implements a loop with player and opponent turns. (File: `main_game/scenes/main_game_scene.py`)

#### Player Choice Phase

- [x] During the Player Choice Phase, the player is shown their creature's list of available skills.
  - **Code Check**: The `player_turn` method displays the player's skills. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] The player can choose one skill, which is queued for the resolution phase.
  - **Code Check**: The `player_turn` method allows the player to choose a skill, which is then executed. (File: `main_game/scenes/main_game_scene.py`)

#### Foe Choice Phase

- [x] During the Foe Choice Phase, the bot player is shown their creature's list of available skills.
  - **Code Check**: The `opponent_turn` method randomly selects a skill for the bot. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] The bot player chooses one skill, which is queued for the resolution phase.
  - **Code Check**: The `opponent_turn` method queues the chosen skill for execution. (File: `main_game/scenes/main_game_scene.py`)

#### Resolution Phase

- [x] Skills queued in the Player and Foe Choice Phases are resolved in the Resolution Phase.
  - **Code Check**: The `execute_skill` method resolves the queued skills. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] Skills are executed based on the speed of the creature using the skill.
  - **Code Check**: The code does not explicitly check for speed to determine skill execution order. This is a discrepancy. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] If creatures have the same speed, the order is decided randomly with equal probability.
  - **Code Check**: The code does not handle speed ties or random order. This is a discrepancy. (File: `main_game/scenes/main_game_scene.py`)

##### Skill Execution

- [x] Raw damage is calculated as the skill's base damage plus the attacker's attack minus the defender's defense.
  - **Code Check**: The `execute_skill` method calculates raw damage correctly. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] Final damage is calculated by multiplying raw damage by a weakness-resistance factor.
  - **Code Check**: The `execute_skill` method calculates final damage using a weakness factor. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] All damage calculations are performed with floats and converted to an integer for final damage.
  - **Code Check**: The code uses integer arithmetic directly, which is a discrepancy. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] Final damage is subtracted from the defender's hp.
  - **Code Check**: The `execute_skill` method subtracts final damage from the defender's hp. (File: `main_game/scenes/main_game_scene.py`)

##### Type Relationships

- [x] A skill type effective against a creature type has a factor of 2.
  - **Code Check**: The `calculate_weakness_factor` method implements this correctly. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] A skill type ineffective against a creature type has a factor of 1/2.
  - **Code Check**: The `calculate_weakness_factor` method implements this correctly. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] "Normal" type skills are neither effective nor ineffective against any types.
  - **Code Check**: The `calculate_weakness_factor` method returns 1 for normal types, which is correct. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] "Fire" type skills are effective against "Leaf" and ineffective against "Water".
  - **Code Check**: The `calculate_weakness_factor` method implements this correctly. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] "Water" type skills are effective against "Fire" and ineffective against "Leaf".
  - **Code Check**: The `calculate_weakness_factor` method implements this correctly. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] "Leaf" type skills are effective against "Water" and ineffective against "Fire".
  - **Code Check**: The `calculate_weakness_factor` method implements this correctly. (File: `main_game/scenes/main_game_scene.py`)

### Battle End Condition

- [x] The battle ends when a creature's hp reaches zero.
  - **Code Check**: The `check_battle_end` method checks for hp reaching zero. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] A message is shown indicating whether the player has won or lost.
  - **Code Check**: The `check_battle_end` method displays a win/loss message. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] If the player's creature is defeated, they are informed they are the loser.
  - **Code Check**: The `check_battle_end` method informs the player of a loss. (File: `main_game/scenes/main_game_scene.py`)
  
- [x] If the opponent's creature is defeated, the player is informed they are the winner.
  - **Code Check**: The `check_battle_end` method informs the player of a win. (File: `main_game/scenes/main_game_scene.py`)

### Game Entities

#### Player

- [x] A Player represents a human or bot within the game.
  - **Code Check**: The `Player` class in `models.py` represents both human and bot players. (File: `main_game/models.py`)
  
- [x] A Player has a collection of creatures at their disposal.
  - **Code Check**: The `Player` class has a `creatures` attribute. (File: `main_game/models.py`)

#### Creature

- [x] A Creature has a `creature_type` attribute representing its elemental affinity.
  - **Code Check**: The `Creature` class has a `creature_type` attribute. (File: `main_game/models.py`)
  
- [x] A Creature has an `hp` attribute representing its health points.
  - **Code Check**: The `Creature` class has an `hp` attribute. (File: `main_game/models.py`)
  
- [x] A Creature has a `max_hp` attribute representing its maximum health points.
  - **Code Check**: The `Creature` class has a `max_hp` attribute. (File: `main_game/models.py`)
  
- [x] A Creature has an `attack` attribute representing its attack power.
  - **Code Check**: The `Creature` class has an `attack` attribute. (File: `main_game/models.py`)
  
- [x] A Creature has a `defense` attribute representing its resistance to damage.
  - **Code Check**: The `Creature` class has a `defense` attribute. (File: `main_game/models.py`)
  
- [x] A Creature has a `speed` attribute representing its priority in turn order.
  - **Code Check**: The `Creature` class has a `speed` attribute. (File: `main_game/models.py`)
  
- [x] A Creature has a `skills` attribute representing the skills it can use in battle.
  - **Code Check**: The `Creature` class has a `skills` attribute. (File: `main_game/models.py`)

#### Skill

- [x] A Skill has a `skill_type` attribute representing its elemental affinity.
  - **Code Check**: The `Skill` class has a `skill_type` attribute. (File: `main_game/models.py`)
  
- [x] A Skill has a `base_damage` attribute representing the damage it deals.
  - **Code Check**: The `Skill` class has a `base_damage` attribute. (File: `main_game/models.py`)

### Prototypes

#### Creature Prototypes

- [x] "Bubwool" is a "water" type creature with 10 hp, 3 attack, 2 defense, 4 speed, and skills ["Tackle", "Lick"].
  - **Code Check**: The `creature.json` file defines "Bubwool" with the correct attributes. (File: `main_game/content/creature.json`)
  
- [x] "Scizard" is a "fire" type creature with 11 hp, 3 attack, 3 defense, 3 speed, and skills ["Tackle", "Fireball"].
  - **Code Check**: The `creature.json` file defines "Scizard" with the correct attributes. (File: `main_game/content/creature.json`)

#### Player Prototypes

- [x] "Default Player" has a Bubwool.
  - **Code Check**: The `player.json` file defines "Default Player" with a Bubwool. (File: `main_game/content/player.json`)
  
- [x] "Basic Opponent" has a Scizard.
  - **Code Check**: The `player.json` file defines "Basic Opponent" with a Scizard. (File: `main_game/content/player.json`)

#### Skill Prototypes

- [x] "Tackle" is a "normal" type skill with 3 damage.
  - **Code Check**: The `skill.json` file defines "Tackle" with the correct attributes. (File: `main_game/content/skill.json`)
  
- [x] "Fireball" is a "fire" type skill with 2 damage.
  - **Code Check**: The `skill.json` file defines "Fireball" with the correct attributes. (File: `main_game/content/skill.json`)
  
- [x] "Lick" is a "water" type skill with 2 damage.
  - **Code Check**: The `skill.json` file defines "Lick" with the correct attributes. (File: `main_game/content/skill.json`)

### Discrepancies and Missing Elements

1. **Speed-Based Skill Execution**: The code does not implement speed-based skill execution or handle ties with random order, which is a discrepancy from the architecture description.

2. **Float-Based Damage Calculation**: The code uses integer arithmetic for damage calculations instead of performing calculations with floats and converting to integers, which is a discrepancy.

These discrepancies should be addressed to fully align the implementation with the described architecture.
__________________
Role: user
Content: if you think the code is correct, set qa_result to 'passed' otherwise set it to 'failed'. Set it to 'unknown' only when you really have no idea
__________________
Role: assistant
Content: ```json
{
  "qa_result": "failed",
  "explanation": "The code does not implement speed-based skill execution or handle ties with random order, which is a discrepancy from the architecture description. Additionally, the code uses integer arithmetic for damage calculations instead of performing calculations with floats and converting to integers, which is another discrepancy."
}
```
__________________
