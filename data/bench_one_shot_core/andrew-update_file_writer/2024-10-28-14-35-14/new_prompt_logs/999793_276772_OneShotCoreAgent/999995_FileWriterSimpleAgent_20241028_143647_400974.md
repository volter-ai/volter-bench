Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
To fix the issue, we need to address the main problem: the MainGameScene is terminating without calling `quit_whole_game` or `transition_to_scene`. This is causing the test to fail because the scene is not exiting in an expected manner. Here's how we'll fix it:

1. In the MainGameScene, we'll modify the `run` method to ensure that after the battle ends, we either transition back to the MainMenuScene or quit the whole game.

2. We'll add a method to check if the player wants to play again after the battle ends.

3. We'll use the `_transition_to_scene` or `_quit_whole_game` methods to properly exit the scene.

Here's the rewritten MainGameScene with the proposed solution:

# Excerpt ID: 0b5cb6f6-0700-4c5d-8bfc-e47a4b83be1f
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available skills:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        while True:
            # Player Choice Phase
            player_skill = self._player_choice_phase()

            # Foe Choice Phase
            foe_skill = self._foe_choice_phase()

            # Resolution Phase
            self._resolution_phase(player_skill, foe_skill)

            # Check for battle end
            if self._check_battle_end():
                if self._play_again():
                    # Reset creatures for a new battle
                    self.player_creature.hp = self.player_creature.max_hp
                    self.opponent_creature.hp = self.opponent_creature.max_hp
                else:
                    self._transition_to_scene("MainMenuScene")
                    break

    def _player_choice_phase(self):
        choices = [SelectThing(skill) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def _foe_choice_phase(self):
        choices = [SelectThing(skill) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def _resolution_phase(self, player_skill, foe_skill):
        first, second = self._determine_order()
        self._execute_skill(first, second, player_skill if first == self.player else foe_skill)
        if not self._check_battle_end():
            self._execute_skill(second, first, foe_skill if first == self.player else player_skill)

    def _determine_order(self):
        if self.player_creature.speed > self.opponent_creature.speed:
            return self.player, self.opponent
        elif self.player_creature.speed < self.opponent_creature.speed:
            return self.opponent, self.player
        else:
            return random.sample([self.player, self.opponent], 2)

    def _execute_skill(self, attacker, defender, skill):
        attacker_creature = attacker.creatures[0]
        defender_creature = defender.creatures[0]
        damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        damage = max(0, damage)  # Ensure damage is not negative
        defender_creature.hp = max(0, defender_creature.hp - damage)
        self._show_text(attacker, f"{attacker_creature.display_name} used {skill.display_name}!")
        self._show_text(defender, f"{defender_creature.display_name} took {damage} damage!")

    def _check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, "You lost the battle!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, "You won the battle!")
            return True
        return False

    def _play_again(self):
        play_again_button = Button("Play Again")
        main_menu_button = Button("Return to Main Menu")
        choices = [play_again_button, main_menu_button]
        choice = self._wait_for_choice(self.player, choices)
        return choice == play_again_button
```

This solution addresses the issue by ensuring that the MainGameScene always exits properly, either by transitioning back to the MainMenuScene or by allowing the player to play again. The `_play_again` method gives the player the option to start a new battle or return to the main menu. 

By using `self._transition_to_scene("MainMenuScene")` when the player chooses not to play again, we ensure that the scene exits in an expected manner, which should resolve the test failure.

This implementation stays within the capabilities of the engine and maintains the existing architecture. It doesn't require any changes to the models, keeping them as pure data schemas.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
