Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for bringing this issue to my attention. You're right that I missed implementing the speed-based resolution of skill execution, which is a crucial part of the game's architecture. I'll describe how to fix this issue and then provide the updated file.

1. Description of the fix:

To implement the speed-based resolution of skill execution, we'll modify the MainGameScene class. Here's how we'll do it:

a. Instead of executing turns sequentially, we'll queue both the player's and opponent's actions.
b. We'll create a method to determine the order of execution based on the creatures' speed stats.
c. We'll modify the run method to use this new execution order.
d. If speeds are equal, we'll use a random choice to determine who goes first.

This approach stays within the capabilities of the engine and doesn't require changes to the models, keeping them as pure data schemas.

2. Rewritten file with the proposed solution:

# Excerpt ID: aa791d68-fc92-4fcb-9079-93a0381a4863
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Your turn! Choose a skill:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent.display_name} appeared!")
        while True:
            player_skill = self.player_turn()
            opponent_skill = self.opponent_turn()
            
            first, second = self.determine_turn_order(
                (self.player_creature, player_skill),
                (self.opponent_creature, opponent_skill)
            )
            
            for attacker, defender, skill in [first, second]:
                if self.execute_turn(attacker, defender, skill):
                    if self.check_battle_end():
                        return

    def player_turn(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def opponent_turn(self):
        return random.choice(self.opponent_creature.skills)

    def determine_turn_order(self, player_action, opponent_action):
        player_creature, player_skill = player_action
        opponent_creature, opponent_skill = opponent_action
        
        if player_creature.speed > opponent_creature.speed:
            return (player_creature, self.opponent_creature, player_skill), (opponent_creature, self.player_creature, opponent_skill)
        elif opponent_creature.speed > player_creature.speed:
            return (opponent_creature, self.player_creature, opponent_skill), (player_creature, self.opponent_creature, player_skill)
        else:
            if random.choice([True, False]):
                return (player_creature, self.opponent_creature, player_skill), (opponent_creature, self.player_creature, opponent_skill)
            else:
                return (opponent_creature, self.player_creature, opponent_skill), (player_creature, self.opponent_creature, player_skill)

    def execute_turn(self, attacker: Creature, defender: Creature, skill: Skill):
        self._show_text(self.player, f"{attacker.display_name} used {skill.display_name}!")
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        type_factor = self.get_type_factor(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_factor)
        defender.hp = max(0, defender.hp - final_damage)
        self._show_text(self.player, f"{defender.display_name} took {final_damage} damage!")
        return defender.hp == 0

    def get_type_factor(self, skill_type: str, defender_type: str):
        if skill_type == "normal":
            return 1
        elif skill_type == "fire" and defender_type == "leaf":
            return 2
        elif skill_type == "water" and defender_type == "fire":
            return 2
        elif skill_type == "leaf" and defender_type == "water":
            return 2
        elif skill_type == "fire" and defender_type == "water":
            return 0.5
        elif skill_type == "water" and defender_type == "leaf":
            return 0.5
        elif skill_type == "leaf" and defender_type == "fire":
            return 0.5
        else:
            return 1

    def check_battle_end(self):
        if self.player_creature.hp == 0:
            self._show_text(self.player, f"Your {self.player_creature.display_name} fainted! You lost the battle.")
            self.end_battle()
            return True
        elif self.opponent_creature.hp == 0:
            self._show_text(self.player, f"Opponent's {self.opponent_creature.display_name} fainted! You won the battle!")
            self.end_battle()
            return True
        return False

    def end_battle(self):
        self._show_text(self.player, "Returning to the main menu...")
        self._transition_to_scene("MainMenuScene")
```

This updated implementation now correctly handles the speed-based resolution of skill execution as described in the architecture. The main changes are:

1. The `run` method now queues both player and opponent actions before determining the execution order.
2. A new `determine_turn_order` method has been added to decide which creature acts first based on their speed stats.
3. If speeds are equal, a random choice is made to determine who goes first.
4. The execution of turns is now done in the order determined by `determine_turn_order`.

These changes ensure that the battle system aligns with the described architecture while maintaining the existing model structure and staying within the capabilities of the engine.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "aa791d68-fc92-4fcb-9079-93a0381a4863", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
