Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issue, we need to modify the `MainGameScene` class in the `main_game_scene.py` file. The error occurs because we're trying to access the `speed` attribute of a `Skill` object, which doesn't exist. Instead, we should be using the `speed` of the creature that's using the skill.

Here's how we'll fix it:

1. We'll modify the `resolve_turn` method to use the active creature's speed instead of the skill's speed when sorting the turn queue.
2. We'll update the lambda function in the `sort` method to access the correct speed attribute.

Now, let's rewrite the `main_game_scene.py` file with the proposed solution:

# Excerpt ID: 388a6f64-44d1-4b27-bfc6-2536e865a25f
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.turn_queue = []

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        return f"""===Battle===
{self.player.display_name}'s {player_creature.display_name}: HP {player_creature.hp}/{player_creature.max_hp}
{self.opponent.display_name}'s {opponent_creature.display_name}: HP {opponent_creature.hp}/{opponent_creature.max_hp}

> Attack
> Swap
"""

    def run(self):
        self._show_text(self.player, "Battle start!")
        while True:
            self.player_turn()
            if self.check_battle_end():
                break
            self.opponent_turn()
            if self.check_battle_end():
                break
            self.resolve_turn()

    def player_turn(self):
        while True:
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choice = self._wait_for_choice(self.player, [attack_button, swap_button])

            if choice == attack_button:
                skill_choices = [SelectThing(skill) for skill in self.player.active_creature.skills]
                skill_choice = self._wait_for_choice(self.player, skill_choices + [Button("Back")])
                if isinstance(skill_choice, SelectThing):
                    self.turn_queue.append(("player", "attack", skill_choice.thing))
                    break
            elif choice == swap_button:
                creature_choices = [SelectThing(creature) for creature in self.player.creatures if creature.hp > 0 and creature != self.player.active_creature]
                creature_choice = self._wait_for_choice(self.player, creature_choices + [Button("Back")])
                if isinstance(creature_choice, SelectThing):
                    self.turn_queue.append(("player", "swap", creature_choice.thing))
                    break

    def opponent_turn(self):
        choices = [Button("Attack"), Button("Swap")]
        choice = self._wait_for_choice(self.opponent, choices)

        if choice.display_name == "Attack":
            skill = random.choice(self.opponent.active_creature.skills)
            self.turn_queue.append(("opponent", "attack", skill))
        else:
            available_creatures = [c for c in self.opponent.creatures if c.hp > 0 and c != self.opponent.active_creature]
            if available_creatures:
                creature = random.choice(available_creatures)
                self.turn_queue.append(("opponent", "swap", creature))

    def resolve_turn(self):
        def get_speed(turn):
            player, action, target = turn
            if action == "swap":
                return float('inf')  # Swapping always goes first
            else:
                return self.player.active_creature.speed if player == "player" else self.opponent.active_creature.speed

        self.turn_queue.sort(key=lambda x: (-get_speed(x), x[0]))  # Sort by speed (descending) and then by player

        for turn in self.turn_queue:
            player, action, target = turn
            if action == "swap":
                self.swap_creature(player, target)
            elif action == "attack":
                self.execute_attack(player, target)

        self.turn_queue.clear()

    def swap_creature(self, player, creature):
        if player == "player":
            self.player.active_creature = creature
            self._show_text(self.player, f"{self.player.display_name} swapped to {creature.display_name}!")
        else:
            self.opponent.active_creature = creature
            self._show_text(self.player, f"{self.opponent.display_name} swapped to {creature.display_name}!")

    def execute_attack(self, attacker, skill):
        if attacker == "player":
            attacker_creature = self.player.active_creature
            defender_creature = self.opponent.active_creature
        else:
            attacker_creature = self.opponent.active_creature
            defender_creature = self.player.active_creature

        damage = self.calculate_damage(attacker_creature, defender_creature, skill)
        defender_creature.hp = max(0, defender_creature.hp - damage)

        self._show_text(self.player, f"{attacker_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender_creature.display_name} took {damage} damage!")

        if defender_creature.hp == 0:
            self._show_text(self.player, f"{defender_creature.display_name} fainted!")
            self.force_swap(attacker)

    def calculate_damage(self, attacker, defender, skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_effectiveness)
        return max(1, final_damage)

    def get_type_effectiveness(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def force_swap(self, player):
        if player == "player":
            available_creatures = [c for c in self.player.creatures if c.hp > 0]
            if available_creatures:
                creature_choices = [SelectThing(creature) for creature in available_creatures]
                choice = self._wait_for_choice(self.player, creature_choices)
                self.player.active_creature = choice.thing
                self._show_text(self.player, f"{self.player.display_name} sent out {choice.thing.display_name}!")
        else:
            available_creatures = [c for c in self.opponent.creatures if c.hp > 0]
            if available_creatures:
                creature = random.choice(available_creatures)
                self.opponent.active_creature = creature
                self._show_text(self.player, f"{self.opponent.display_name} sent out {creature.display_name}!")

    def check_battle_end(self):
        if all(c.hp == 0 for c in self.player.creatures):
            self._show_text(self.player, f"{self.player.display_name} lost the battle!")
            return True
        elif all(c.hp == 0 for c in self.opponent.creatures):
            self._show_text(self.player, f"{self.player.display_name} won the battle!")
            return True
        return False
```

This solution modifies the `resolve_turn` method to use a separate `get_speed` function that correctly retrieves the speed of the active creature for each player. The sorting logic has been updated to use this function, ensuring that the turn order is determined by the creatures' speeds rather than trying to access a non-existent `speed` attribute on the `Skill` objects.

The rest of the file remains largely unchanged, maintaining the overall structure and logic of the battle system. This change should resolve the AttributeError and allow the game to run without crashing.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "388a6f64-44d1-4b27-bfc6-2536e865a25f", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
