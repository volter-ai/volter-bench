Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for bringing this issue to my attention. I'll address the missing implementation for forced swapping when a creature is knocked out.

1. To fix this issue, I'll make the following changes to the `MainGameScene` class:

   a. Modify the `_perform_attack` method to check if the defender's active creature is knocked out after taking damage.
   b. If the active creature is knocked out, call a new `_handle_knocked_out_creature` method.
   c. Implement the `_handle_knocked_out_creature` method to force a swap if the player has any available creatures, or end the battle if not.
   d. Update the `_check_battle_end` method to use the new `_handle_knocked_out_creature` method.

These changes will stay within the capabilities of the engine and maintain the existing architecture. The models will remain as pure data schemas, and all game logic will be handled within the scene.

2. Here's the rewritten `main_game_scene.py` file with the proposed solution:

# Excerpt ID: 1b79c2ae-63dd-4f12-be39-e668fc25ab78
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing, HumanListener, RandomModeGracefulExit
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.turn_counter = 0

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        return f"""===Battle===
Turn: {self.turn_counter}

{self.player.display_name}'s {player_creature.display_name}:
HP: {player_creature.hp}/{player_creature.max_hp}

{self.opponent.display_name}'s {opponent_creature.display_name}:
HP: {opponent_creature.hp}/{opponent_creature.max_hp}

> Attack
> Swap
"""

    def run(self):
        self._initialize_battle()
        try:
            while True:
                self.turn_counter += 1
                player_action = self._player_choice_phase(self.player)
                opponent_action = self._player_choice_phase(self.opponent)
                self._resolution_phase(player_action, opponent_action)
                
                if self._check_battle_end():
                    break

                if isinstance(self.player._listener, HumanListener) and self.player._listener.random_mode:
                    self.player._listener.random_mode_counter -= 1
                    if self.player._listener.random_mode_counter <= 0:
                        raise RandomModeGracefulExit()

        except RandomModeGracefulExit:
            print("Random mode gracefully exiting the battle")
        finally:
            self._reset_creatures_state()
            self._transition_to_scene("MainMenuScene")

    def _initialize_battle(self):
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]

    def _player_choice_phase(self, player):
        while True:
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choices = [attack_button, swap_button]
            choice = self._wait_for_choice(player, choices)

            if attack_button == choice:
                action = self._choose_attack(player)
                if action:
                    return action
            elif swap_button == choice:
                action = self._choose_swap(player)
                if action:
                    return action

    def _choose_attack(self, player):
        choices = [SelectThing(skill) for skill in player.active_creature.skills]
        back_button = Button("Back")
        choices.append(back_button)
        choice = self._wait_for_choice(player, choices)
        if choice == back_button:
            return None
        return choice

    def _choose_swap(self, player):
        available_creatures = [c for c in player.creatures if c != player.active_creature and c.hp > 0]
        if not available_creatures:
            self._show_text(player, "No creatures available to swap!")
            return None
        choices = [SelectThing(creature) for creature in available_creatures]
        back_button = Button("Back")
        choices.append(back_button)
        choice = self._wait_for_choice(player, choices)
        if choice == back_button:
            return None
        return choice

    def _resolution_phase(self, player_action, opponent_action):
        actions = [
            (self.player, player_action),
            (self.opponent, opponent_action)
        ]
        
        # Sort actions based on speed (swap actions go first)
        actions.sort(key=lambda x: (
            isinstance(x[1].thing, Creature),
            -x[0].active_creature.speed
        ))

        # Randomize order for same-speed creatures
        if (isinstance(actions[0][1].thing, Skill) and isinstance(actions[1][1].thing, Skill) and
            actions[0][0].active_creature.speed == actions[1][0].active_creature.speed):
            random.shuffle(actions)

        for actor, action in actions:
            if isinstance(action.thing, Creature):
                self._perform_swap(actor, action.thing)
            elif isinstance(action.thing, Skill):
                self._perform_attack(actor, action.thing)

    def _perform_swap(self, actor, new_creature):
        actor.active_creature = new_creature
        self._show_text(actor, f"{actor.display_name} swapped to {new_creature.display_name}!")

    def _perform_attack(self, attacker, skill):
        defender = self.opponent if attacker == self.player else self.player
        damage = self._calculate_damage(attacker.active_creature, defender.active_creature, skill)
        defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
        self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(defender, f"{defender.active_creature.display_name} took {damage} damage!")

        if defender.active_creature.hp == 0:
            self._handle_knocked_out_creature(defender)

    def _calculate_damage(self, attacker, defender, skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_effectiveness = self._get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_effectiveness)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def _get_type_effectiveness(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def _check_battle_end(self):
        for player in [self.player, self.opponent]:
            if all(c.hp == 0 for c in player.creatures):
                winner = self.opponent if player == self.player else self.player
                self._show_text(self.player, f"{winner.display_name} won the battle!")
                return True
        return False

    def _handle_knocked_out_creature(self, player):
        self._show_text(player, f"{player.active_creature.display_name} was knocked out!")
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if available_creatures:
            self._force_swap(player)
        else:
            self._show_text(player, f"{player.display_name} has no more creatures available!")

    def _force_swap(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        choices = [SelectThing(creature) for creature in available_creatures]
        self._show_text(player, "Choose a creature to swap in:")
        new_creature = self._wait_for_choice(player, choices).thing
        self._perform_swap(player, new_creature)

    def _reset_creatures_state(self):
        for player in [self.player, self.opponent]:
            for creature in player.creatures:
                creature.hp = creature.max_hp
        self.player.active_creature = None
        self.opponent.active_creature = None
```

This solution implements the forced swapping when a creature is knocked out, as required by the architecture description. The changes include:

1. A new `_handle_knocked_out_creature` method that checks for available creatures and forces a swap if possible.
2. An updated `_perform_attack` method that calls `_handle_knocked_out_creature` when a creature's HP reaches zero.
3. A modified `_force_swap` method that handles the swapping process for knocked-out creatures.
4. An updated `_check_battle_end` method that uses the new logic for determining when the battle ends.

These changes maintain the existing architecture and stay within the capabilities of the engine. The models remain as pure data schemas, and all game logic is handled within the scene.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "1b79c2ae-63dd-4f12-be39-e668fc25ab78", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
