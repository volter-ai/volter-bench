Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issues raised during QA/testing, we need to address two main problems:

1. The MainGameScene is not exiting properly, either by transitioning to another scene or quitting the whole game.
2. The test for MainGameScene is failing because the scene is not exiting as expected.

Here's how we'll fix these issues:

1. In the MainGameScene, we'll add a transition back to the MainMenuScene after the battle ends (either when the player wins or loses).
2. We'll also add a check to quit the whole game if the random mode counter reaches zero, to ensure the test can exit gracefully.

These changes will ensure that the scene always exits properly and that the tests can pass. Let's rewrite the MainGameScene with these fixes:

# Excerpt ID: 9bb82646-2dd0-48fd-b7ab-b88d6cd8c6fe
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing, HumanListener, RandomModeGracefulExit
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.turn_counter = 0

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        return f"""===Battle===
Turn: {self.turn_counter}

{self.player.display_name}'s {player_creature.display_name}:
HP: {player_creature.hp}/{player_creature.max_hp}

{self.opponent.display_name}'s {opponent_creature.display_name}:
HP: {opponent_creature.hp}/{opponent_creature.max_hp}

> Attack
> Swap
"""

    def run(self):
        self._initialize_battle()
        try:
            while True:
                self.turn_counter += 1
                player_action = self._player_choice_phase(self.player)
                opponent_action = self._player_choice_phase(self.opponent)
                self._resolution_phase(player_action, opponent_action)
                
                if self._check_battle_end():
                    break

                # Check if we're in random mode and should exit
                if isinstance(self.player._listener, HumanListener) and self.player._listener.random_mode:
                    self.player._listener.random_mode_counter -= 1
                    if self.player._listener.random_mode_counter <= 0:
                        raise RandomModeGracefulExit()

        except RandomModeGracefulExit:
            print("Random mode gracefully exiting the battle")
        finally:
            self._transition_to_scene("MainMenuScene")

    def _initialize_battle(self):
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]

    def _player_choice_phase(self, player):
        while True:
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choices = [attack_button, swap_button]
            choice = self._wait_for_choice(player, choices)

            if attack_button == choice:
                return self._choose_attack(player)
            elif swap_button == choice:
                swap_action = self._choose_swap(player)
                if swap_action is not None:
                    return swap_action
                else:
                    self._show_text(player, "No creatures available to swap!")
                    continue  # Go back to the main choice

    def _choose_attack(self, player):
        choices = [SelectThing(skill) for skill in player.active_creature.skills]
        return self._wait_for_choice(player, choices)

    def _choose_swap(self, player):
        available_creatures = [c for c in player.creatures if c != player.active_creature and c.hp > 0]
        if not available_creatures:
            return None
        choices = [SelectThing(creature) for creature in available_creatures]
        return self._wait_for_choice(player, choices)

    def _resolution_phase(self, player_action, opponent_action):
        actions = [
            (self.player, player_action),
            (self.opponent, opponent_action)
        ]
        
        # Sort actions based on speed (swap actions go first)
        actions.sort(key=lambda x: (
            isinstance(x[1].thing, Creature),
            -x[0].active_creature.speed
        ))

        for actor, action in actions:
            if isinstance(action.thing, Creature):
                self._perform_swap(actor, action.thing)
            elif isinstance(action.thing, Skill):
                self._perform_attack(actor, action.thing)

    def _perform_swap(self, actor, new_creature):
        actor.active_creature = new_creature
        self._show_text(actor, f"{actor.display_name} swapped to {new_creature.display_name}!")

    def _perform_attack(self, attacker, skill):
        defender = self.opponent if attacker == self.player else self.player
        damage = self._calculate_damage(attacker.active_creature, defender.active_creature, skill)
        defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
        self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(defender, f"{defender.active_creature.display_name} took {damage} damage!")

    def _calculate_damage(self, attacker, defender, skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_effectiveness = self._get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_effectiveness)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def _get_type_effectiveness(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def _check_battle_end(self):
        if all(c.hp == 0 for c in self.player.creatures):
            self._show_text(self.player, "You lost the battle!")
            return True
        elif all(c.hp == 0 for c in self.opponent.creatures):
            self._show_text(self.player, "You won the battle!")
            return True
        return False

    def _force_swap(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if not available_creatures:
            return False
        choices = [SelectThing(creature) for creature in available_creatures]
        new_creature = self._wait_for_choice(player, choices).thing
        self._perform_swap(player, new_creature)
        return True
```

These changes address the issues by:

1. Adding a try-except-finally block in the `run` method to ensure that we always transition back to the MainMenuScene, even if an exception occurs.
2. Implementing a check for the random mode counter in each turn, raising a RandomModeGracefulExit exception when it reaches zero.
3. Catching the RandomModeGracefulExit exception and handling it gracefully before transitioning back to the MainMenuScene.

These modifications should resolve the test failures and ensure that the MainGameScene always exits properly, either by transitioning to another scene or quitting the whole game when appropriate.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "9bb82646-2dd0-48fd-b7ab-b88d6cd8c6fe", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
