Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issues raised during QA/testing, we need to address two main problems:

1. In the MainGameScene, the scene is not exiting properly after the battle ends. We need to transition to another scene or quit the game after the battle concludes.

2. The whole game flow is not completing correctly, likely due to the same issue in the MainGameScene.

To resolve these issues, we'll modify the MainGameScene to transition back to the MainMenuScene after the battle ends. This will ensure that the scene exits properly and allows the game flow to continue.

Here's how we'll fix the MainGameScene:

1. We'll add a transition to the MainMenuScene after the battle ends.
2. We'll remove the break statement that was causing the scene to exit improperly.

Let's rewrite the main_game_scene.py file with these changes:

# Excerpt ID: a7ed80d5-a6a1-494d-9298-ef17a3e41ebf
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Your turn! Choose a skill:
{', '.join([skill.display_name for skill in self.player_creature.skills])}
"""

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent.display_name} appeared!")
        while True:
            player_skill = self.player_choice_phase()
            opponent_skill = self.foe_choice_phase()
            self.resolution_phase(player_skill, opponent_skill)
            
            if self.check_battle_end():
                self._transition_to_scene("MainMenuScene")
                return

    def player_choice_phase(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def foe_choice_phase(self):
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def resolution_phase(self, player_skill, opponent_skill):
        first, second = self.determine_order(self.player_creature, self.opponent_creature)
        first_skill = player_skill if first == self.player_creature else opponent_skill
        second_skill = opponent_skill if first == self.player_creature else player_skill

        self.execute_skill(first, second, first_skill)
        if not self.check_battle_end():
            self.execute_skill(second, first, second_skill)

    def determine_order(self, creature1, creature2):
        if creature1.speed > creature2.speed:
            return creature1, creature2
        elif creature2.speed > creature1.speed:
            return creature2, creature1
        else:
            return random.sample([creature1, creature2], 2)

    def execute_skill(self, attacker, defender, skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        factor = self.get_weakness_resistance_factor(skill.skill_type, defender.creature_type)
        final_damage = int(factor * raw_damage)
        defender.hp = max(0, defender.hp - final_damage)

        attacker_name = self.player.display_name if attacker == self.player_creature else self.opponent.display_name
        defender_name = self.opponent.display_name if attacker == self.player_creature else self.player.display_name
        self._show_text(self.player, f"{attacker_name}'s {attacker.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"{defender_name}'s {defender.display_name} took {final_damage} damage!")

    def get_weakness_resistance_factor(self, skill_type, creature_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, creature_type), 1)

    def check_battle_end(self):
        if self.player_creature.hp == 0:
            self._show_text(self.player, f"{self.player.display_name}, you lost the battle!")
            return True
        elif self.opponent_creature.hp == 0:
            self._show_text(self.player, f"Congratulations {self.player.display_name}, you won the battle!")
            return True
        return False
```

The main changes in this updated version are:

1. In the `run` method, we've replaced the `break` statement with a transition to the MainMenuScene:
# Excerpt ID: 29ab5924-326f-4634-a6f0-f9013c2b350d
   ```python
   if self.check_battle_end():
       self._transition_to_scene("MainMenuScene")
       return
   ```

2. We've removed the `break` statement that was causing the scene to exit improperly.

These changes ensure that the MainGameScene properly transitions back to the MainMenuScene after the battle ends, allowing the game flow to continue and fixing the issues raised during QA/testing. The scene will now exit in an expected manner, either by transitioning to another scene or quitting the game, which should resolve both the MainGameScene test failure and the whole game flow test failure.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "a7ed80d5-a6a1-494d-9298-ef17a3e41ebf", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
