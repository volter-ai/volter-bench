Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
The issue is that scenes need to properly end by either transitioning to another scene or calling quit_whole_game. There are two specific problems:

1. In MainMenuScene, we need to catch the _QuitWholeGame exception in the test
2. In MainGameScene, we're breaking from the game loop without properly ending the scene. After a battle ends, we should call quit_whole_game

Here's how I'll fix it:

1. For MainGameScene: After a battle ends and we show the winner, we'll call quit_whole_game to properly end the game
2. For test_main_menu_scene: We'll catch the expected _QuitWholeGame exception

Here are the fixed files:

# Excerpt ID: 496b42d8-b74e-460c-959f-a545da7878cc
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        
        # Reset creatures
        for p in [self.player, self.bot]:
            for c in p.creatures:
                c.hp = c.max_hp
            p.active_creature = p.creatures[0]

    def __str__(self):
        p1 = self.player
        p2 = self.bot
        
        return f"""=== Battle ===
{p1.display_name}'s {p1.active_creature.display_name}: {p1.active_creature.hp}/{p1.active_creature.max_hp} HP
{p2.display_name}'s {p2.active_creature.display_name}: {p2.active_creature.hp}/{p2.active_creature.max_hp} HP

> Attack
> Swap"""

    def run(self):
        while True:
            # Player turn
            p1_action = self.get_player_action(self.player)
            p2_action = self.get_player_action(self.bot)
            
            # Resolve actions
            self.resolve_turn(p1_action, p2_action)
            
            # Check for battle end
            if self.check_battle_end():
                # Properly end the game after showing the winner
                self._quit_whole_game()

    def get_player_action(self, player):
        # First check what choices are available
        choices = [Button("Attack")]
        
        # Only add swap if there are valid creatures to swap to
        valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
        if valid_creatures:
            choices.append(Button("Swap"))
            
        choice = self._wait_for_choice(player, choices)
        
        if choice.display_name == "Attack":
            choices = [SelectThing(skill) for skill in player.active_creature.skills]
            return ("attack", self._wait_for_choice(player, choices).thing)
        else:
            choices = [SelectThing(creature) for creature in valid_creatures]
            return ("swap", self._wait_for_choice(player, choices).thing)

    def resolve_turn(self, p1_action, p2_action):
        actions = [p1_action, p2_action]
        players = [self.player, self.bot]
        
        # Swaps go first
        for i, action in enumerate(actions):
            if action[0] == "swap":
                players[i].active_creature = action[1]
                self._show_text(players[i], f"{players[i].display_name} swapped to {action[1].display_name}!")

        # Then attacks in speed order
        attackers = []
        for i, action in enumerate(actions):
            if action[0] == "attack":
                attackers.append((i, players[i], action[1]))
                
        if len(attackers) == 2:
            # Sort by speed
            attackers.sort(key=lambda x: x[1].active_creature.speed, reverse=True)
            
        for i, attacker, skill in attackers:
            defender = players[1-i]
            damage = self.calculate_damage(attacker.active_creature, defender.active_creature, skill)
            defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
            
            self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
            self._show_text(defender, f"{defender.active_creature.display_name} took {damage} damage!")
            
            if defender.active_creature.hp == 0:
                self._show_text(defender, f"{defender.active_creature.display_name} was knocked out!")
                valid_creatures = [c for c in defender.creatures if c.hp > 0]
                if valid_creatures:
                    choices = [SelectThing(c) for c in valid_creatures]
                    new_creature = self._wait_for_choice(defender, choices).thing
                    defender.active_creature = new_creature
                    self._show_text(defender, f"{defender.display_name} sent out {new_creature.display_name}!")

    def calculate_damage(self, attacker, defender, skill):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Type effectiveness
        effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        
        return int(raw_damage * effectiveness)

    def get_type_effectiveness(self, attack_type, defend_type):
        if attack_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"water": 0.5, "leaf": 2.0},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(attack_type, {}).get(defend_type, 1.0)

    def check_battle_end(self):
        for player in [self.player, self.bot]:
            if not any(c.hp > 0 for c in player.creatures):
                winner = self.bot if player == self.player else self.player
                self._show_text(self.player, f"{winner.display_name} wins!")
                return True
        return False
```

# Excerpt ID: f88e9a21-3cbc-431c-ab49-2f1c7448296e
```python main_game/tests/test_main_menu_scene.py
import pytest
from unittest.mock import Mock, patch
from mini_game_engine.engine.lib import HumanListener, RandomModeGracefulExit, AbstractApp
from main_game.scenes.main_menu_scene import MainMenuScene
from main_game.main import App

class TestMainMenuSceneRandomRun:
    @pytest.fixture
    def app(self):
        return App()

    def test_main_menu_scene_random_run(self, app):
        for i in range(10):
            print(f"starting random run iteration {i}")
            HumanListener.random_mode = True
            HumanListener.random_mode_counter = 10

            player = app.create_player(f"player_{i}")
            scene = MainMenuScene(app, player)

            try:
                scene.run()
            except (RandomModeGracefulExit, AbstractApp._QuitWholeGame) as e:
                print(f"Run {i} completed as expected with: {type(e).__name__}")
```

The key changes are:

1. In MainGameScene.run(), after check_battle_end() returns True, we now call self._quit_whole_game() to properly end the game
2. In test_main_menu_scene.py, we now catch both RandomModeGracefulExit and AbstractApp._QuitWholeGame as expected exceptions

These changes ensure that:
1. The game properly ends after a battle concludes
2. The tests properly handle the expected quit game exception
3. We maintain the scene transition/quit requirements of the engine
4. We stay within the engine's capabilities using only provided methods

The changes don't affect the models or architecture, they just ensure proper scene termination according to the engine's requirements.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
