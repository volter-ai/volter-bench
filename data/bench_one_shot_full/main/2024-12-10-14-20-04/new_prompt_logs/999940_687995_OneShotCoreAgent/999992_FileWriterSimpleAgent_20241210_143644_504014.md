Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The test is failing because MainMenuScene tries to transition to MainGameScene, but MainGameScene isn't registered in the App. The solution is to:

- Create MainGameScene implementation
- Register it in App
- Implement the battle logic according to the architecture doc
- Keep models as pure data schemas
- Use proper scene transitions and choice handling

2. Here's the complete implementation of MainGameScene and updated App registration:

# Excerpt ID: e77bc3ce-926d-441d-8dbb-d3d099e832eb
```python main_game/scenes/main_game_scene.py
from typing import List, Optional, Tuple
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing, DictionaryChoice
from main_game.models import Player, Creature, Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        # Initialize creatures
        for p in [self.player, self.opponent]:
            p.active_creature = p.creatures[0]

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        
        return f"""=== Battle Scene ===
Your {player_creature.display_name}: HP {player_creature.hp}/{player_creature.max_hp}
Foe's {opponent_creature.display_name}: HP {opponent_creature.hp}/{opponent_creature.max_hp}

> Attack
> Swap
"""

    def run(self):
        while True:
            # Check for battle end
            if self._check_battle_end():
                return
                
            # Player turn
            player_action = self._handle_turn_choices(self.player)
            # Bot turn 
            opponent_action = self._handle_turn_choices(self.opponent)
            
            # Resolve actions
            self._resolve_actions(player_action, opponent_action)

    def _handle_turn_choices(self, current_player: Player) -> Tuple[str, Optional[Skill], Optional[Creature]]:
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        
        choice = self._wait_for_choice(current_player, [attack_button, swap_button])
        
        if choice == attack_button:
            # Show skills
            skill_choices = [SelectThing(skill) for skill in current_player.active_creature.skills]
            skill_choice = self._wait_for_choice(current_player, skill_choices)
            return ("attack", skill_choice.thing, None)
        else:
            # Show available creatures
            available_creatures = [c for c in current_player.creatures 
                                if c.hp > 0 and c != current_player.active_creature]
            if not available_creatures:
                self._show_text(current_player, "No creatures available to swap!")
                return self._handle_turn_choices(current_player)
                
            creature_choices = [SelectThing(creature) for creature in available_creatures]
            creature_choice = self._wait_for_choice(current_player, creature_choices)
            return ("swap", None, creature_choice.thing)

    def _resolve_actions(self, player_action: Tuple, opponent_action: Tuple):
        # Handle swaps first
        for action, player in [(player_action, self.player), (opponent_action, self.opponent)]:
            if action[0] == "swap":
                player.active_creature = action[2]
                self._show_text(self.player, f"{player.display_name} swapped to {action[2].display_name}!")

        # Then handle attacks
        actions = [(player_action, self.player, self.opponent), 
                  (opponent_action, self.opponent, self.player)]
        
        # Sort by speed
        actions.sort(key=lambda x: x[1].active_creature.speed, reverse=True)
        
        for action, attacker, defender in actions:
            if action[0] == "attack":
                skill = action[1]
                damage = self._calculate_damage(skill, attacker.active_creature, defender.active_creature)
                defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
                
                self._show_text(self.player, 
                    f"{attacker.display_name}'s {attacker.active_creature.display_name} used {skill.display_name}! "
                    f"Dealt {damage} damage!")

                if defender.active_creature.hp == 0:
                    self._handle_knockout(defender)

    def _calculate_damage(self, skill: Skill, attacker: Creature, defender: Creature) -> int:
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Type effectiveness
        multiplier = self._get_type_multiplier(skill.skill_type, defender.creature_type)
        
        return int(raw_damage * multiplier)

    def _get_type_multiplier(self, skill_type: str, defender_type: str) -> float:
        if skill_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(skill_type, {}).get(defender_type, 1.0)

    def _handle_knockout(self, player: Player):
        self._show_text(self.player, f"{player.display_name}'s {player.active_creature.display_name} was knocked out!")
        
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if not available_creatures:
            winner = self.opponent if player == self.player else self.player
            self._show_text(self.player, f"{winner.display_name} wins the battle!")
            self._transition_to_scene("MainMenuScene")
            return
            
        creature_choices = [SelectThing(creature) for creature in available_creatures]
        new_creature = self._wait_for_choice(player, creature_choices).thing
        player.active_creature = new_creature
        self._show_text(self.player, f"{player.display_name} sent out {new_creature.display_name}!")

    def _check_battle_end(self) -> bool:
        for player in [self.player, self.opponent]:
            if all(c.hp <= 0 for c in player.creatures):
                winner = self.opponent if player == self.player else self.player
                self._show_text(self.player, f"{winner.display_name} wins the battle!")
                self._transition_to_scene("MainMenuScene")
                return True
        return False
```

# Excerpt ID: 35366e69-830a-4631-bbf4-f99536a1d643
```python main_game/main.py
import uuid

from mini_game_engine.engine.lib import HumanListener, AbstractApp, BotListener
from main_game.models import Player
from main_game.scenes.main_menu_scene import MainMenuScene
from main_game.scenes.main_game_scene import MainGameScene

class App(AbstractApp):
    def __init__(self):
        super().__init__()
        self.register_scene("MainMenuScene", MainMenuScene, is_entry_point=True)
        self.register_scene("MainGameScene", MainGameScene)

    def create_player(self, player_id: str):
        player = Player.from_prototype_id(prototype_id="default_player")
        player.uid = player_id
        player.set_listener(HumanListener())
        return player

    def create_bot(self, prototype_id: str):
        bot = Player.from_prototype_id(prototype_id=prototype_id)
        bot.uid = str(uuid.uuid4())
        bot.set_listener(BotListener())
        return bot

if __name__ == '__main__':
    app = App()
    app.run(app.create_player("just_a_guy"))
```

This implementation:
1. Properly registers MainGameScene in App
2. Implements the battle logic according to the spec
3. Uses proper scene transitions
4. Keeps models as pure data schemas
5. Uses the engine's choice system for all interactions
6. Handles both human and bot players consistently

The scene follows all the phases from the architecture doc:
- Player Choice Phase
- Foe Choice Phase  
- Resolution Phase with proper speed ordering
- Handles knockouts and forced swapping
- Calculates damage using the specified formulas
- Implements type effectiveness

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
