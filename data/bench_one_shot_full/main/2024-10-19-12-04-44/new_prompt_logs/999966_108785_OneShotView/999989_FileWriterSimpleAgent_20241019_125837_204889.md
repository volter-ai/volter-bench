Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for providing the detailed information and requirements. I'll explain the architecture and implementation approach, and then provide the updated code for the MainGameSceneView component.

Architecture and Implementation Approach:

1. Component Structure:
   - MainGameSceneView: The main component that will render the entire game scene.
   - Battlefield: A sub-component to display the player and opponent creatures.
   - UserInterface: A sub-component to display the text box and action buttons.
   - HUD: A sub-component for the top navigation bar.

2. Data Handling:
   - We'll use TypeScript interfaces to define the structure of the game data, including Player, Creature, and Skill types.
   - We'll use optional chaining and nullish coalescing operators to handle potential missing data safely.

3. Styling:
   - We'll use Tailwind CSS classes for inline styling to create the layout and design described in the VIEW_SUMMARY.
   - We'll use flexbox and grid layouts to structure the battlefield and user interface areas.

4. Custom Components:
   - We'll use the provided custom components (PlayerCard, CreatureCard, and SkillButton) to display the relevant data.
   - These components will be used when we have the corresponding data types with UIDs.

5. Interactivity:
   - We'll use the useCurrentButtons hook to handle button interactions.
   - The custom components already have click events wired up, so we don't need to implement them manually.

6. Responsive Design:
   - We'll use Tailwind's responsive classes to ensure the game fits within the 16:9 game container and adapts to different screen sizes.

Now, let's implement the MainGameSceneView component:

# Excerpt ID: 78f3cd0c-e14e-440f-b8ac-0829139c8faa
```tsx main_game/templates/MainGameScene.tsx
import { useCurrentButtons } from "@/lib/useChoices.ts";
import { Shield, Sword, Zap } from 'lucide-react';
import { PlayerCard } from "@/components/ui/custom/player/player_card";
import { CreatureCard } from "@/components/ui/custom/creature/creature_card";
import { SkillButton } from "@/components/ui/custom/skill/skill_button";

interface Skill {
  __type: "Skill";
  uid: string;
  display_name: string;
  description: string;
  stats: {
    base_damage: number;
  };
}

interface Creature {
  __type: "Creature";
  uid: string;
  display_name: string;
  description: string;
  stats: {
    hp: number;
    max_hp: number;
    attack: number;
    defense: number;
    speed: number;
  };
  collections: {
    skills: Skill[];
  };
}

interface Player {
  __type: "Player";
  uid: string;
  display_name: string;
  description: string;
  collections: {
    creatures: Creature[];
  };
}

interface GameUIData {
  entities: {
    player: Player;
    opponent: Player;
    player_creature: Creature;
    opponent_creature: Creature;
  };
  meta: {
    battle_ended: boolean;
  };
}

export function MainGameSceneView({ data }: { data: GameUIData }) {
  const { availableButtonSlugs, emitButtonClick } = useCurrentButtons();

  const playerCreature = data.entities.player_creature;
  const opponentCreature = data.entities.opponent_creature;

  return (
    <div className="w-full h-full flex flex-col bg-gray-100">
      <HUD player={data.entities.player} opponent={data.entities.opponent} />
      <div className="flex-grow flex flex-col">
        <Battlefield playerCreature={playerCreature} opponentCreature={opponentCreature} />
        <UserInterface playerCreature={playerCreature} availableButtonSlugs={availableButtonSlugs} emitButtonClick={emitButtonClick} />
      </div>
    </div>
  );
}

function HUD({ player, opponent }: { player: Player; opponent: Player }) {
  return (
    <nav className="bg-gray-800 text-white p-2 flex justify-between items-center">
      <PlayerCard uid={player.uid} playerName={player.display_name} imageUrl="/path/to/player-image.jpg" />
      <h1 className="text-2xl font-bold">Creature Battle</h1>
      <PlayerCard uid={opponent.uid} playerName={opponent.display_name} imageUrl="/path/to/opponent-image.jpg" />
    </nav>
  );
}

function Battlefield({ playerCreature, opponentCreature }: { playerCreature: Creature; opponentCreature: Creature }) {
  return (
    <div className="flex-grow flex justify-between items-center p-4">
      <div className="flex flex-col items-center">
        <CreatureCard
          uid={playerCreature.uid}
          name={playerCreature.display_name}
          imageUrl="/path/to/player-creature.jpg"
          hp={playerCreature.stats.hp}
          maxHp={playerCreature.stats.max_hp}
        />
        <div className="mt-2 flex space-x-2">
          <Sword size={20} /> <span>{playerCreature.stats.attack}</span>
          <Shield size={20} /> <span>{playerCreature.stats.defense}</span>
          <Zap size={20} /> <span>{playerCreature.stats.speed}</span>
        </div>
      </div>
      <div className="flex flex-col items-center">
        <CreatureCard
          uid={opponentCreature.uid}
          name={opponentCreature.display_name}
          imageUrl="/path/to/opponent-creature.jpg"
          hp={opponentCreature.stats.hp}
          maxHp={opponentCreature.stats.max_hp}
        />
        <div className="mt-2 flex space-x-2">
          <Sword size={20} /> <span>{opponentCreature.stats.attack}</span>
          <Shield size={20} /> <span>{opponentCreature.stats.defense}</span>
          <Zap size={20} /> <span>{opponentCreature.stats.speed}</span>
        </div>
      </div>
    </div>
  );
}

function UserInterface({ playerCreature, availableButtonSlugs, emitButtonClick }: { playerCreature: Creature; availableButtonSlugs: string[]; emitButtonClick: (slug: string) => void }) {
  return (
    <div className="bg-white p-4 rounded-t-lg shadow-lg">
      <div className="mb-4 h-24 overflow-y-auto bg-gray-100 p-2 rounded">
        {/* Text box content goes here */}
        <p>Battle log and game messages will appear here.</p>
      </div>
      <div className="grid grid-cols-2 gap-2">
        {playerCreature.collections.skills.map((skill) => (
          <SkillButton
            key={skill.uid}
            uid={skill.uid}
            skillName={skill.display_name}
            description={skill.description}
            stats={`Damage: ${skill.stats.base_damage}`}
            disabled={!availableButtonSlugs.includes(skill.uid)}
            onClick={() => emitButtonClick(skill.uid)}
          />
        ))}
      </div>
    </div>
  );
}
```

This implementation follows the architecture described earlier and uses the custom components as specified. The layout is divided into three main sections: HUD, Battlefield, and UserInterface. Tailwind CSS classes are used for styling, and the component is designed to fit within a 16:9 container.

The code handles potential missing data with optional chaining and provides a responsive layout. The custom components (PlayerCard, CreatureCard, and SkillButton) are used where appropriate, passing the required props including the UID.

Note that you'll need to replace the placeholder image URLs ("/path/to/...") with actual image paths for your game assets.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "78f3cd0c-e14e-440f-b8ac-0829139c8faa", "file_path": "main_game/templates/MainGameScene.tsx"}]
```
__________________
