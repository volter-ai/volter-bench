Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To address the issue raised during QA/testing, we need to modify the MainGameScene to handle the case where creatures have the same speed by randomly deciding which creature goes first. Here's how we'll fix this:

1. We'll add a method called `determine_turn_order` that will return a tuple of (first_attacker, second_attacker) based on their speed.
2. If the speeds are equal, we'll use Python's `random.choice` to randomly select the first attacker.
3. We'll modify the `resolution_phase` method to use this new `determine_turn_order` method.

Now, let's rewrite the MainGameScene with these fixes:

# Excerpt ID: d8969ff9-cc78-40d0-8607-a7099fdd360e
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.battle_ended = False

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Your skills:
{self._format_skills(self.player_creature.skills)}

Opponent's skills:
{self._format_skills(self.opponent_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name} ({skill.skill_type} type, {skill.base_damage} damage)" for skill in skills])

    def run(self):
        self.reset_creatures()
        self.game_loop()
        self._transition_to_scene("MainMenuScene")

    def reset_creatures(self):
        self.player_creature.hp = self.player_creature.max_hp
        self.opponent_creature.hp = self.opponent_creature.max_hp
        self.battle_ended = False

    def game_loop(self):
        while not self.battle_ended:
            self._show_text(self.player, str(self))
            
            player_skill = self.player_choice_phase()
            opponent_skill = self.foe_choice_phase()
            
            self.resolution_phase(player_skill, opponent_skill)
            
            self.check_battle_end()

    def player_choice_phase(self):
        choices = [SelectThing(skill, label=f"Use {skill.display_name}") for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def foe_choice_phase(self):
        choices = [SelectThing(skill, label=f"Use {skill.display_name}") for skill in self.opponent_creature.skills]
        choice = self._wait_for_choice(self.opponent, choices)
        return choice.thing

    def determine_turn_order(self):
        if self.player_creature.speed > self.opponent_creature.speed:
            return (self.player, self.player_creature), (self.opponent, self.opponent_creature)
        elif self.player_creature.speed < self.opponent_creature.speed:
            return (self.opponent, self.opponent_creature), (self.player, self.player_creature)
        else:
            first = random.choice([(self.player, self.player_creature), (self.opponent, self.opponent_creature)])
            second = (self.opponent, self.opponent_creature) if first[0] == self.player else (self.player, self.player_creature)
            return first, second

    def resolution_phase(self, player_skill, opponent_skill):
        first, second = self.determine_turn_order()
        first_skill = player_skill if first[0] == self.player else opponent_skill
        second_skill = opponent_skill if first[0] == self.player else player_skill

        self.execute_skill(*first, first_skill, second[1])
        if second[1].hp > 0:
            self.execute_skill(*second, second_skill, first[1])

    def execute_skill(self, attacker, attacker_creature, skill, defender_creature):
        raw_damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        weakness_factor = self.calculate_weakness_factor(skill.skill_type, defender_creature.creature_type)
        final_damage = int(raw_damage * weakness_factor)
        defender_creature.hp = max(0, defender_creature.hp - final_damage)
        
        self._show_text(self.player, f"{attacker.display_name}'s {attacker_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"It dealt {final_damage} damage to {defender_creature.display_name}!")

    def calculate_weakness_factor(self, skill_type, defender_type):
        effectiveness = {
            "fire": {"leaf": 2, "water": 0.5},
            "water": {"fire": 2, "leaf": 0.5},
            "leaf": {"water": 2, "fire": 0.5}
        }
        return effectiveness.get(skill_type, {}).get(defender_type, 1)

    def check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name}, you have lost the battle!")
            self.battle_ended = True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"Congratulations {self.player.display_name}, you have won the battle!")
            self.battle_ended = True
```

This updated implementation addresses the issue by:

1. Adding a `determine_turn_order` method that handles the case where creatures have the same speed by randomly deciding which creature goes first.
2. Modifying the `resolution_phase` method to use the new `determine_turn_order` method, ensuring that the turn order is correctly determined based on speed and randomness when speeds are equal.

These changes ensure that the game follows the described architecture, where creatures with equal speed have an equal chance of going first in each turn. The implementation now correctly handles all speed scenarios, including when speeds are equal.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "d8969ff9-cc78-40d0-8607-a7099fdd360e", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
