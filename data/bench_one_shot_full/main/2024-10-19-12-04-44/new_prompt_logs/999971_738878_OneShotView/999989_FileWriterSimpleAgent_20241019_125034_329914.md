Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for providing the detailed information and requirements. I'll explain the architecture and implementation approach, and then provide the updated code for the MainGameSceneView component.

Architecture and Implementation Approach:

1. Component Structure:
   - We'll create a main container for the entire game scene.
   - Inside this container, we'll have three main sections:
     a. HUD (Navigation bar at the top)
     b. Battlefield (Middle section)
     c. User Interface (Bottom section)

2. Styling:
   - We'll use Tailwind CSS for inline styling to create the layout and design.
   - The main container will use flex layout to organize the three sections vertically.
   - The Battlefield section will use flex layout to position the player and opponent creatures.

3. Data Handling:
   - We'll create interfaces for the main data structures (Player, Creature, Skill) based on the provided VIEW_DATA.
   - We'll use optional chaining and nullish coalescing operators to handle potential missing data safely.

4. Custom Components:
   - We'll use the provided custom components (PlayerCard, CreatureCard, SkillButton) to display the relevant data.
   - These components will be used with their respective data types and UIDs.

5. Button Handling:
   - We'll use the availableButtonSlugs and emitButtonClick from useCurrentButtons to handle button availability and clicks.
   - We'll create a separate component for rendering available buttons.

6. Responsive Design:
   - We'll use Tailwind CSS classes to ensure the game fits within a 16:9 container and adapts to the window size.

Now, let's implement the MainGameSceneView component:

# Excerpt ID: 32d01b12-62e6-4757-b6a2-36deac81c415
```tsx main_game/templates/MainGameScene.tsx
import { useCurrentButtons } from "@/lib/useChoices.ts";
import { ArrowLeft } from 'lucide-react';
import { PlayerCard } from "@/components/ui/custom/player/player_card";
import { CreatureCard } from "@/components/ui/custom/creature/creature_card";
import { SkillButton } from "@/components/ui/custom/skill/skill_button";
import { Button } from "@/components/ui/button";

interface Skill {
  __type: "Skill";
  stats: { base_damage: number };
  meta: { prototype_id: string; category: string; skill_type: string };
  uid: string;
  display_name: string;
  description: string;
}

interface Creature {
  __type: "Creature";
  stats: { hp: number; max_hp: number; attack: number; defense: number; speed: number };
  meta: { prototype_id: string; category: string; creature_type: string };
  collections: { skills: Skill[] };
  uid: string;
  display_name: string;
  description: string;
}

interface Player {
  __type: "Player";
  meta: { prototype_id: string; category: string };
  collections: { creatures: Creature[] };
  uid: string;
  display_name: string;
  description: string;
}

interface GameUIData {
  entities: {
    player: Player;
    opponent: Player;
    player_creature: Creature;
    opponent_creature: Creature;
  };
}

export function MainGameSceneView(props: { data: GameUIData }) {
  const { availableButtonSlugs, emitButtonClick } = useCurrentButtons();

  const renderButtons = () => {
    return availableButtonSlugs.map((slug) => (
      <Button
        key={slug}
        onClick={() => emitButtonClick(slug)}
        className="m-1"
      >
        {slug === "return-to-main-menu" ? (
          <>
            <ArrowLeft className="mr-2 h-4 w-4" /> Return to Main Menu
          </>
        ) : (
          slug
        )}
      </Button>
    ));
  };

  return (
    <div className="flex flex-col h-full w-full bg-gray-100">
      {/* HUD */}
      <nav className="bg-blue-600 text-white p-2">
        <h1 className="text-xl font-bold">Pokemon-like Creature Battler</h1>
      </nav>

      {/* Battlefield */}
      <div className="flex-grow flex justify-between items-center p-4">
        {/* Player Creature */}
        <div className="flex flex-col items-center">
          <CreatureCard
            uid={props.data.entities.player_creature?.uid || ""}
            name={props.data.entities.player_creature?.display_name || "Unknown"}
            imageUrl="/placeholder-creature.png"
            hp={props.data.entities.player_creature?.stats.hp || 0}
            maxHp={props.data.entities.player_creature?.stats.max_hp || 1}
          />
          <p className="mt-2 font-bold">Player's Creature</p>
        </div>

        {/* Opponent Creature */}
        <div className="flex flex-col items-center">
          <CreatureCard
            uid={props.data.entities.opponent_creature?.uid || ""}
            name={props.data.entities.opponent_creature?.display_name || "Unknown"}
            imageUrl="/placeholder-creature.png"
            hp={props.data.entities.opponent_creature?.stats.hp || 0}
            maxHp={props.data.entities.opponent_creature?.stats.max_hp || 1}
          />
          <p className="mt-2 font-bold">Opponent's Creature</p>
        </div>
      </div>

      {/* User Interface */}
      <div className="bg-white p-4 border-t-2 border-gray-200">
        <div className="mb-4">
          <h2 className="text-lg font-bold mb-2">Player's Skills</h2>
          <div className="flex flex-wrap">
            {props.data.entities.player_creature?.collections.skills.map((skill) => (
              <SkillButton
                key={skill.uid}
                uid={skill.uid}
                skillName={skill.display_name}
                description={skill.description}
                stats={`Damage: ${skill.stats.base_damage}`}
                onClick={() => emitButtonClick(skill.uid)}
                className="m-1"
              />
            ))}
          </div>
        </div>
        <div>
          <h2 className="text-lg font-bold mb-2">Game Controls</h2>
          <div className="flex flex-wrap">
            {renderButtons()}
          </div>
        </div>
      </div>
    </div>
  );
}
```

This implementation creates a layout that fits the requirements described in the VIEW_SUMMARY. It uses Tailwind CSS for styling and incorporates the custom components as specified. The component handles potential missing data with optional chaining and provides fallback values where necessary.

The layout is divided into three main sections: HUD, Battlefield, and User Interface. The Battlefield displays the player's and opponent's creatures using the CreatureCard component. The User Interface section shows the player's skills using the SkillButton component and includes game control buttons.

The component uses the availableButtonSlugs and emitButtonClick functions to handle button availability and clicks. It also includes a special case for the "return-to-main-menu" button, adding an icon to it.

This implementation should provide a solid foundation for the MainGameSceneView, which can be further customized and expanded as needed.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "32d01b12-62e6-4757-b6a2-36deac81c415", "file_path": "main_game/templates/MainGameScene.tsx"}]
```
__________________
