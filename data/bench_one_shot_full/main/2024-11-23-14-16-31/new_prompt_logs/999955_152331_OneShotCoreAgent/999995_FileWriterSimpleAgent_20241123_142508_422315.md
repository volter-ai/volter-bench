Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
The issue is that I added a `reset()` method to the Creature model class, but models must be pure data schemas without any methods. Instead, the reset functionality should be moved to the scene where it's used.

Here's how to fix it:

1. Remove the `reset()` method from the Creature model
2. In MainGameScene, create a helper method to reset creature HP
3. Call this helper method instead of the creature's reset method

Here's the corrected files:

# Excerpt ID: cca27215-7db8-40a0-8b7b-cc5e0c58de24
```python main_game/models.py
from __future__ import annotations
from typing import List
from mini_game_engine.engine.lib import AbstractThing, AbstractPlayer, Collection

class Skill(AbstractThing):
    category: str = "Skill"
    skill_type: str  # normal, fire, water, leaf
    is_physical: bool
    base_damage: int

class Creature(AbstractThing):
    category: str = "Creature"
    creature_type: str  # normal, fire, water, leaf
    hp: int
    max_hp: int
    attack: int
    defense: int
    sp_attack: int 
    sp_defense: int
    speed: int
    skills: Collection[Skill]

class Player(AbstractPlayer):
    category: str = "Player"
    creatures: Collection[Creature]
```

# Excerpt ID: 5468c59c-0de3-466b-b1b1-c20741327e7c
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""=== Battle ===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available Skills:
{chr(10).join([f"> {skill.display_name}" for skill in self.player_creature.skills])}
"""

    def _reset_creature(self, creature):
        """Reset a creature's HP to its maximum"""
        creature.hp = creature.max_hp

    def run(self):
        self._show_text(self.player, f"Battle Start! {self.player_creature.display_name} vs {self.opponent_creature.display_name}")
        
        while True:
            # Player choice phase
            player_skill = self._get_skill_choice(self.player, self.player_creature)
            
            # Opponent choice phase
            opponent_skill = self._get_skill_choice(self.opponent, self.opponent_creature)

            # Resolution phase
            first, second = self._determine_order(
                (self.player, self.player_creature, player_skill),
                (self.opponent, self.opponent_creature, opponent_skill)
            )

            # Execute moves in order
            for attacker, creature, skill in [first, second]:
                if attacker == self.player:
                    defender = self.opponent
                    target = self.opponent_creature
                else:
                    defender = self.player
                    target = self.player_creature

                damage = self._calculate_damage(creature, target, skill)
                target.hp = max(0, target.hp - damage)
                
                self._show_text(self.player, f"{creature.display_name} used {skill.display_name}! Dealt {damage} damage!")
                self._show_text(self.opponent, f"{creature.display_name} used {skill.display_name}! Dealt {damage} damage!")

                if target.hp <= 0:
                    winner = self.player if target == self.opponent_creature else self.opponent
                    self._show_text(self.player, f"{winner.display_name} wins!")
                    self._show_text(self.opponent, f"{winner.display_name} wins!")
                    
                    # Reset creatures before leaving
                    self._reset_creature(self.player_creature)
                    self._reset_creature(self.opponent_creature)
                    
                    self._transition_to_scene("MainMenuScene")
                    return

    def _get_skill_choice(self, player, creature):
        choices = [SelectThing(skill) for skill in creature.skills]
        return self._wait_for_choice(player, choices).thing

    def _determine_order(self, first_pair, second_pair):
        if first_pair[1].speed > second_pair[1].speed:
            return first_pair, second_pair
        elif first_pair[1].speed < second_pair[1].speed:
            return second_pair, first_pair
        else:
            return random.sample([first_pair, second_pair], 2)

    def _calculate_damage(self, attacker, defender, skill):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        # Apply type effectiveness
        type_factor = self._get_type_effectiveness(skill.skill_type, defender.creature_type)
        
        return int(raw_damage * type_factor)

    def _get_type_effectiveness(self, skill_type, defender_type):
        if skill_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(skill_type, {}).get(defender_type, 1.0)
```

The key changes are:
1. Removed the `reset()` method from Creature class to keep it as a pure data model
2. Added `_reset_creature()` helper method in MainGameScene to handle resetting creature HP
3. Updated the battle end code to use `_reset_creature()` instead of calling reset() on the creatures directly

This maintains the separation between data models and logic while preserving the same functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
