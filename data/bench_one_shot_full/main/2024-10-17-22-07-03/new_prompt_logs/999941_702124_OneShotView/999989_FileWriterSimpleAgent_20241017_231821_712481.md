Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for providing the detailed information and requirements. I'll explain the architecture and implementation approach, and then provide the updated code for the MainGameSceneView component.

Architecture and Implementation Approach:

1. Component Structure:
   We'll create a main container div that takes up the entire 16:9 game container. Inside this, we'll have two main sections:
   - Battlefield Display (upper 2/3)
   - User Interface (lower 1/3)

2. Battlefield Display:
   We'll use a grid layout with four areas for:
   - Player creature (bottom-left)
   - Player creature status (bottom-right)
   - Opponent creature (top-right)
   - Opponent creature status (top-left)

3. User Interface:
   We'll create a section for buttons and messages. When buttons are available, we'll display them in a 2x2 grid.

4. Custom Components:
   We'll use the provided custom components (CreatureCard, PlayerCard, SkillButton) to display the relevant data.

5. Tailwind Styles:
   We'll use Tailwind classes for layout, sizing, and positioning. For example:
   - `h-screen w-screen` for full-screen container
   - `grid grid-cols-2 grid-rows-2` for the battlefield layout
   - `flex flex-col` for vertical stacking
   - `justify-center items-center` for centering content

6. Data Handling:
   We'll create interfaces for the game data structure and use optional chaining and nullish coalescing to handle potential missing data safely.

7. Button Handling:
   We'll use the `availableButtonSlugs` and `emitButtonClick` from `useCurrentButtons` to display and handle button interactions.

Now, let's implement the MainGameSceneView component:

# Excerpt ID: 0119f511-1c0e-44c6-b84d-91c6ee32c73b
```tsx main_game/templates/MainGameScene.tsx
import { useCurrentButtons, useThingInteraction } from "@/lib/useChoices.ts";
import { Sword, RefreshCw } from 'lucide-react'
import { CreatureCard } from "@/components/ui/custom/creature/creature_card";
import { PlayerCard } from "@/components/ui/custom/player/player_card";
import { SkillButton } from "@/components/ui/custom/skill/skill_button";
import { Button } from "@/components/ui/button";

interface Creature {
  uid: string;
  display_name: string;
  stats: {
    hp: number;
    max_hp: number;
  };
  meta: {
    creature_type: string;
  };
}

interface Player {
  uid: string;
  display_name: string;
  collections: {
    creatures: Creature[];
  };
}

interface GameUIData {
  entities: {
    player: Player;
    opponent: Player;
  };
}

export function MainGameSceneView(props: { data: GameUIData }) {
  const { availableButtonSlugs, emitButtonClick } = useCurrentButtons();
  const { enabledUIDs } = useThingInteraction();

  const playerCreature = props.data.entities.player.collections.creatures[0];
  const opponentCreature = props.data.entities.opponent.collections.creatures[0];

  return (
    <div className="h-screen w-screen flex flex-col">
      {/* Battlefield Display */}
      <div className="h-2/3 grid grid-cols-2 grid-rows-2 gap-4 p-4">
        {/* Opponent Status */}
        <div className="row-start-1 col-start-1 flex justify-start items-start">
          {opponentCreature && (
            <CreatureCard
              uid={opponentCreature.uid}
              name={opponentCreature.display_name}
              image={`/images/creatures/${opponentCreature.meta.creature_type}.png`}
              hp={opponentCreature.stats.hp}
              maxHp={opponentCreature.stats.max_hp}
            />
          )}
        </div>

        {/* Opponent Creature */}
        <div className="row-start-1 col-start-2 flex justify-end items-start">
          <PlayerCard
            uid={props.data.entities.opponent.uid}
            playerName={props.data.entities.opponent.display_name}
            imageUrl="/images/opponent.png"
          />
        </div>

        {/* Player Creature */}
        <div className="row-start-2 col-start-1 flex justify-start items-end">
          <PlayerCard
            uid={props.data.entities.player.uid}
            playerName={props.data.entities.player.display_name}
            imageUrl="/images/player.png"
          />
        </div>

        {/* Player Status */}
        <div className="row-start-2 col-start-2 flex justify-end items-end">
          {playerCreature && (
            <CreatureCard
              uid={playerCreature.uid}
              name={playerCreature.display_name}
              image={`/images/creatures/${playerCreature.meta.creature_type}.png`}
              hp={playerCreature.stats.hp}
              maxHp={playerCreature.stats.max_hp}
            />
          )}
        </div>
      </div>

      {/* User Interface */}
      <div className="h-1/3 bg-gray-100 p-4">
        <div className="grid grid-cols-2 gap-4">
          {availableButtonSlugs.includes('attack') && (
            <SkillButton
              uid="attack-button"
              skillName="Attack"
              description="Perform a basic attack"
              stats="Damage: 5"
              onClick={() => emitButtonClick('attack')}
            >
              <Sword className="mr-2 h-4 w-4" /> Attack
            </SkillButton>
          )}
          {availableButtonSlugs.includes('swap') && (
            <Button
              onClick={() => emitButtonClick('swap')}
            >
              <RefreshCw className="mr-2 h-4 w-4" /> Swap Creature
            </Button>
          )}
          {/* Add more buttons here as needed */}
        </div>
      </div>
    </div>
  );
}
```

This implementation creates a full-screen layout with the battlefield display in the upper 2/3 and the user interface in the lower 1/3. It uses the custom components as specified and implements the required button choices. The component is also designed to handle potential missing data safely.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "0119f511-1c0e-44c6-b84d-91c6ee32c73b", "file_path": "main_game/templates/MainGameScene.tsx"}]
```
__________________
