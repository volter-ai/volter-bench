Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The error occurs because main.py is trying to import MainGameScene but the file main_game_scene.py hasn't been created yet. We need to implement the MainGameScene class that handles the battle logic.

The scene needs to:
- Initialize with both players (human and bot)
- Handle turn phases (player choice, foe choice, resolution)
- Calculate damage based on type effectiveness
- Handle creature swapping and KOs

2. Here's the implementation of main_game_scene.py:

# Excerpt ID: d67e18fa-304a-4901-9c02-839f4f89c57c
```python main_game/scenes/main_game_scene.py
from typing import List, Optional
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing, DictionaryChoice
from main_game.models import Player, Creature, Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        # Initialize active creatures
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]
        # Reset creature HPs
        for creature in self.player.creatures + self.bot.creatures:
            creature.hp = creature.max_hp

    def __str__(self):
        player_creatures_status = "\n".join(
            f"{c.display_name}: {c.hp}/{c.max_hp} HP" 
            for c in self.player.creatures
        )
        bot_creatures_status = "\n".join(
            f"{c.display_name}: {c.hp}/{c.max_hp} HP" 
            for c in self.bot.creatures
        )
        return f"""=== Battle ===
Your Active Creature: {self.player.active_creature.display_name} ({self.player.active_creature.hp}/{self.player.active_creature.max_hp} HP)
Foe's Active Creature: {self.bot.active_creature.display_name} ({self.bot.active_creature.hp}/{self.bot.active_creature.max_hp} HP)

Your Team:
{player_creatures_status}

Foe's Team:
{bot_creatures_status}
"""

    def _calculate_damage(self, attacker: Creature, defender: Creature, skill: Skill) -> int:
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        # Type effectiveness multiplier
        multiplier = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf":
                multiplier = 2.0
            elif defender.creature_type == "water":
                multiplier = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire":
                multiplier = 2.0
            elif defender.creature_type == "leaf":
                multiplier = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water":
                multiplier = 2.0
            elif defender.creature_type == "fire":
                multiplier = 0.5

        return int(raw_damage * multiplier)

    def _get_available_creatures(self, player: Player) -> List[Creature]:
        return [c for c in player.creatures if c.hp > 0 and c != player.active_creature]

    def _handle_turn(self, first_player: Player, second_player: Player):
        # Get actions from both players
        first_action = self._get_player_action(first_player)
        second_action = self._get_player_action(second_player)

        # Handle swaps first
        if isinstance(first_action, Creature):
            first_player.active_creature = first_action
        if isinstance(second_action, Creature):
            second_player.active_creature = second_action

        # Handle attacks
        if isinstance(first_action, Skill):
            damage = self._calculate_damage(first_player.active_creature, second_player.active_creature, first_action)
            second_player.active_creature.hp -= damage
            self._show_text(first_player, f"{first_player.active_creature.display_name} used {first_action.display_name}!")
            self._show_text(second_player, f"{first_player.active_creature.display_name} used {first_action.display_name}!")

        if isinstance(second_action, Skill) and second_player.active_creature.hp > 0:
            damage = self._calculate_damage(second_player.active_creature, first_player.active_creature, second_action)
            first_player.active_creature.hp -= damage
            self._show_text(first_player, f"{second_player.active_creature.display_name} used {second_action.display_name}!")
            self._show_text(second_player, f"{second_player.active_creature.display_name} used {second_action.display_name}!")

    def _get_player_action(self, player: Player) -> Skill | Creature:
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        
        choice = self._wait_for_choice(player, [attack_button, swap_button])
        
        if choice == attack_button:
            # Show skills
            skill_choices = [SelectThing(skill) for skill in player.active_creature.skills]
            skill_choice = self._wait_for_choice(player, skill_choices)
            return skill_choice.thing
        else:
            # Show available creatures
            creature_choices = [SelectThing(c) for c in self._get_available_creatures(player)]
            creature_choice = self._wait_for_choice(player, creature_choices)
            return creature_choice.thing

    def _handle_knockouts(self, player: Player):
        if player.active_creature.hp <= 0:
            available = self._get_available_creatures(player)
            if not available:
                return False
            
            creature_choices = [SelectThing(c) for c in available]
            choice = self._wait_for_choice(player, creature_choices)
            player.active_creature = choice.thing
            
        return True

    def run(self):
        while True:
            # Determine turn order based on speed
            if self.player.active_creature.speed >= self.bot.active_creature.speed:
                self._handle_turn(self.player, self.bot)
            else:
                self._handle_turn(self.bot, self.player)

            # Check for knockouts
            player_can_continue = self._handle_knockouts(self.player)
            bot_can_continue = self._handle_knockouts(self.bot)

            if not player_can_continue:
                self._show_text(self.player, "You lost the battle!")
                break
            elif not bot_can_continue:
                self._show_text(self.player, "You won the battle!")
                break

        self._transition_to_scene("MainMenuScene")
```

This implementation:
1. Follows the engine's architecture by using AbstractGameScene
2. Uses the proper choice mechanisms (Button, SelectThing)
3. Implements all battle mechanics from the requirements
4. Properly handles turn order based on speed
5. Calculates damage according to the formulas
6. Handles creature swapping and knockouts
7. Returns to main menu when battle ends

The scene integrates with the existing models and uses them as pure data schemas without adding methods to them.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
