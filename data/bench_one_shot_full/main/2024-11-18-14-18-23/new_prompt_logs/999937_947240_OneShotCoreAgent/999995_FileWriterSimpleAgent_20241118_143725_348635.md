Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis and Solution:

The error occurs because I added methods (`reset()`) to the data models in `models.py`. According to the guidelines, models must be pure data schemas without methods or properties. The reset functionality should be moved to the scenes.

The fix involves:
1. Remove all methods from models.py
2. Move the reset logic to MainGameScene
3. Keep models as pure data schemas with just attributes
4. Handle all creature/player state management in the scene

2. Here's the fixed models.py:

# Excerpt ID: 2ca2452c-323a-45eb-82ef-9207ce2c1991
```python main_game/models.py
from __future__ import annotations
from typing import List
from mini_game_engine.engine.lib import AbstractPlayer, AbstractThing, Collection

class Skill(AbstractThing):
    category: str = "Skill"
    skill_type: str
    is_physical: bool 
    base_damage: int

class Creature(AbstractThing):
    category: str = "Creature"
    creature_type: str
    hp: int
    max_hp: int
    attack: int
    defense: int
    sp_attack: int
    sp_defense: int
    speed: int
    skills: Collection[Skill]

class Player(AbstractPlayer):
    category: str = "Player"
    creatures: Collection[Creature]
    active_creature: Creature = None
```

And the corresponding changes needed in MainGameScene:

# Excerpt ID: 937cfdce-03d6-4ed0-97c4-9ba3c44667e0
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        self.reset_player(self.player)
        self.reset_player(self.bot)

    def reset_player(self, player):
        """Reset a player's creatures to full health and set initial active creature"""
        for creature in player.creatures:
            creature.hp = creature.max_hp
        player.active_creature = player.creatures[0]

    def __str__(self):
        p_creature = self.player.active_creature
        b_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {p_creature.display_name}: {p_creature.hp}/{p_creature.max_hp} HP
Foe's {b_creature.display_name}: {b_creature.hp}/{b_creature.max_hp} HP

> Attack
> Swap
"""

    def run(self):
        self._show_text(self.player, "Battle Start!")
        
        while True:
            # Player turn
            player_action = self.get_player_action(self.player)
            bot_action = self.get_player_action(self.bot)
            
            # Resolve actions
            self.resolve_turn(player_action, bot_action)
            
            # Check for battle end
            if self.check_battle_end():
                break

    def get_player_action(self, player):
        while True:
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choice = self._wait_for_choice(player, [attack_button, swap_button])
            
            if choice == attack_button:
                skills = [SelectThing(skill) for skill in player.active_creature.skills]
                back_button = Button("Back")
                skill_choice = self._wait_for_choice(player, skills + [back_button])
                
                if skill_choice != back_button:
                    return ("attack", skill_choice.thing)
                    
            else:
                available_creatures = [
                    SelectThing(c) for c in player.creatures 
                    if c != player.active_creature and c.hp > 0
                ]
                if available_creatures:
                    back_button = Button("Back")
                    swap_choice = self._wait_for_choice(player, available_creatures + [back_button])
                    
                    if swap_choice != back_button:
                        return ("swap", swap_choice.thing)

    def resolve_turn(self, player_action, bot_action):
        actions = [(self.player, player_action), (self.bot, bot_action)]
        
        # Handle swaps first
        for player, action in actions:
            if action[0] == "swap":
                self._show_text(player, f"{player.display_name} swaps to {action[1].display_name}!")
                player.active_creature = action[1]
        
        # Then handle attacks
        random.shuffle(actions)  # Randomize same-speed ties
        actions.sort(key=lambda x: x[0].active_creature.speed, reverse=True)
        
        for player, action in actions:
            if action[0] == "attack":
                skill = action[1]
                attacker = player.active_creature
                defender = self.bot.active_creature if player == self.player else self.player.active_creature
                
                damage = self.calculate_damage(skill, attacker, defender)
                defender.hp = max(0, defender.hp - damage)
                
                self._show_text(player, f"{attacker.display_name} uses {skill.display_name}!")
                self._show_text(player, f"Deals {damage} damage!")
                
                if defender.hp == 0:
                    self._show_text(player, f"{defender.display_name} is knocked out!")
                    self.handle_knockout(defender)

    def calculate_damage(self, skill, attacker, defender):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Apply type effectiveness
        effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        
        return int(raw_damage * effectiveness)

    def get_type_effectiveness(self, attack_type, defend_type):
        if attack_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(attack_type, {}).get(defend_type, 1.0)

    def handle_knockout(self, defender):
        player = self.player if defender in self.player.creatures else self.bot
        available_creatures = [c for c in player.creatures if c.hp > 0]
        
        if available_creatures:
            choices = [SelectThing(c) for c in available_creatures]
            self._show_text(player, "Choose next creature!")
            choice = self._wait_for_choice(player, choices)
            player.active_creature = choice.thing
            self._show_text(player, f"Go, {choice.thing.display_name}!")

    def check_battle_end(self):
        player_alive = any(c.hp > 0 for c in self.player.creatures)
        bot_alive = any(c.hp > 0 for c in self.bot.creatures)
        
        if not player_alive or not bot_alive:
            winner = self.player if player_alive else self.bot
            self._show_text(self.player, f"{winner.display_name} wins!")
            self._transition_to_scene("MainMenuScene")
            return True
            
        return False
```

The key changes are:
1. Removed all methods from the model classes
2. Added reset_player() method to MainGameScene to handle creature state initialization
3. Models are now pure data schemas
4. All game logic remains in the scene

This maintains the separation between data and logic while preserving all the game functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
