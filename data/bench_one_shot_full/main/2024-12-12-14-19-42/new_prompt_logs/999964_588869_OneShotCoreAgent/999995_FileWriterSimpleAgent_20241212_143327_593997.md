Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The error occurs because MainGameScene ends without properly transitioning or quitting. When a battle ends, we just break from the loop instead of calling `_quit_whole_game()` or `_transition_to_scene()`. According to the engine's requirements, every scene must explicitly end with one of these calls.

The fix is simple: in MainGameScene, after a battle ends, we should:
1. Show the battle result message
2. Return to MainMenuScene if the player wants to play again
3. Or quit the whole game if they don't

2. Here's the fixed MainGameScene:

# Excerpt ID: 60e74835-4424-4e4d-bb16-ce35b1f2c389
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, SelectThing, Button
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        
    def __str__(self):
        return f"""=== Battle ===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available Skills:
{[skill.display_name for skill in self.player_creature.skills]}
"""

    def run(self):
        while True:
            # Player phase
            player_skill = self._get_skill_choice(self.player, self.player_creature)
            
            # Opponent phase  
            opponent_skill = self._get_skill_choice(self.opponent, self.opponent_creature)

            # Resolution phase
            first, second = self._determine_order(
                (self.player, self.player_creature, player_skill),
                (self.opponent, self.opponent_creature, opponent_skill)
            )

            # Execute skills
            self._execute_skill(*first)
            if self._check_battle_end():
                self._handle_game_end()
                return

            if self.player_creature.hp > 0 and self.opponent_creature.hp > 0:
                self._execute_skill(*second)
                if self._check_battle_end():
                    self._handle_game_end()
                    return

    def _get_skill_choice(self, player, creature):
        choices = [SelectThing(skill) for skill in creature.skills]
        return self._wait_for_choice(player, choices).thing

    def _determine_order(self, action1, action2):
        p1, c1, _ = action1
        p2, c2, _ = action2
        
        if c1.speed > c2.speed:
            return action1, action2
        elif c2.speed > c1.speed:
            return action2, action1
        else:
            return (action1, action2) if random.random() < 0.5 else (action2, action1)

    def _calculate_damage(self, attacker, skill, defender):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        
        # Type effectiveness
        factor = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf": factor = 2.0
            elif defender.creature_type == "water": factor = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire": factor = 2.0
            elif defender.creature_type == "leaf": factor = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water": factor = 2.0
            elif defender.creature_type == "fire": factor = 0.5

        return int(raw_damage * factor)

    def _execute_skill(self, attacker, attacker_creature, skill):
        if attacker == self.player:
            defender = self.opponent
            defender_creature = self.opponent_creature
        else:
            defender = self.player
            defender_creature = self.player_creature

        damage = self._calculate_damage(attacker_creature, skill, defender_creature)
        defender_creature.hp = max(0, defender_creature.hp - damage)
        
        self._show_text(self.player, f"{attacker_creature.display_name} used {skill.display_name}!")
        self._show_text(self.player, f"It dealt {damage} damage!")

    def _check_battle_end(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name} lost the battle!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"{self.player.display_name} won the battle!")
            return True
        return False

    def _handle_game_end(self):
        play_again = Button("Play Again")
        quit_button = Button("Quit")
        choice = self._wait_for_choice(self.player, [play_again, quit_button])
        
        if choice == play_again:
            self._transition_to_scene("MainMenuScene")
        else:
            self._quit_whole_game()
```

The key changes are:
1. Added `_handle_game_end()` method that properly handles scene transitions
2. Modified the battle loop to call `_handle_game_end()` when battle ends
3. Ensured the scene always ends with either `_transition_to_scene()` or `_quit_whole_game()`

This maintains the engine's architecture while properly handling scene transitions.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
