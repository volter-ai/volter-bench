Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
I understand the issues raised during QA/testing. I'll address each point and propose a solution that aligns with the described architecture and stays within the capabilities of the engine.

1. How to fix the issues:

a) Add a 'Back' option in the Player Choice Phase.
b) Implement explicit handling of action order based on speed and prioritize swaps over skills.
c) Call the 'force_swap' method when a creature is knocked out.
d) Implement resetting the state of the player's creatures when leaving the scene.

These changes will be made in the `MainGameScene` class. We'll modify the existing methods and add new ones to address these issues.

2. Here's the rewritten `main_game_scene.py` file with the proposed solution:

# Excerpt ID: 46b96240-61c2-4aa2-9ef5-093e9a27c29c
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}: {self.player.active_creature.display_name} (HP: {self.player.active_creature.hp}/{self.player.active_creature.max_hp})
{self.opponent.display_name}: {self.opponent.active_creature.display_name} (HP: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp})

> Attack
> Swap
"""

    def run(self):
        while True:
            player_action = self.get_player_action(self.player)
            opponent_action = self.get_player_action(self.opponent)
            
            self.resolve_actions(player_action, opponent_action)
            
            if self.check_battle_end():
                self.end_battle()
                return

    def get_player_action(self, current_player):
        while True:
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            back_button = Button("Back")
            choices = [attack_button, swap_button, back_button]
            choice = self._wait_for_choice(current_player, choices)

            if choice == attack_button:
                action = self.choose_attack(current_player)
                if action:
                    return action
            elif choice == swap_button:
                action = self.choose_swap(current_player)
                if action:
                    return action
            elif choice == back_button:
                continue

    def choose_attack(self, current_player):
        choices = [SelectThing(skill) for skill in current_player.active_creature.skills]
        choices.append(Button("Back"))
        choice = self._wait_for_choice(current_player, choices)
        if isinstance(choice, Button) and choice.display_name == "Back":
            return None
        return choice

    def choose_swap(self, current_player):
        valid_creatures = [creature for creature in current_player.creatures if creature != current_player.active_creature and creature.hp > 0]
        if not valid_creatures:
            self._show_text(current_player, "No valid creatures to swap to.")
            return None
        choices = [SelectThing(creature) for creature in valid_creatures]
        choices.append(Button("Back"))
        choice = self._wait_for_choice(current_player, choices)
        if isinstance(choice, Button) and choice.display_name == "Back":
            return None
        return choice

    def resolve_actions(self, player_action, opponent_action):
        actions = [(self.player, player_action), (self.opponent, opponent_action)]
        
        # Prioritize swaps
        swaps = [action for action in actions if isinstance(action[1].thing, Creature)]
        for player, action in swaps:
            self.execute_swap(player, action.thing)
        
        # Execute attacks based on speed
        attacks = [action for action in actions if isinstance(action[1].thing, Skill)]
        attacks.sort(key=lambda x: x[0].active_creature.speed, reverse=True)
        
        for attacker, action in attacks:
            defender = self.opponent if attacker == self.player else self.player
            self.execute_attack(attacker, defender, action.thing)
            if self.check_knockout(defender):
                if not self.force_swap(defender):
                    break

    def execute_attack(self, attacker, defender, skill):
        damage = self.calculate_damage(attacker.active_creature, defender.active_creature, skill)
        defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
        self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(defender, f"{defender.active_creature.display_name} took {damage} damage!")

    def execute_swap(self, player, new_creature):
        player.active_creature = new_creature
        self._show_text(player, f"{player.display_name} swapped to {new_creature.display_name}!")

    def calculate_damage(self, attacker, defender, skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_factor = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(type_factor * raw_damage)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def get_type_effectiveness(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def check_knockout(self, player):
        return player.active_creature.hp == 0

    def force_swap(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if not available_creatures:
            return False
        choices = [SelectThing(creature) for creature in available_creatures]
        new_creature = self._wait_for_choice(player, choices).thing
        player.active_creature = new_creature
        self._show_text(player, f"{player.display_name} swapped to {new_creature.display_name}!")
        return True

    def check_battle_end(self):
        if all(creature.hp == 0 for creature in self.player.creatures):
            self._show_text(self.player, "You lost the battle!")
            return True
        elif all(creature.hp == 0 for creature in self.opponent.creatures):
            self._show_text(self.player, "You won the battle!")
            return True
        return False

    def end_battle(self):
        self._show_text(self.player, "Battle ended. Returning to main menu.")
        self.reset_creatures_state()
        self._transition_to_scene("MainMenuScene")

    def reset_creatures_state(self):
        for player in [self.player, self.opponent]:
            for creature in player.creatures:
                creature.hp = creature.max_hp
```

This solution addresses all the issues raised:

1. Added a 'Back' option in the Player Choice Phase, allowing players to return to the main choice menu.
2. Implemented explicit handling of action order based on speed and prioritized swaps over skills in the `resolve_actions` method.
3. Called the `force_swap` method when a creature is knocked out in the `resolve_actions` method.
4. Implemented `reset_creatures_state` method to reset the state of the player's creatures when leaving the scene, called in the `end_battle` method.

These changes align with the described architecture and stay within the capabilities of the engine while addressing all the issues raised during QA/testing.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "46b96240-61c2-4aa2-9ef5-093e9a27c29c", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
