Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for providing the detailed information and requirements. I'll outline the architecture and implementation approach for the MainGameSceneView component, and then proceed to rewrite the code.

Architecture and Implementation Approach:

1. Component Structure:
   - MainGameSceneView (main component)
     - BattlefieldDisplay (upper 2/3 of the screen)
       - PlayerCreature
       - PlayerCreatureStatus
       - OpponentCreature
       - OpponentCreatureStatus
     - UserInterface (lower 1/3 of the screen)
       - MessageDisplay
       - ButtonGrid

2. Styling:
   We'll use Tailwind CSS for inline styling to create the layout and design. We'll utilize flexbox and grid layouts to achieve the desired structure.

3. Data Handling:
   We'll create interfaces for the main data structures (Player, Creature, Skill) to ensure type safety and easier data manipulation.

4. Custom Components:
   We'll use the provided custom components (SkillButton, PlayerCard, CreatureCard) to display the relevant data.

5. Responsive Design:
   We'll use Tailwind's responsive classes to ensure the game fits within the 16:9 game container and adapts to different screen sizes.

6. Button Handling:
   We'll use the availableButtonSlugs and emitButtonClick from useCurrentButtons to manage button visibility and interactions.

Now, let's implement the component:

# Excerpt ID: e41921ca-67ce-413e-af3b-21b41cc37c78
```tsx main_game/templates/MainGameScene.tsx
import { useCurrentButtons } from "@/lib/useChoices.ts";
import { Sword, ArrowLeft } from 'lucide-react'
import { SkillButton } from "@/components/ui/custom/skill/skill_button";
import { PlayerCard } from "@/components/ui/custom/player/player_card";
import { CreatureCard, Progress } from "@/components/ui/custom/creature/creature_card";

interface Skill {
  __type: "Skill";
  stats: { base_damage: number };
  meta: { skill_type: string; is_physical: boolean };
  uid: string;
  display_name: string;
  description: string;
}

interface Creature {
  __type: "Creature";
  stats: {
    hp: number;
    max_hp: number;
    attack: number;
    defense: number;
    sp_attack: number;
    sp_defense: number;
    speed: number;
  };
  meta: { creature_type: string };
  collections: { skills: Skill[] };
  uid: string;
  display_name: string;
  description: string;
}

interface Player {
  __type: "Player";
  collections: { creatures: Creature[] };
  uid: string;
  display_name: string;
  description: string;
}

interface GameUIData {
  entities: {
    player: Player;
    opponent: Player;
    player_creature: Creature;
    opponent_creature: Creature;
  };
  meta: { battle_ended: boolean };
}

export function MainGameSceneView(props: { data: GameUIData }) {
  const { availableButtonSlugs, emitButtonClick } = useCurrentButtons();

  const { player_creature, opponent_creature } = props.data.entities;

  return (
    <div className="w-full h-full flex flex-col" style={{ aspectRatio: '16/9' }}>
      {/* Battlefield Display */}
      <div className="flex-grow flex">
        {/* Opponent Creature */}
        <div className="w-1/2 flex flex-col items-center justify-start p-4">
          <CreatureCard
            uid={opponent_creature.uid}
            name={opponent_creature.display_name}
            image={`/images/creatures/${opponent_creature.meta.creature_type}.png`}
            hp={opponent_creature.stats.hp}
            maxHp={opponent_creature.stats.max_hp}
          />
        </div>
        {/* Player Creature */}
        <div className="w-1/2 flex flex-col items-center justify-end p-4">
          <CreatureCard
            uid={player_creature.uid}
            name={player_creature.display_name}
            image={`/images/creatures/${player_creature.meta.creature_type}_back.png`}
            hp={player_creature.stats.hp}
            maxHp={player_creature.stats.max_hp}
          />
        </div>
      </div>

      {/* User Interface */}
      <div className="h-1/3 bg-gray-100 p-4">
        <div className="grid grid-cols-2 gap-4">
          {availableButtonSlugs.includes('use-skill') && player_creature.collections.skills.map((skill) => (
            <SkillButton
              key={skill.uid}
              uid={skill.uid}
              skillName={skill.display_name}
              description={skill.description}
              stats={`Damage: ${skill.stats.base_damage}, Type: ${skill.meta.skill_type}`}
              onClick={() => emitButtonClick('use-skill', { skillId: skill.uid })}
            >
              <Sword className="mr-2 h-4 w-4" />
              {skill.display_name}
            </SkillButton>
          ))}
          {availableButtonSlugs.includes('return-to-main-menu') && (
            <SkillButton
              uid="return-to-main-menu"
              skillName="Return to Main Menu"
              description="Go back to the main menu"
              stats=""
              onClick={() => emitButtonClick('return-to-main-menu')}
            >
              <ArrowLeft className="mr-2 h-4 w-4" />
              Return to Main Menu
            </SkillButton>
          )}
        </div>
      </div>
    </div>
  );
}
```

This implementation creates a layout that matches the description in the VIEW_SUMMARY. It uses Tailwind CSS for styling and incorporates the custom components as required. The component is responsive and will fit within a 16:9 container. 

The battlefield display shows the opponent's creature at the top and the player's creature at the bottom, each with their respective CreatureCard. The user interface at the bottom displays skill buttons when available, and a "Return to Main Menu" button when that option is available.

The component handles potential missing data by using optional chaining and only rendering elements when the corresponding data is available. It also uses the custom components as specified, passing the required props including the uid.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "e41921ca-67ce-413e-af3b-21b41cc37c78", "file_path": "main_game/templates/MainGameScene.tsx"}]
```
__________________
