Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issue, we need to modify the `MainGameScene` class to properly handle the end of the battle and transition back to the `MainMenuScene` or quit the game. The main problem is that the scene is terminating without calling `_transition_to_scene` or `_quit_whole_game`. Here's how we'll fix it:

1. We'll modify the `run` method to continue the game loop until the battle ends.
2. After the battle ends, we'll add a choice for the player to either return to the main menu or quit the game.
3. We'll implement these choices using `_transition_to_scene` and `_quit_whole_game` respectively.

Here's the proposed solution for the `main_game_scene.py` file:

# Excerpt ID: 457b64f2-e5c9-4843-80ea-5fe7acf13648
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]
        self.battle_ended = False

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}: {self.player.active_creature.display_name} (HP: {self.player.active_creature.hp}/{self.player.active_creature.max_hp})
{self.opponent.display_name}: {self.opponent.active_creature.display_name} (HP: {self.opponent.active_creature.hp}/{self.opponent.active_creature.max_hp})

> Attack
> Swap
"""

    def run(self):
        while not self.battle_ended:
            self.player_turn()
            if self.check_battle_end():
                break
            self.opponent_turn()
            if self.check_battle_end():
                break

        self.end_battle()

    def end_battle(self):
        main_menu_button = Button("Return to Main Menu")
        quit_button = Button("Quit Game")
        choices = [main_menu_button, quit_button]
        choice = self._wait_for_choice(self.player, choices)

        if choice == main_menu_button:
            self._transition_to_scene("MainMenuScene")
        elif choice == quit_button:
            self._quit_whole_game()

    def player_turn(self):
        action = self.get_player_action(self.player)
        if action:
            self.execute_action(self.player, self.opponent, action)

    def opponent_turn(self):
        action = self.get_player_action(self.opponent)
        if action:
            self.execute_action(self.opponent, self.player, action)

    def get_player_action(self, current_player):
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        choices = [attack_button, swap_button]
        choice = self._wait_for_choice(current_player, choices)

        if choice == attack_button:
            return self.choose_attack(current_player)
        elif choice == swap_button:
            swap_action = self.choose_swap(current_player)
            if swap_action is None:
                self._show_text(current_player, "No creatures available to swap!")
                return self.get_player_action(current_player)  # Retry action selection
            return swap_action

    def choose_attack(self, current_player):
        choices = [SelectThing(skill) for skill in current_player.active_creature.skills]
        return self._wait_for_choice(current_player, choices)

    def choose_swap(self, current_player):
        available_creatures = [creature for creature in current_player.creatures if creature != current_player.active_creature and creature.hp > 0]
        if not available_creatures:
            return None
        choices = [SelectThing(creature) for creature in available_creatures]
        return self._wait_for_choice(current_player, choices)

    def execute_action(self, attacker, defender, action):
        if isinstance(action.thing, Skill):
            self.execute_attack(attacker, defender, action.thing)
        elif isinstance(action.thing, Creature):
            self.execute_swap(attacker, action.thing)

    def execute_attack(self, attacker, defender, skill):
        damage = self.calculate_damage(attacker.active_creature, defender.active_creature, skill)
        defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
        self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(defender, f"{defender.active_creature.display_name} took {damage} damage!")

    def execute_swap(self, player, new_creature):
        player.active_creature = new_creature
        self._show_text(player, f"{player.display_name} swapped to {new_creature.display_name}!")

    def calculate_damage(self, attacker, defender, skill):
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_factor = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(type_factor * raw_damage)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def get_type_effectiveness(self, skill_type, defender_type):
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def check_battle_end(self):
        if all(creature.hp == 0 for creature in self.player.creatures):
            self._show_text(self.player, "You lost the battle!")
            self.battle_ended = True
            return True
        elif all(creature.hp == 0 for creature in self.opponent.creatures):
            self._show_text(self.player, "You won the battle!")
            self.battle_ended = True
            return True
        return False

    def force_swap(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
        if not available_creatures:
            return False
        choices = [SelectThing(creature) for creature in available_creatures]
        new_creature = self._wait_for_choice(player, choices).thing
        player.active_creature = new_creature
        self._show_text(player, f"{player.display_name} swapped to {new_creature.display_name}!")
        return True
```

This solution addresses the issue by:

1. Adding a `battle_ended` flag to track when the battle is over.
2. Modifying the `run` method to continue the game loop until `battle_ended` is True.
3. Implementing an `end_battle` method that provides the player with choices to return to the main menu or quit the game.
4. Using `_transition_to_scene` and `_quit_whole_game` to properly exit the scene.

These changes ensure that the `MainGameScene` always exits properly, either by transitioning back to the main menu or by quitting the game entirely. This should resolve the FixableException we were seeing in the tests and allow the game to flow correctly between scenes.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "457b64f2-e5c9-4843-80ea-5fe7acf13648", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
