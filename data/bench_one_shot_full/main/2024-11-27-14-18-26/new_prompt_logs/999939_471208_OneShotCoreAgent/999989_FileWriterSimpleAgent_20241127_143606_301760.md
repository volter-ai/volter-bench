Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The error occurs because MainGameScene is not registered but MainMenuScene is trying to transition to it. The fix is to:
- Create the MainGameScene class in a new file
- Register it in main.py
- Implement the battle logic according to the architecture docs
- Keep the scene transition in MainMenuScene

2. Here are the fixed files:

# Excerpt ID: 50383997-b382-408a-94b7-6c5f0de73ebc
```python main_game/scenes/main_game_scene.py
from typing import List, Dict, Tuple
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing, create_from_game_database
from main_game.models import Player, Creature, Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = self._app.create_bot("basic_opponent")
        
        # Initialize active creatures
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]

    def __str__(self):
        player_creature = self.player.active_creature
        bot_creature = self.bot.active_creature
        
        return f"""=== Battle Scene ===
Your {player_creature.display_name}: HP {player_creature.hp}/{player_creature.max_hp}
Foe's {bot_creature.display_name}: HP {bot_creature.hp}/{bot_creature.max_hp}

Your Actions:
> Attack
> Swap
"""

    def _calculate_damage(self, attacker: Creature, defender: Creature, skill: Skill) -> int:
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Calculate type multiplier
        multiplier = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf": multiplier = 2.0
            elif defender.creature_type == "water": multiplier = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire": multiplier = 2.0
            elif defender.creature_type == "leaf": multiplier = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water": multiplier = 2.0
            elif defender.creature_type == "fire": multiplier = 0.5
            
        return int(raw_damage * multiplier)

    def _get_available_creatures(self, player: Player) -> List[Creature]:
        return [c for c in player.creatures if c != player.active_creature and c.hp > 0]

    def _handle_fainted_creature(self, player: Player) -> bool:
        """Returns True if player can continue, False if they lost"""
        available = self._get_available_creatures(player)
        if not available:
            return False
            
        self._show_text(player, f"{player.active_creature.display_name} fainted! Choose a new creature!")
        choices = [SelectThing(c) for c in available]
        choice = self._wait_for_choice(player, choices)
        player.active_creature = choice.thing
        return True

    def _execute_turn(self, first: Tuple[Player, Skill], second: Tuple[Player, Skill]):
        for attacker, skill in [first, second]:
            if attacker.active_creature.hp <= 0:
                continue
                
            defender = self.bot if attacker == self.player else self.player
            damage = self._calculate_damage(attacker.active_creature, defender.active_creature, skill)
            defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
            
            self._show_text(self.player, 
                f"{attacker.active_creature.display_name} used {skill.display_name}! "
                f"Dealt {damage} damage to {defender.active_creature.display_name}!")
                
            if defender.active_creature.hp <= 0:
                if not self._handle_fainted_creature(defender):
                    self._show_text(self.player, 
                        f"{attacker.display_name} wins! {defender.display_name} has no creatures left!")
                    self._transition_to_scene("MainMenuScene")
                    return

    def run(self):
        while True:
            # Player turn
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choice = self._wait_for_choice(self.player, [attack_button, swap_button])
            
            player_action = None
            if choice == attack_button:
                skill_choices = [SelectThing(s) for s in self.player.active_creature.skills]
                skill_choice = self._wait_for_choice(self.player, skill_choices)
                player_action = skill_choice.thing
            else:
                available = self._get_available_creatures(self.player)
                if available:
                    creature_choices = [SelectThing(c) for c in available]
                    creature_choice = self._wait_for_choice(self.player, creature_choices)
                    self.player.active_creature = creature_choice.thing
                    self._show_text(self.player, f"Go, {self.player.active_creature.display_name}!")
                
            # Bot turn
            bot_action = self.bot.active_creature.skills[0]  # Simple AI - always uses first skill
            
            # Determine order and execute
            if player_action:  # If player attacked
                if self.player.active_creature.speed >= self.bot.active_creature.speed:
                    self._execute_turn((self.player, player_action), (self.bot, bot_action))
                else:
                    self._execute_turn((self.bot, bot_action), (self.player, player_action))
            else:  # If player swapped
                self._execute_turn((self.bot, bot_action), (None, None))
```

# Excerpt ID: 25737701-b759-4ff7-ad63-2063f8b1d099
```python main_game/main.py
import uuid

from mini_game_engine.engine.lib import HumanListener, AbstractApp, BotListener
from main_game.models import Player
from main_game.scenes.main_menu_scene import MainMenuScene
from main_game.scenes.main_game_scene import MainGameScene

class App(AbstractApp):
    def __init__(self):
        super().__init__()
        self.register_scene("MainMenuScene", MainMenuScene, is_entry_point=True)
        self.register_scene("MainGameScene", MainGameScene)

    def create_player(self, player_id: str):
        player = Player.from_prototype_id(prototype_id="default_player")
        player.uid = player_id
        player.set_listener(HumanListener())
        return player

    def create_bot(self, prototype_id: str):
        bot = Player.from_prototype_id(prototype_id=prototype_id)
        bot.uid = str(uuid.uuid4())
        bot.set_listener(BotListener())
        return bot

if __name__ == '__main__':
    app = App()
    app.run(app.create_player("just_a_guy"))
```

The key changes:
1. Created MainGameScene implementing the full battle system
2. Registered MainGameScene in App
3. Kept models as pure data schemas
4. Used proper engine patterns (SelectThing for choices, _show_text for messages)
5. Implemented all battle mechanics from the architecture docs

The scene handles:
- Turn-based combat with speed determining order
- Type effectiveness system
- Physical vs Special attacks
- Creature fainting and swapping
- Win/loss conditions

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
