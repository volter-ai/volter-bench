Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The error occurs in MainGameScene._execute_turn() when handling the second tuple (None, None) after a swap. The issue is that we're trying to check active_creature on None. We need to modify the _execute_turn method to properly handle the case where a player swapped instead of attacking.

The fix involves:
- Modifying _execute_turn to skip None entries entirely
- Keeping the pure data model approach
- Maintaining the battle mechanics as specified

2. Here's the fixed MainGameScene:

# Excerpt ID: cdadbc70-2514-4e22-9008-142d5510fc5c
```python main_game/scenes/main_game_scene.py
from typing import List, Dict, Tuple, Optional
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing, create_from_game_database
from main_game.models import Player, Creature, Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = self._app.create_bot("basic_opponent")
        
        # Initialize active creatures
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]

    def __str__(self):
        player_creature = self.player.active_creature
        bot_creature = self.bot.active_creature
        
        return f"""=== Battle Scene ===
Your {player_creature.display_name}: HP {player_creature.hp}/{player_creature.max_hp}
Foe's {bot_creature.display_name}: HP {bot_creature.hp}/{bot_creature.max_hp}

Your Actions:
> Attack
> Swap
"""

    def _calculate_damage(self, attacker: Creature, defender: Creature, skill: Skill) -> int:
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Calculate type multiplier
        multiplier = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf": multiplier = 2.0
            elif defender.creature_type == "water": multiplier = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire": multiplier = 2.0
            elif defender.creature_type == "leaf": multiplier = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water": multiplier = 2.0
            elif defender.creature_type == "fire": multiplier = 0.5
            
        return int(raw_damage * multiplier)

    def _get_available_creatures(self, player: Player) -> List[Creature]:
        return [c for c in player.creatures if c != player.active_creature and c.hp > 0]

    def _handle_fainted_creature(self, player: Player) -> bool:
        """Returns True if player can continue, False if they lost"""
        available = self._get_available_creatures(player)
        if not available:
            return False
            
        self._show_text(player, f"{player.active_creature.display_name} fainted! Choose a new creature!")
        choices = [SelectThing(c) for c in available]
        choice = self._wait_for_choice(player, choices)
        player.active_creature = choice.thing
        return True

    def _execute_turn(self, first: Tuple[Optional[Player], Optional[Skill]], second: Tuple[Optional[Player], Optional[Skill]]):
        for attacker, skill in [first, second]:
            if attacker is None or skill is None:
                continue
                
            if attacker.active_creature.hp <= 0:
                continue
                
            defender = self.bot if attacker == self.player else self.player
            damage = self._calculate_damage(attacker.active_creature, defender.active_creature, skill)
            defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
            
            self._show_text(self.player, 
                f"{attacker.active_creature.display_name} used {skill.display_name}! "
                f"Dealt {damage} damage to {defender.active_creature.display_name}!")
                
            if defender.active_creature.hp <= 0:
                if not self._handle_fainted_creature(defender):
                    self._show_text(self.player, 
                        f"{attacker.display_name} wins! {defender.display_name} has no creatures left!")
                    self._transition_to_scene("MainMenuScene")
                    return

    def run(self):
        while True:
            # Player turn
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choice = self._wait_for_choice(self.player, [attack_button, swap_button])
            
            player_action = None
            if choice == attack_button:
                skill_choices = [SelectThing(s) for s in self.player.active_creature.skills]
                skill_choice = self._wait_for_choice(self.player, skill_choices)
                player_action = skill_choice.thing
            else:
                available = self._get_available_creatures(self.player)
                if available:
                    creature_choices = [SelectThing(c) for c in available]
                    creature_choice = self._wait_for_choice(self.player, creature_choices)
                    self.player.active_creature = creature_choice.thing
                    self._show_text(self.player, f"Go, {self.player.active_creature.display_name}!")
                
            # Bot turn
            bot_action = self.bot.active_creature.skills[0]  # Simple AI - always uses first skill
            
            # Determine order and execute
            if player_action:  # If player attacked
                if self.player.active_creature.speed >= self.bot.active_creature.speed:
                    self._execute_turn((self.player, player_action), (self.bot, bot_action))
                else:
                    self._execute_turn((self.bot, bot_action), (self.player, player_action))
            else:  # If player swapped
                self._execute_turn((self.bot, bot_action), (None, None))
```

Key changes:
1. Added Optional type hints to _execute_turn parameters
2. Added explicit check for None before accessing attributes
3. Maintained pure data models approach
4. Kept all game logic in the scene
5. Fixed the swap action handling by properly skipping None entries

The fix ensures that when a player swaps creatures, we don't try to access attributes on None values while still maintaining the proper battle flow and game mechanics.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
