Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. The issue is that the MainGameScene is ending without properly transitioning or quitting. According to the engine architecture, scenes must always end with either:
- Calling `_transition_to_scene()` to go to another scene
- Calling `_quit_whole_game()` to end the game

In our case, when the battle ends (win or lose), we should return to the main menu or quit the game. I'll modify MainGameScene to transition back to MainMenuScene after showing the battle result.

2. Here's the fixed version:

# Excerpt ID: 01123ffd-3d27-4986-b4a1-0ed90b0736f4
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random
import math

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self.queued_skills = {}

    def __str__(self):
        return f"""=== Battle ===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available Skills:
{chr(10).join([f"> {skill.display_name}" for skill in self.player_creature.skills])}
"""

    def calculate_damage(self, attacker, defender, skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        
        type_multipliers = {
            ("fire", "leaf"): 2.0,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2.0,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2.0,
            ("leaf", "fire"): 0.5
        }
        
        multiplier = type_multipliers.get((skill.skill_type, defender.creature_type), 1.0)
        return int(raw_damage * multiplier)

    def execute_turn(self):
        creatures = [(self.player_creature, self.queued_skills[self.player.uid]), 
                    (self.opponent_creature, self.queued_skills[self.opponent.uid])]
        
        # Sort by speed, randomize if equal
        creatures.sort(key=lambda x: (x[0].speed, random.random()), reverse=True)
        
        for attacker, skill in creatures:
            if attacker == self.player_creature:
                defender = self.opponent_creature
                attacker_name = self.player.display_name
            else:
                defender = self.player_creature
                attacker_name = self.opponent.display_name
                
            damage = self.calculate_damage(attacker, defender, skill)
            defender.hp = max(0, defender.hp - damage)
            
            self._show_text(self.player, 
                f"{attacker_name}'s {attacker.display_name} used {skill.display_name}!")
            self._show_text(self.player, f"It dealt {damage} damage!")
            
            if defender.hp <= 0:
                return True
        return False

    def run(self):
        while True:
            # Player choice phase
            choices = [SelectThing(skill) for skill in self.player_creature.skills]
            player_choice = self._wait_for_choice(self.player, choices)
            self.queued_skills[self.player.uid] = player_choice.thing
            
            # Opponent choice phase
            opponent_choice = self._wait_for_choice(self.opponent, 
                [SelectThing(skill) for skill in self.opponent_creature.skills])
            self.queued_skills[self.opponent.uid] = opponent_choice.thing
            
            # Resolution phase
            battle_ended = self.execute_turn()
            
            if battle_ended:
                if self.player_creature.hp <= 0:
                    self._show_text(self.player, "You lost!")
                else:
                    self._show_text(self.player, "You won!")
                    
                # After showing battle result, give player choice to return to menu or quit
                continue_button = Button("Return to Main Menu")
                quit_button = Button("Quit Game")
                choice = self._wait_for_choice(self.player, [continue_button, quit_button])
                
                if choice == continue_button:
                    self._transition_to_scene("MainMenuScene")
                else:
                    self._quit_whole_game()
```

The key changes are:
1. After showing the battle result, we now present the player with two choices:
   - Return to Main Menu (transitions back to MainMenuScene)
   - Quit Game (calls quit_whole_game)
2. This ensures the scene always ends with a proper transition or quit, following the engine's architecture
3. The models remain unchanged as pure data schemas
4. We're still properly using the engine's capabilities for scene transitions and game flow

This should fix the test failure while maintaining the proper architecture and scene flow patterns required by the engine.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
