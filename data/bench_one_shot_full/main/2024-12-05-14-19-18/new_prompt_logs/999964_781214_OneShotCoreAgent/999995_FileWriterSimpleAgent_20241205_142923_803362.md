Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
The issue is that we're trying to use Player objects as dictionary keys in `self.queued_skills`, but AbstractThing objects cannot be used as dictionary keys (they raise FixableException when __hash__ is called). Instead, we should use the player's uid as the key.

The fix needs to be in main_game_scene.py. Here's the corrected version:

# Excerpt ID: 82d6e28b-8366-4164-8a5b-2127ff1584d6
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random
import math

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        # Use player UIDs as dictionary keys instead of player objects
        self.queued_skills = {}

    def __str__(self):
        return f"""=== Battle ===
{self.player.display_name}'s {self.player_creature.display_name}: HP {self.player_creature.hp}/{self.player_creature.max_hp}
{self.opponent.display_name}'s {self.opponent_creature.display_name}: HP {self.opponent_creature.hp}/{self.opponent_creature.max_hp}

Available Skills:
{chr(10).join([f"> {skill.display_name}" for skill in self.player_creature.skills])}
"""

    def calculate_damage(self, attacker, defender, skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        
        type_multipliers = {
            ("fire", "leaf"): 2.0,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2.0,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2.0,
            ("leaf", "fire"): 0.5
        }
        
        multiplier = type_multipliers.get((skill.skill_type, defender.creature_type), 1.0)
        return int(raw_damage * multiplier)

    def execute_turn(self):
        creatures = [(self.player_creature, self.queued_skills[self.player.uid]), 
                    (self.opponent_creature, self.queued_skills[self.opponent.uid])]
        
        # Sort by speed, randomize if equal
        creatures.sort(key=lambda x: (x[0].speed, random.random()), reverse=True)
        
        for attacker, skill in creatures:
            if attacker == self.player_creature:
                defender = self.opponent_creature
                attacker_name = self.player.display_name
            else:
                defender = self.player_creature
                attacker_name = self.opponent.display_name
                
            damage = self.calculate_damage(attacker, defender, skill)
            defender.hp = max(0, defender.hp - damage)
            
            self._show_text(self.player, 
                f"{attacker_name}'s {attacker.display_name} used {skill.display_name}!")
            self._show_text(self.player, f"It dealt {damage} damage!")
            
            if defender.hp <= 0:
                return True
        return False

    def run(self):
        while True:
            # Player choice phase
            choices = [SelectThing(skill) for skill in self.player_creature.skills]
            player_choice = self._wait_for_choice(self.player, choices)
            self.queued_skills[self.player.uid] = player_choice.thing
            
            # Opponent choice phase
            opponent_choice = self._wait_for_choice(self.opponent, 
                [SelectThing(skill) for skill in self.opponent_creature.skills])
            self.queued_skills[self.opponent.uid] = opponent_choice.thing
            
            # Resolution phase
            battle_ended = self.execute_turn()
            
            if battle_ended:
                if self.player_creature.hp <= 0:
                    self._show_text(self.player, "You lost!")
                else:
                    self._show_text(self.player, "You won!")
                return
```

The key changes are:
1. Using `self.player.uid` and `self.opponent.uid` as dictionary keys instead of the player objects themselves
2. Updated the execute_turn() method to use the UIDs when accessing queued_skills

This maintains the architecture and capabilities of the engine while fixing the hash issue. The models remain pure data schemas and we're properly using the unique identifiers (UIDs) that the engine provides.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
