Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis and Solution:
The error occurs because I added methods (`reset()`) to the data models, which violates the "pure data schemas" requirement. The models should only contain data fields, with all logic in scenes.

To fix this:
- Remove all methods from models
- Move the reset logic to the MainGameScene
- Initialize hp to max_hp in the JSON data
- Handle creature hp reset directly in the scene when needed

2. Here's the fixed models.py file:

# Excerpt ID: 0fb43455-4fa5-48d9-973e-33d6541f21f7
```python main_game/models.py
from __future__ import annotations
from typing import List, Optional
from mini_game_engine.engine.lib import AbstractThing, AbstractPlayer, Collection

class Skill(AbstractThing):
    category: str = "Skill"
    skill_type: str
    is_physical: bool
    base_damage: int

class Creature(AbstractThing):
    category: str = "Creature"
    creature_type: str
    hp: int
    max_hp: int 
    attack: int
    defense: int
    sp_attack: int
    sp_defense: int
    speed: int
    skills: Collection[Skill]

class Player(AbstractPlayer):
    category: str = "Player"
    creatures: Collection[Creature]
    active_creature: Optional[Creature] = None
```

And we need to modify the MainGameScene to handle the reset logic:

# Excerpt ID: 1e4988e6-df44-42f9-aea1-3b8d47650bba
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing, create_from_game_database
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        
        # Reset creatures by recreating them from prototypes
        self.player.creatures = [
            create_from_game_database(c.prototype_id, c.__class__) 
            for c in self.player.creatures
        ]
        self.bot.creatures = [
            create_from_game_database(c.prototype_id, c.__class__)
            for c in self.bot.creatures
        ]
        
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]

    def __str__(self):
        player_creature = self.player.active_creature
        bot_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {player_creature.display_name}: {player_creature.hp}/{player_creature.max_hp} HP
Foe's {bot_creature.display_name}: {bot_creature.hp}/{bot_creature.max_hp} HP

What will you do?
> Attack
> Swap"""

    def run(self):
        while True:
            # Player turn
            player_action = self.get_player_action(self.player)
            if not player_action:
                continue
                
            # Bot turn
            bot_action = self.get_bot_action(self.bot)
            
            # Resolve actions
            self.resolve_turn(player_action, bot_action)
            
            # Check for battle end
            if self.check_battle_end():
                # Reset creatures by recreating them before leaving
                self.player.creatures = [
                    create_from_game_database(c.prototype_id, c.__class__)
                    for c in self.player.creatures
                ]
                self.player.active_creature = None
                break

    def get_player_action(self, player):
        attack_button = Button("Attack")
        swap_button = Button("Swap")
        choice = self._wait_for_choice(player, [attack_button, swap_button])
        
        if choice == attack_button:
            return self.choose_attack(player)
        else:
            return self.choose_swap(player)

    def get_bot_action(self, bot):
        # Bot randomly chooses between attack and swap
        if random.random() < 0.8:  # 80% chance to attack
            return self.choose_attack(bot)
        return self.choose_swap(bot)

    def choose_attack(self, player):
        choices = [SelectThing(skill) for skill in player.active_creature.skills]
        back_button = Button("Back")
        choices.append(back_button)
        
        choice = self._wait_for_choice(player, choices)
        if choice == back_button:
            return None
        return ("attack", choice.thing)

    def choose_swap(self, player):
        available_creatures = [c for c in player.creatures 
                             if c != player.active_creature and c.hp > 0]
        if not available_creatures:
            self._show_text(player, "No other creatures available!")
            return None
            
        choices = [SelectThing(creature) for creature in available_creatures]
        back_button = Button("Back")
        choices.append(back_button)
        
        choice = self._wait_for_choice(player, choices)
        if choice == back_button:
            return None
        return ("swap", choice.thing)

    def resolve_turn(self, player_action, bot_action):
        # Handle swaps first
        if player_action[0] == "swap":
            self.player.active_creature = player_action[1]
            self._show_text(self.player, f"Go {player_action[1].display_name}!")
            
        if bot_action[0] == "swap":
            self.bot.active_creature = bot_action[1]
            self._show_text(self.player, f"Foe sent out {bot_action[1].display_name}!")

        # Then resolve attacks
        if player_action[0] == "attack" and bot_action[0] == "attack":
            # Determine order based on speed
            if self.player.active_creature.speed > self.bot.active_creature.speed:
                self.execute_attack(self.player, self.bot, player_action[1])
                if self.bot.active_creature.hp > 0:
                    self.execute_attack(self.bot, self.player, bot_action[1])
            else:
                self.execute_attack(self.bot, self.player, bot_action[1])
                if self.player.active_creature.hp > 0:
                    self.execute_attack(self.player, self.bot, player_action[1])

    def execute_attack(self, attacker, defender, skill):
        # Calculate damage
        if skill.is_physical:
            raw_damage = (attacker.active_creature.attack + 
                         skill.base_damage - 
                         defender.active_creature.defense)
        else:
            raw_damage = (attacker.active_creature.sp_attack / 
                         defender.active_creature.sp_defense * 
                         skill.base_damage)
            
        # Apply type effectiveness
        multiplier = self.get_type_multiplier(skill.skill_type, 
                                            defender.active_creature.creature_type)
        
        final_damage = int(raw_damage * multiplier)
        defender.active_creature.hp = max(0, defender.active_creature.hp - final_damage)
        
        self._show_text(self.player, 
                       f"{attacker.active_creature.display_name} used {skill.display_name}!")
        
        if multiplier > 1:
            self._show_text(self.player, "It's super effective!")
        elif multiplier < 1:
            self._show_text(self.player, "It's not very effective...")

    def get_type_multiplier(self, attack_type, defend_type):
        if attack_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(attack_type, {}).get(defend_type, 1.0)

    def check_battle_end(self):
        def has_available_creatures(player):
            return any(c.hp > 0 for c in player.creatures)
            
        if self.player.active_creature.hp <= 0:
            if not has_available_creatures(self.player):
                self._show_text(self.player, "You lost the battle!")
                return True
            self.force_swap(self.player)
            
        if self.bot.active_creature.hp <= 0:
            if not has_available_creatures(self.bot):
                self._show_text(self.player, "You won the battle!")
                return True
            self.force_swap(self.bot)
            
        return False

    def force_swap(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        choices = [SelectThing(creature) for creature in available_creatures]
        
        self._show_text(self.player, 
                       f"{player.active_creature.display_name} was knocked out!")
        
        choice = self._wait_for_choice(player, choices)
        player.active_creature = choice.thing
        self._show_text(self.player, 
                       f"Go {player.active_creature.display_name}!")
```

The key changes are:
1. Removed all methods from models
2. Handle creature reset by recreating them from prototypes using create_from_game_database
3. Reset creatures at the start and end of battle in the scene
4. Keep models as pure data schemas

This maintains the separation between data and logic while preserving all the game functionality.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
