Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
The issue is that the MainGameScene is ending without properly transitioning or quitting. According to the error message and engine requirements, every scene must either:
1. Transition to another scene using `_transition_to_scene()`, or
2. End the game using `_quit_whole_game()`

In our case, when the battle ends (win or lose), we should return to the main menu. If we're in random testing mode, we should quit the whole game to avoid infinite loops.

Here's the fixed MainGameScene:

# Excerpt ID: d3706812-c44d-49b3-ae33-c97b82be5473
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, SelectThing, Button, HumanListener
from main_game.models import Player, Creature

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        self.initialize_battle()

    def initialize_battle(self):
        # Reset creatures
        for creature in self.player.creatures:
            creature.hp = creature.max_hp
        for creature in self.bot.creatures:
            creature.hp = creature.max_hp
            
        # Set initial active creatures
        self.player.active_creature = self.player.creatures[0]
        self.bot.active_creature = self.bot.creatures[0]

    def __str__(self):
        return f"""=== Battle ===
Your {self.player.active_creature.display_name}: {self.player.active_creature.hp}/{self.player.active_creature.max_hp} HP
Foe's {self.bot.active_creature.display_name}: {self.bot.active_creature.hp}/{self.bot.active_creature.max_hp} HP

> Attack
> Swap"""

    def run(self):
        while True:
            if not self.has_valid_creatures(self.player) or not self.has_valid_creatures(self.bot):
                self.handle_battle_end()
                return

            # Player turn
            player_action = self.get_player_action(self.player)
            bot_action = self.get_player_action(self.bot)
            
            # Resolve actions
            self.resolve_turn(player_action, bot_action)

    def handle_battle_end(self):
        player_has_valid = self.has_valid_creatures(self.player)
        if not player_has_valid:
            self._show_text(self.player, "You lost the battle!")
        else:
            self._show_text(self.player, "You won the battle!")

        # In random mode (testing), quit the game
        # Otherwise return to main menu
        if isinstance(self.player._listener, HumanListener) and self.player._listener.random_mode:
            self._quit_whole_game()
        else:
            self._transition_to_scene("MainMenuScene")

    def has_valid_creatures(self, player):
        return any(c.hp > 0 for c in player.creatures)

    def get_player_action(self, player):
        if not player.active_creature or player.active_creature.hp <= 0:
            valid_creatures = [c for c in player.creatures if c.hp > 0]
            if valid_creatures:
                player.active_creature = valid_creatures[0]
                self._show_text(player, f"{player.active_creature.display_name} was sent out!")
                return {"type": "swap", "creature": player.active_creature}
            return {"type": "none"}

        attack_button = Button("Attack")
        swap_button = Button("Swap")
        
        choice = self._wait_for_choice(player, [attack_button, swap_button])
        
        if choice == attack_button:
            return self.get_attack_choice(player)
        else:
            # Check if swap is possible before attempting
            valid_creatures = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
            if valid_creatures:
                return self.get_swap_choice(player, valid_creatures)
            # If no valid creatures to swap to, default to attack
            return self.get_attack_choice(player)

    def get_attack_choice(self, player):
        choices = [SelectThing(skill) for skill in player.active_creature.skills]
        return {"type": "attack", "skill": self._wait_for_choice(player, choices).thing}

    def get_swap_choice(self, player, valid_creatures):
        choices = [SelectThing(creature) for creature in valid_creatures]
        return {"type": "swap", "creature": self._wait_for_choice(player, choices).thing}

    def resolve_turn(self, player_action, bot_action):
        if player_action["type"] == "none" or bot_action["type"] == "none":
            return

        # Handle swaps first
        if player_action["type"] == "swap":
            self.player.active_creature = player_action["creature"]
        if bot_action["type"] == "swap":
            self.bot.active_creature = bot_action["creature"]

        # Then handle attacks
        if player_action["type"] == "attack" and bot_action["type"] == "attack":
            # Determine order based on speed
            if self.player.active_creature.speed >= self.bot.active_creature.speed:
                self.execute_attack(self.player, self.bot, player_action["skill"])
                if self.bot.active_creature.hp > 0:
                    self.execute_attack(self.bot, self.player, bot_action["skill"])
            else:
                self.execute_attack(self.bot, self.player, bot_action["skill"])
                if self.player.active_creature.hp > 0:
                    self.execute_attack(self.player, self.bot, player_action["skill"])

    def execute_attack(self, attacker, defender, skill):
        # Calculate damage
        if skill.is_physical:
            raw_damage = attacker.active_creature.attack + skill.base_damage - defender.active_creature.defense
        else:
            raw_damage = (attacker.active_creature.sp_attack / defender.active_creature.sp_defense) * skill.base_damage

        # Apply type effectiveness
        multiplier = self.get_type_multiplier(skill.skill_type, defender.active_creature.creature_type)
        final_damage = int(raw_damage * multiplier)
        
        defender.active_creature.hp = max(0, defender.active_creature.hp - final_damage)
        
        self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(defender, f"It dealt {final_damage} damage!")

        if defender.active_creature.hp == 0:
            self._show_text(defender, f"{defender.active_creature.display_name} fainted!")

    def get_type_multiplier(self, skill_type, creature_type):
        if skill_type == "normal":
            return 1.0
        
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(skill_type, {}).get(creature_type, 1.0)
```

Key changes:
1. Added `handle_battle_end()` method to properly handle scene transitions
2. When battle ends:
   - If in random mode (testing), call `_quit_whole_game()`
   - Otherwise, transition back to main menu with `_transition_to_scene("MainMenuScene")`
3. Removed redundant `check_battle_end()` method and merged its logic into `handle_battle_end()`

This ensures the scene always ends properly according to the engine's requirements while maintaining the game's logic.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
