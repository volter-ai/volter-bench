Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
I understand the issues raised during QA/testing. I'll address each of the problems and propose solutions that align with the architecture documentation and the engine's capabilities.

1. How to fix the issues:

a) Add 'Back' option in the player choice phase:
   - In the player_turn method, we'll add a 'Back' option when presenting skill choices or creature swap choices.
   - We'll implement a loop that allows the player to go back to the main choice (Attack or Swap) if they select 'Back'.

b) Handle random order for actions when creatures have the same speed:
   - In the resolution_phase method, we'll modify the sorting of the turn queue to use a random tiebreaker when creatures have the same speed.

c) Reset the state of the player's creatures when leaving the scene:
   - We'll add a reset_creatures method to restore all creatures to their initial state.
   - We'll call this method in the check_battle_end method before transitioning to the MainMenuScene.

2. Rewriting the main_game_scene.py file with the proposed solutions:

# Excerpt ID: 3131dad9-484e-4d11-92e3-cf55e0b1919d
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.turn_queue = []

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        return f"""===Battle===
{self.player.display_name}'s {player_creature.display_name}: HP {player_creature.hp}/{player_creature.max_hp}
{self.opponent.display_name}'s {opponent_creature.display_name}: HP {opponent_creature.hp}/{opponent_creature.max_hp}

> Attack
> Swap
"""

    def run(self):
        self._show_text(self.player, "A wild opponent appeared!")
        while True:
            self.player_turn()
            if self.check_battle_end():
                break
            self.opponent_turn()
            if self.check_battle_end():
                break
            self.resolution_phase()
            if self.check_battle_end():
                break

    def player_turn(self):
        while True:
            choices = []
            if self.player.active_creature.skills:
                choices.append(Button("Attack"))
            available_creatures = [c for c in self.player.creatures if c != self.player.active_creature and c.hp > 0]
            if available_creatures:
                choices.append(Button("Swap"))
            
            if not choices:
                self._show_text(self.player, f"{self.player.active_creature.display_name} has no available actions!")
                return

            choice = self._wait_for_choice(self.player, choices)

            if choice.display_name == "Attack":
                skill_choices = [SelectThing(skill) for skill in self.player.active_creature.skills]
                skill_choices.append(Button("Back"))
                skill_choice = self._wait_for_choice(self.player, skill_choices)
                if skill_choice.display_name == "Back":
                    continue
                self.turn_queue.append(("attack", self.player, skill_choice.thing))
                break
            elif choice.display_name == "Swap":
                creature_choices = [SelectThing(creature) for creature in available_creatures]
                creature_choices.append(Button("Back"))
                creature_choice = self._wait_for_choice(self.player, creature_choices)
                if creature_choice.display_name == "Back":
                    continue
                self.turn_queue.append(("swap", self.player, creature_choice.thing))
                break

    def opponent_turn(self):
        opponent_choice = self._wait_for_choice(self.opponent, [Button("Make Move")])
        if opponent_choice:
            available_creatures = [c for c in self.opponent.creatures if c != self.opponent.active_creature and c.hp > 0]
            if self.opponent.active_creature.skills and (random.choice(["attack", "swap"]) == "attack" or not available_creatures):
                skill = random.choice(self.opponent.active_creature.skills)
                self.turn_queue.append(("attack", self.opponent, skill))
            elif available_creatures:
                creature = random.choice(available_creatures)
                self.turn_queue.append(("swap", self.opponent, creature))
            else:
                self._show_text(self.player, f"{self.opponent.active_creature.display_name} has no available actions!")

    def resolution_phase(self):
        def action_priority(action):
            if action[0] == "swap":
                return (-1, 0)
            return (action[1].active_creature.speed, random.random())

        self.turn_queue.sort(key=action_priority, reverse=True)

        for action, player, target in self.turn_queue:
            if action == "swap":
                player.active_creature = target
                self._show_text(self.player, f"{player.display_name} swapped to {target.display_name}!")
            elif action == "attack":
                attacker = player.active_creature
                defender = self.opponent.active_creature if player == self.player else self.player.active_creature
                damage = self.calculate_damage(attacker, defender, target)
                defender.hp = max(0, defender.hp - damage)
                self._show_text(self.player, f"{attacker.display_name} used {target.display_name} and dealt {damage} damage to {defender.display_name}!")

        self.turn_queue.clear()

    def calculate_damage(self, attacker: Creature, defender: Creature, skill: Skill) -> int:
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage

        type_effectiveness = self.get_type_effectiveness(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_effectiveness)
        return max(1, final_damage)  # Ensure at least 1 damage is dealt

    def get_type_effectiveness(self, skill_type: str, defender_type: str) -> float:
        effectiveness = {
            ("fire", "leaf"): 2,
            ("fire", "water"): 0.5,
            ("water", "fire"): 2,
            ("water", "leaf"): 0.5,
            ("leaf", "water"): 2,
            ("leaf", "fire"): 0.5
        }
        return effectiveness.get((skill_type, defender_type), 1)

    def check_battle_end(self) -> bool:
        if all(c.hp == 0 for c in self.player.creatures):
            self._show_text(self.player, "You lost the battle!")
            self.reset_creatures()
            self._transition_to_scene("MainMenuScene")
            return True
        elif all(c.hp == 0 for c in self.opponent.creatures):
            self._show_text(self.player, "You won the battle!")
            self.reset_creatures()
            self._transition_to_scene("MainMenuScene")
            return True
        return False

    def reset_creatures(self):
        for player in [self.player, self.opponent]:
            for creature in player.creatures:
                creature.hp = creature.max_hp

    def force_swap(self, player: Player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if available_creatures:
            creature_choices = [SelectThing(creature) for creature in available_creatures]
            creature_choice = self._wait_for_choice(player, creature_choices)
            player.active_creature = creature_choice.thing
            self._show_text(self.player, f"{player.display_name} swapped to {player.active_creature.display_name}!")
        else:
            self._show_text(self.player, f"{player.display_name} has no more creatures able to battle!")
```

These changes address the issues raised in the QA/testing:

1. The 'Back' option is now available in the player choice phase for both Attack and Swap actions.
2. The resolution_phase now uses a random tiebreaker when creatures have the same speed.
3. A reset_creatures method has been added and is called before transitioning to the MainMenuScene, ensuring that the state of the player's creatures is reset when leaving the scene.

These modifications should bring the implementation in line with the architecture documentation while staying within the capabilities of the engine.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "3131dad9-484e-4d11-92e3-cf55e0b1919d", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
