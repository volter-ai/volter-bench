Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for providing the detailed requirements and context. I'll explain the architecture and approach I'll use to implement the MainGameScene component, and then I'll provide the updated code.

Architecture and Implementation Approach:

1. Component Structure:
   - We'll create a main container div that takes up the entire 16:9 game container.
   - Inside this, we'll have three main sections: HUD (top), Battlefield (middle), and User Interface (bottom).

2. HUD:
   - We'll implement this as a nav bar at the top of the screen using Tailwind classes for styling.
   - It will display basic game information (we can add more details later if needed).

3. Battlefield:
   - We'll use Tailwind's flex layout to horizontally spread the player and opponent creatures.
   - Each creature will be represented by a card-like component showing its name, health, and an indicator of ownership.
   - We'll use Tailwind classes to position the creatures on the left and right sides of the battlefield.

4. User Interface:
   - We'll create a text box area that can switch between displaying game text and action buttons.
   - We'll use the `availableButtonSlugs` and `emitButtonClick` from `useCurrentButtons` to render and handle button interactions.
   - The buttons will represent the player's available skills and actions.

5. Tailwind Styling:
   - We'll use Tailwind classes extensively for layout, spacing, colors, and responsive design.
   - For the 16:9 aspect ratio, we'll use the `aspect-video` class on the main container.
   - We'll use flexbox (`flex`, `flex-col`, `justify-between`, etc.) for overall layout.
   - For the battlefield, we'll use `flex justify-between` to spread creatures horizontally.
   - We'll use Tailwind's color classes for theming and `rounded` classes for rounded corners.

6. Data Handling:
   - We'll create interfaces for the main data structures (Player, Creature, Skill) based on the provided VIEW_DATA.
   - We'll use optional chaining and nullish coalescing to safely access potentially missing data.

7. Icons:
   - We'll import and use Lucide icons for visual enhancements where appropriate.

Now, let's implement the component based on this architecture:

# Excerpt ID: 51a50f65-8322-4033-9f9a-eb689f6957ce
```tsx main_game/templates/MainGameScene.tsx
import { useCurrentButtons } from "@/lib/useChoices.ts";
import { Heart, Swords, User } from 'lucide-react';

interface Skill {
  uid: string;
  display_name: string;
  description: string;
  stats: {
    damage: number;
  };
}

interface Creature {
  uid: string;
  display_name: string;
  description: string;
  stats: {
    hp: number;
    max_hp: number;
  };
  collections: {
    skills: Skill[];
  };
}

interface Player {
  uid: string;
  display_name: string;
  description: string;
  collections: {
    creatures: Creature[];
  };
}

interface GameUIData {
  entities: {
    player: Player;
    bot: Player;
    player_creature: Creature;
    bot_creature: Creature;
  };
}

export function MainGameSceneView(props: { data: GameUIData }) {
  const {
    availableButtonSlugs,
    emitButtonClick
  } = useCurrentButtons();

  const playerCreature = props.data.entities.player_creature;
  const botCreature = props.data.entities.bot_creature;

  return (
    <div className="w-full h-full aspect-video flex flex-col bg-gray-100">
      {/* HUD */}
      <nav className="bg-blue-600 text-white p-2 flex justify-between items-center">
        <div className="flex items-center">
          <User className="mr-2" />
          <span>{props.data.entities.player.display_name}</span>
        </div>
        <div>
          <Swords className="mr-2 inline" />
          <span>Battle in Progress</span>
        </div>
      </nav>

      {/* Battlefield */}
      <div className="flex-grow flex justify-between items-center p-4 bg-green-200">
        {/* Player Creature */}
        <div className="text-center">
          <div className="bg-white rounded-lg p-4 shadow-md">
            <h3 className="font-bold">{playerCreature?.display_name}</h3>
            <p className="flex items-center justify-center">
              <Heart className="text-red-500 mr-1" />
              {playerCreature?.stats.hp} / {playerCreature?.stats.max_hp}
            </p>
          </div>
          <div className="mt-2 text-blue-600 font-semibold">Player's Creature</div>
        </div>

        {/* Opponent Creature */}
        <div className="text-center">
          <div className="bg-white rounded-lg p-4 shadow-md">
            <h3 className="font-bold">{botCreature?.display_name}</h3>
            <p className="flex items-center justify-center">
              <Heart className="text-red-500 mr-1" />
              {botCreature?.stats.hp} / {botCreature?.stats.max_hp}
            </p>
          </div>
          <div className="mt-2 text-red-600 font-semibold">Opponent's Creature</div>
        </div>
      </div>

      {/* User Interface */}
      <div className="bg-gray-200 p-4 h-1/3">
        <div className="bg-white rounded-lg p-4 h-full overflow-y-auto">
          {availableButtonSlugs.includes('tackle') ? (
            <button
              onClick={() => emitButtonClick('tackle')}
              className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 mr-2 mb-2"
            >
              Tackle
            </button>
          ) : (
            <p className="text-gray-600">Waiting for your turn...</p>
          )}
          {/* Add more buttons here as needed */}
        </div>
      </div>
    </div>
  );
}
```

This implementation follows the described architecture and meets the requirements outlined in the VIEW_SUMMARY. It uses Tailwind classes for styling, handles the 16:9 aspect ratio, and implements the HUD, Battlefield, and User Interface sections as requested. The component also safely handles potentially missing data and includes the required button interactions.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "51a50f65-8322-4033-9f9a-eb689f6957ce", "file_path": "main_game/templates/MainGameScene.tsx"}]
```
__________________
