Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me describe the fixes needed:

1. Reset Creature State:
- We need to reset all creatures' HP to their max_hp when leaving MainGameScene
- This should happen before transitioning or quitting
- Since models can't have methods, this must be done in the scene

2. Add "Back" Option:
- During attack/swap choice phases, we need to add a "Back" button
- If Back is chosen, return to the main choice menu
- This requires restructuring the action selection logic to handle the back option

The solution requires modifying MainGameScene.py to:
1. Add a reset_creatures() method to restore HP
2. Call reset_creatures() before any scene exit
3. Add Back buttons to submenus
4. Restructure get_player_action() to handle Back choices

Here's the fixed implementation:

# Excerpt ID: 6c74e1a8-4001-4b69-b196-8a21b7e2e1a6
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        
        # Set initial active creatures
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]

    def __str__(self):
        p_creature = self.player.active_creature
        o_creature = self.opponent.active_creature
        
        return f"""=== Battle ===
Your {p_creature.display_name}: {p_creature.hp}/{p_creature.max_hp} HP
Opponent's {o_creature.display_name}: {o_creature.hp}/{o_creature.max_hp} HP

> Attack
> Swap"""

    def reset_creatures(self):
        """Reset all creatures to their initial state"""
        for creature in self.player.creatures:
            creature.hp = creature.max_hp
        for creature in self.opponent.creatures:
            creature.hp = creature.max_hp

    def run(self):
        try:
            while True:
                # Player turn
                player_action = self.get_player_action(self.player)
                if not player_action:
                    continue
                    
                # Opponent turn
                opponent_action = self.get_player_action(self.opponent)
                if not opponent_action:
                    continue
                    
                # Resolve actions
                self.resolve_turn(player_action, opponent_action)
                
                # Check for battle end
                if self.check_battle_end():
                    self.reset_creatures()  # Reset before quitting
                    self._quit_whole_game()
        except Exception as e:
            self.reset_creatures()  # Reset before any unexpected exit
            raise e

    def get_player_action(self, player):
        while True:  # Main choice loop
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            
            main_choice = self._wait_for_choice(player, [attack_button, swap_button])
            
            if main_choice == attack_button:
                # Show skills with Back option
                back_button = Button("Back")
                skill_choices = [SelectThing(skill) for skill in player.active_creature.skills]
                skill_choices.append(back_button)
                
                choice = self._wait_for_choice(player, skill_choices)
                if choice == back_button:
                    continue  # Go back to main choices
                return choice
            else:
                # Show available creatures with Back option
                available_creatures = [c for c in player.creatures if c != player.active_creature and c.hp > 0]
                if not available_creatures:
                    self._show_text(player, "No other creatures available!")
                    continue
                    
                back_button = Button("Back")
                creature_choices = [SelectThing(creature) for creature in available_creatures]
                creature_choices.append(back_button)
                
                choice = self._wait_for_choice(player, creature_choices)
                if choice == back_button:
                    continue  # Go back to main choices
                return choice

    def resolve_turn(self, player_action, opponent_action):
        # Handle swaps first
        if isinstance(player_action.thing, type(self.player.creatures[0])):
            self.player.active_creature = player_action.thing
            
        if isinstance(opponent_action.thing, type(self.opponent.creatures[0])):
            self.opponent.active_creature = opponent_action.thing

        # Then handle attacks
        first, second = self.get_action_order(player_action, opponent_action)
        self.execute_action(first)
        self.execute_action(second)

    def get_action_order(self, player_action, opponent_action):
        p_speed = self.player.active_creature.speed
        o_speed = self.opponent.active_creature.speed
        
        if p_speed > o_speed or (p_speed == o_speed and random.random() < 0.5):
            return player_action, opponent_action
        return opponent_action, player_action

    def execute_action(self, action):
        if isinstance(action.thing, type(self.player.creatures[0])):
            return  # Skip if it's a swap
            
        skill = action.thing
        attacker = self.player.active_creature if action == self.player else self.opponent.active_creature
        defender = self.opponent.active_creature if action == self.player else self.player.active_creature
        
        # Calculate damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Apply type effectiveness
        multiplier = self.get_type_multiplier(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * multiplier)
        
        defender.hp = max(0, defender.hp - final_damage)

    def get_type_multiplier(self, attack_type, defend_type):
        if attack_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(attack_type, {}).get(defend_type, 1.0)

    def check_battle_end(self):
        p_has_active = any(c.hp > 0 for c in self.player.creatures)
        o_has_active = any(c.hp > 0 for c in self.opponent.creatures)
        
        if not p_has_active:
            self._show_text(self.player, "You lost!")
            return True
        elif not o_has_active:
            self._show_text(self.player, "You won!")
            return True
            
        return False
```

Key changes:

1. Added reset_creatures() method to restore HP values
2. Added try/except to ensure reset happens on any exit
3. Added reset call before quit_whole_game
4. Restructured get_player_action() to:
   - Use a while loop for main choice menu
   - Add Back button to skill and creature choices
   - Handle Back button by continuing main loop
   - Keep all other battle logic intact

The changes maintain the pure data model architecture while adding the missing features required by the specification. The scene now properly resets creature state on exit and provides the Back option during choice phases.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
