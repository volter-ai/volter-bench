Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for providing the detailed information and requirements. I'll explain the architecture and implementation approach for the MainGameSceneView component, and then provide the updated code.

Architecture and Implementation Approach:

1. Component Structure:
   We'll create a main container div that will house two main sections:
   - Battlefield Display (upper 2/3)
   - User Interface (lower 1/3)

2. Battlefield Display:
   - We'll use a grid layout with four quadrants for the battlefield display.
   - Each quadrant will contain either a creature display or a status display.
   - We'll use the CreatureCard component for displaying creatures and their status.

3. User Interface:
   - We'll create a section for the UI at the bottom of the screen.
   - We'll use a grid layout for displaying choices in a 2x2 format when needed.
   - We'll use the SkillButton component for displaying skills/actions.

4. Styling:
   - We'll use Tailwind CSS classes for styling and layout.
   - The main container will use flex layout to divide the screen into the battlefield and UI sections.
   - We'll use responsive classes to ensure the layout works well on different screen sizes.

5. Data Handling:
   - We'll create interfaces for the data structures we receive, such as Creature and Skill.
   - We'll use optional chaining and nullish coalescing to handle potentially missing data.

6. State Management:
   - We'll use the provided useCurrentButtons hook to manage available actions and handle button clicks.

Now, let's implement the component based on this architecture:

# Excerpt ID: e4004714-3c58-40cc-9536-9f19f8634795
```tsx main_game/templates/MainGameScene.tsx
import { useCurrentButtons } from "@/lib/useChoices.ts";
import { Sword, Shield, Zap } from 'lucide-react'
import { CreatureCard } from "@/components/ui/custom/creature/creature_card";
import { SkillButton } from "@/components/ui/custom/skill/skill_button";

interface Creature {
  uid: string;
  display_name: string;
  stats: {
    hp: number;
    max_hp: number;
  };
  meta: {
    creature_type: string;
  };
}

interface Skill {
  uid: string;
  display_name: string;
  description: string;
  stats: {
    base_damage: number;
  };
  meta: {
    skill_type: string;
    is_physical: boolean;
  };
}

interface GameUIData {
  entities: {
    player_creature: Creature;
    opponent_creature: Creature;
  };
}

export function MainGameSceneView(props: { data: GameUIData }) {
  const {
    availableButtonSlugs,
    emitButtonClick
  } = useCurrentButtons()

  const { player_creature, opponent_creature } = props.data.entities;

  return (
    <div className="w-full h-full flex flex-col">
      {/* Battlefield Display */}
      <div className="flex-grow grid grid-cols-2 grid-rows-2 gap-4 p-4">
        {/* Opponent Creature Status */}
        <div className="row-start-1 col-start-1 flex items-start justify-start">
          <CreatureCard
            uid={opponent_creature?.uid || "opponent"}
            name={opponent_creature?.display_name || "Unknown"}
            image={`/images/creatures/${opponent_creature?.meta.creature_type || "unknown"}_front.png`}
            hp={opponent_creature?.stats.hp || 0}
            maxHp={opponent_creature?.stats.max_hp || 1}
          />
        </div>

        {/* Opponent Creature */}
        <div className="row-start-1 col-start-2 flex items-start justify-end">
          <img
            src={`/images/creatures/${opponent_creature?.meta.creature_type || "unknown"}_front.png`}
            alt={opponent_creature?.display_name || "Unknown"}
            className="w-48 h-48 object-contain"
          />
        </div>

        {/* Player Creature */}
        <div className="row-start-2 col-start-1 flex items-end justify-start">
          <img
            src={`/images/creatures/${player_creature?.meta.creature_type || "unknown"}_back.png`}
            alt={player_creature?.display_name || "Unknown"}
            className="w-48 h-48 object-contain"
          />
        </div>

        {/* Player Creature Status */}
        <div className="row-start-2 col-start-2 flex items-end justify-end">
          <CreatureCard
            uid={player_creature?.uid || "player"}
            name={player_creature?.display_name || "Unknown"}
            image={`/images/creatures/${player_creature?.meta.creature_type || "unknown"}_back.png`}
            hp={player_creature?.stats.hp || 0}
            maxHp={player_creature?.stats.max_hp || 1}
          />
        </div>
      </div>

      {/* User Interface */}
      <div className="h-1/3 bg-gray-100 p-4">
        <div className="grid grid-cols-2 grid-rows-2 gap-4 h-full">
          {player_creature?.collections?.skills?.map((skill: Skill) => (
            <SkillButton
              key={skill.uid}
              uid={skill.uid}
              skillName={skill.display_name}
              description={skill.description}
              stats={`Damage: ${skill.stats.base_damage}, Type: ${skill.meta.skill_type}`}
              onClick={() => emitButtonClick(skill.uid)}
              disabled={!availableButtonSlugs.includes(skill.uid)}
            >
              {skill.meta.is_physical ? <Sword className="mr-2" /> : <Zap className="mr-2" />}
              {skill.display_name}
            </SkillButton>
          ))}
        </div>
      </div>
    </div>
  );
}
```

This implementation follows the architecture described earlier and uses Tailwind CSS for styling. It creates a responsive layout that divides the screen into the battlefield display and user interface sections. The CreatureCard and SkillButton components are used to display creature information and available skills, respectively.

The component handles potentially missing data using optional chaining and provides fallback values where necessary. It also uses the availableButtonSlugs to disable buttons that are not currently available for interaction.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "e4004714-3c58-40cc-9536-9f19f8634795", "file_path": "main_game/templates/MainGameScene.tsx"}]
```
__________________
