Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
Thank you for providing the detailed information and requirements. I'll explain the architecture and implementation approach for the MainGameSceneView component, and then provide the updated code.

Architecture and Implementation Approach:

1. Component Structure:
   We'll create a main container div that will house two main sections:
   - Battlefield Display (upper 2/3)
   - User Interface (lower 1/3)

2. Battlefield Display:
   - We'll use a grid layout with four quadrants for the battlefield display.
   - Each quadrant will contain either a creature display or a status display.
   - We'll use the CreatureCard component for displaying creatures and their status.

3. User Interface:
   - We'll create a section for the lower 1/3 of the screen.
   - This section will display either messages or a 2x2 grid of buttons/choices.
   - We'll use the SkillButton component for displaying skill choices.

4. Styling:
   - We'll use Tailwind CSS classes for styling and layout.
   - The main container will have a fixed aspect ratio of 16:9 using Tailwind's aspect-ratio utility.
   - We'll use flexbox and grid layouts for positioning elements.

5. Data Handling:
   - We'll create interfaces for the data structures we receive from the backend.
   - We'll use optional chaining and nullish coalescing to handle potential missing data.

6. Responsiveness:
   - We'll use Tailwind's responsive classes to ensure the layout adapts to different screen sizes while maintaining the 16:9 aspect ratio.

Now, let's implement the component based on this architecture:

# Excerpt ID: 8bcab318-2aab-4fdf-acbc-3bd8e1203d59
```tsx main_game/templates/MainGameScene.tsx
import { useCurrentButtons } from "@/lib/useChoices.ts";
import { CreatureCard } from "@/components/ui/custom/creature/creature_card";
import { SkillButton } from "@/components/ui/custom/skill/skill_button";
import { Sword, Shield, Zap, Heart } from 'lucide-react';

interface Creature {
  uid: string;
  display_name: string;
  stats: {
    hp: number;
    max_hp: number;
    attack: number;
    defense: number;
    sp_attack: number;
    sp_defense: number;
    speed: number;
  };
  meta: {
    creature_type: string;
  };
}

interface Skill {
  uid: string;
  display_name: string;
  description: string;
  stats: {
    base_damage: number;
  };
  meta: {
    skill_type: string;
    is_physical: boolean;
  };
}

interface GameUIData {
  entities: {
    player_creature: Creature;
    opponent_creature: Creature;
  };
  meta: {
    battle_ended: boolean;
  };
}

export function MainGameSceneView(props: { data: GameUIData }) {
  const {
    availableButtonSlugs,
    emitButtonClick
  } = useCurrentButtons();

  const { player_creature, opponent_creature } = props.data.entities;

  const renderCreatureStats = (creature: Creature) => (
    <div className="flex flex-col items-start space-y-1">
      <div className="flex items-center">
        <Sword className="w-4 h-4 mr-1" />
        <span>{creature.stats.attack}</span>
      </div>
      <div className="flex items-center">
        <Shield className="w-4 h-4 mr-1" />
        <span>{creature.stats.defense}</span>
      </div>
      <div className="flex items-center">
        <Zap className="w-4 h-4 mr-1" />
        <span>{creature.stats.speed}</span>
      </div>
    </div>
  );

  return (
    <div className="w-full h-full aspect-video bg-gradient-to-b from-blue-100 to-green-100 flex flex-col">
      {/* Battlefield Display */}
      <div className="flex-grow grid grid-cols-2 grid-rows-2 p-4 gap-4">
        {/* Opponent Creature Status */}
        <div className="flex justify-start items-start">
          {opponent_creature && (
            <CreatureCard
              uid={opponent_creature.uid}
              name={opponent_creature.display_name}
              image={`/images/creatures/${opponent_creature.meta.creature_type}.png`}
              hp={opponent_creature.stats.hp}
              maxHp={opponent_creature.stats.max_hp}
              className="transform scale-75 origin-top-left"
            />
          )}
        </div>

        {/* Opponent Creature */}
        <div className="flex justify-end items-start">
          {opponent_creature && renderCreatureStats(opponent_creature)}
        </div>

        {/* Player Creature */}
        <div className="flex justify-start items-end">
          {player_creature && renderCreatureStats(player_creature)}
        </div>

        {/* Player Creature Status */}
        <div className="flex justify-end items-end">
          {player_creature && (
            <CreatureCard
              uid={player_creature.uid}
              name={player_creature.display_name}
              image={`/images/creatures/${player_creature.meta.creature_type}_back.png`}
              hp={player_creature.stats.hp}
              maxHp={player_creature.stats.max_hp}
              className="transform scale-75 origin-bottom-right"
            />
          )}
        </div>
      </div>

      {/* User Interface */}
      <div className="h-1/3 bg-gray-100 p-4">
        {props.data.meta.battle_ended ? (
          <div className="text-center text-2xl font-bold">Battle Ended!</div>
        ) : (
          <div className="grid grid-cols-2 gap-4">
            {player_creature?.collections?.skills?.map((skill: Skill) => (
              <SkillButton
                key={skill.uid}
                uid={skill.uid}
                skillName={skill.display_name}
                description={skill.description}
                stats={`Damage: ${skill.stats.base_damage}, Type: ${skill.meta.skill_type}`}
                onClick={() => emitButtonClick(skill.uid)}
                disabled={!availableButtonSlugs.includes(skill.uid)}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
```

This implementation follows the architecture described earlier and incorporates the custom components as specified. It uses Tailwind CSS for styling and layout, and handles potential missing data with optional chaining. The component is responsive and maintains a 16:9 aspect ratio.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "8bcab318-2aab-4fdf-acbc-3bd8e1203d59", "file_path": "main_game/templates/MainGameScene.tsx"}]
```
__________________
