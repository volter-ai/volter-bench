Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issues raised during QA/testing, we need to address two main problems:

1. The `MainGameScene` is not exiting properly, either by transitioning to another scene or quitting the game.
2. The game loop is not handling the end of the battle correctly.

Here's how we'll fix these issues:

1. We'll modify the `MainGameScene` to transition back to the `MainMenuScene` after the battle ends.
2. We'll update the `battle_loop` method to return when the battle ends, allowing the `run` method to handle the transition.
3. We'll add a method to reset the creatures' HP after the battle ends.

Let's rewrite the `main_game/scenes/main_game_scene.py` file with these changes:

# Excerpt ID: 5e111a6c-8b6a-4f47-b1ac-d455a2db09be
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.turn_queue = []

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        return f"""===Battle===
{self.player.display_name}'s {player_creature.display_name}: HP {player_creature.hp}/{player_creature.max_hp}
{self.opponent.display_name}'s {opponent_creature.display_name}: HP {opponent_creature.hp}/{opponent_creature.max_hp}

> Attack
> Swap
"""

    def run(self):
        self.setup_battle()
        self.battle_loop()
        self.reset_creatures()
        self._transition_to_scene("MainMenuScene")

    def setup_battle(self):
        self.player.active_creature = self.player.creatures[0]
        self.opponent.active_creature = self.opponent.creatures[0]

    def battle_loop(self):
        while True:
            self.player_turn()
            self.opponent_turn()
            self.resolve_turn()
            if self.check_battle_end():
                break

    def player_turn(self):
        while True:
            attack_button = Button("Attack")
            choices = [attack_button]
            
            if self.can_swap(self.player):
                swap_button = Button("Swap")
                choices.append(swap_button)
            
            choice = self._wait_for_choice(self.player, choices)

            if attack_button == choice:
                skill = self.choose_skill(self.player)
                self.turn_queue.append(("attack", self.player, skill))
                break
            elif choice.display_name == "Swap":
                new_creature = self.choose_creature(self.player)
                self.turn_queue.append(("swap", self.player, new_creature))
                break

    def opponent_turn(self):
        choices = [Button("Attack")]
        if self.can_swap(self.opponent):
            choices.append(Button("Swap"))
        
        choice = self._wait_for_choice(self.opponent, choices)
        if choice.display_name == "Attack":
            skill = self.choose_skill(self.opponent)
            self.turn_queue.append(("attack", self.opponent, skill))
        else:
            new_creature = self.choose_creature(self.opponent)
            self.turn_queue.append(("swap", self.opponent, new_creature))

    def choose_skill(self, player):
        choices = [SelectThing(skill) for skill in player.active_creature.skills]
        return self._wait_for_choice(player, choices).thing

    def choose_creature(self, player):
        choices = [SelectThing(creature) for creature in player.creatures if creature.hp > 0 and creature != player.active_creature]
        if not choices:
            return None
        return self._wait_for_choice(player, choices).thing

    def can_swap(self, player):
        return any(creature.hp > 0 and creature != player.active_creature for creature in player.creatures)

    def resolve_turn(self):
        self.turn_queue.sort(key=lambda x: (-1 if x[0] == "swap" else x[1].active_creature.speed), reverse=True)
        
        for action, player, target in self.turn_queue:
            if action == "swap":
                if target is not None:
                    player.active_creature = target
                    self._show_text(player, f"{player.display_name} swapped to {target.display_name}!")
            elif action == "attack":
                self.resolve_attack(player, target)

        self.turn_queue.clear()

    def resolve_attack(self, attacker, skill):
        defender = self.player if attacker == self.opponent else self.opponent
        defender_creature = defender.active_creature

        if skill.is_physical:
            raw_damage = attacker.active_creature.attack + skill.base_damage - defender_creature.defense
        else:
            raw_damage = (attacker.active_creature.sp_attack / defender_creature.sp_defense) * skill.base_damage

        type_factor = self.get_type_factor(skill.skill_type, defender_creature.creature_type)
        final_damage = int(raw_damage * type_factor)

        defender_creature.hp = max(0, defender_creature.hp - final_damage)
        self._show_text(attacker, f"{attacker.display_name}'s {attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(defender, f"{defender.display_name}'s {defender_creature.display_name} took {final_damage} damage!")

        if defender_creature.hp == 0:
            self._show_text(defender, f"{defender.display_name}'s {defender_creature.display_name} fainted!")
            self.force_swap(defender)

    def get_type_factor(self, skill_type, creature_type):
        effectiveness = {
            "fire": {"leaf": 2, "water": 0.5},
            "water": {"fire": 2, "leaf": 0.5},
            "leaf": {"water": 2, "fire": 0.5}
        }
        return effectiveness.get(skill_type, {}).get(creature_type, 1)

    def force_swap(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if available_creatures:
            new_creature = self.choose_creature(player)
            if new_creature:
                player.active_creature = new_creature
                self._show_text(player, f"{player.display_name} sent out {new_creature.display_name}!")

    def check_battle_end(self):
        if all(c.hp == 0 for c in self.player.creatures):
            self._show_text(self.player, "You lost the battle!")
            return True
        elif all(c.hp == 0 for c in self.opponent.creatures):
            self._show_text(self.player, "You won the battle!")
            return True
        return False

    def reset_creatures(self):
        for player in [self.player, self.opponent]:
            for creature in player.creatures:
                creature.hp = creature.max_hp
```

These changes address the issues by:

1. Adding a `reset_creatures` method to restore all creatures' HP after the battle.
2. Modifying the `run` method to call `reset_creatures` and transition back to the `MainMenuScene` after the battle ends.
3. Keeping the `battle_loop` method as is, but now it will properly exit when the battle ends.

These modifications ensure that the `MainGameScene` always exits properly by transitioning back to the `MainMenuScene`, and it resets the game state for future battles. This should resolve both the test failures and the `FixableException` that were occurring in the QA/testing phase.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "5e111a6c-8b6a-4f47-b1ac-d455a2db09be", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
