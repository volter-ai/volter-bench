Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
Let me describe how to fix this issue:

1. According to the architecture doc: "When transitioning out of this scene, reset the state of the player's creatures."

2. The fix needs to:
- Reset creature HP to max_hp before quitting
- Do this for both player and bot creatures
- Keep models as pure data schemas
- Handle this in the scene logic

3. Implementation approach:
- Add reset logic in MainGameScene before calling _quit_whole_game()
- Reset HP to max_hp for all creatures

Here's the fixed MainGameScene:

# Excerpt ID: ba41230e-97f7-4cf6-bc48-c331a85bf17f
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button
from main_game.models import Player, Creature

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("default_player")
        self.player_creature = self.player.creatures[0]
        self.bot_creature = self.bot.creatures[0]

    def __str__(self):
        return f"""=== Battle ===
Your {self.player_creature.display_name}: {self.player_creature.hp}/{self.player_creature.max_hp} HP
Foe's {self.bot_creature.display_name}: {self.bot_creature.hp}/{self.bot_creature.max_hp} HP

Available Skills:
{chr(10).join([f"> {skill.display_name} ({skill.damage} damage)" for skill in self.player_creature.skills])}
"""

    def run(self):
        while True:
            # Player Choice Phase
            player_skill = self._handle_player_turn()
            
            # Bot Choice Phase  
            bot_skill = self._handle_bot_turn()
            
            # Resolution Phase
            self._resolve_turn(player_skill, bot_skill)
            
            # Check win condition
            if self._check_battle_end():
                break

    def _handle_player_turn(self):
        choices = [Button(skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return self.player_creature.skills[choices.index(choice)]

    def _handle_bot_turn(self):
        choices = [Button(skill.display_name) for skill in self.bot_creature.skills]
        choice = self._wait_for_choice(self.bot, choices)
        return self.bot_creature.skills[choices.index(choice)]

    def _resolve_turn(self, player_skill, bot_skill):
        # Apply damage
        self.bot_creature.hp -= player_skill.damage
        self._show_text(self.player, f"Your {self.player_creature.display_name} used {player_skill.display_name}!")
        
        if self.bot_creature.hp > 0:
            self.player_creature.hp -= bot_skill.damage
            self._show_text(self.player, f"Foe's {self.bot_creature.display_name} used {bot_skill.display_name}!")

    def _reset_creatures(self):
        # Reset all creatures to their max HP
        for creature in self.player.creatures:
            creature.hp = creature.max_hp
        for creature in self.bot.creatures:
            creature.hp = creature.max_hp

    def _check_battle_end(self):
        if self.bot_creature.hp <= 0:
            self._show_text(self.player, "You won!")
            self._reset_creatures()  # Reset before quitting
            self._quit_whole_game()
            return True
        elif self.player_creature.hp <= 0:
            self._show_text(self.player, "You lost!")
            self._reset_creatures()  # Reset before quitting
            self._quit_whole_game()
            return True
        return False
```

The key changes are:
1. Added _reset_creatures() method to handle resetting creature HP
2. Called _reset_creatures() before _quit_whole_game() in both win/loss conditions
3. Kept models as pure data schemas by handling all logic in the scene
4. Maintained the same interface and architecture while adding the missing functionality

This ensures creatures are reset to their original state when the battle ends, as specified in the architecture documentation.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
