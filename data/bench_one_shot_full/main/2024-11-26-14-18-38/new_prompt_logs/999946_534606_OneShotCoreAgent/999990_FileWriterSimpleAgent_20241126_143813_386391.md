Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Fix Description:
The issue is that when creatures have equal speed, the current implementation doesn't randomly decide which goes first. Looking at the architecture docs:

> If the creatures have the same speed, then which creature goes first is decided randomly, with either creature having equal chance of being picked to go first.

The fix is simple - we need to modify the sorting in `_resolve_actions` to:
1. First sort by speed
2. When speeds are equal, add a random tiebreaker
3. This can be done by making the sort key return a tuple of (speed, random_tiebreaker)

This only requires changing the MainGameScene class, specifically the `_resolve_actions` method. No model changes are needed since this is purely game logic.

2. Here's the fixed MainGameScene:

# Excerpt ID: f77c7b0f-e805-4107-af3c-fd6793338b9f
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing, create_from_game_database
from main_game.models import Player, Creature
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        
        # Initialize creatures for both players
        for p in [self.player, self.bot]:
            p.active_creature = p.creatures[0]
            for c in p.creatures:
                c.hp = c.max_hp

    def __str__(self):
        p_creature = self.player.active_creature
        b_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {p_creature.display_name}: {p_creature.hp}/{p_creature.max_hp} HP
Foe's {b_creature.display_name}: {b_creature.hp}/{b_creature.max_hp} HP

Your Team:
{self._format_team(self.player)}

Foe's Team:
{self._format_team(self.bot)}
"""

    def _format_team(self, player):
        return "\n".join([f"- {c.display_name}: {c.hp}/{c.max_hp} HP" for c in player.creatures])

    def run(self):
        while True:
            # Player turn
            player_action = self._handle_turn(self.player)
            if not player_action:
                return
                
            # Bot turn
            bot_action = self._handle_turn(self.bot)
            if not bot_action:
                return
                
            # Resolve actions
            self._resolve_actions(player_action, bot_action)
            
            # Check for battle end
            if self._check_battle_end():
                return

    def _handle_turn(self, player):
        if player.active_creature.hp <= 0:
            available = [c for c in player.creatures if c.hp > 0]
            if not available:
                self._show_text(self.player, f"{player.display_name} has no creatures left!")
                return None
                
            choices = [SelectThing(c) for c in available]
            choice = self._wait_for_choice(player, choices)
            player.active_creature = choice.thing
            return ("swap", choice.thing)
            
        while True:  # Main action loop
            attack = Button("Attack")
            swap = Button("Swap")
            choice = self._wait_for_choice(player, [attack, swap])
            
            if choice == attack:
                # Attack submenu
                skills = [SelectThing(s) for s in player.active_creature.skills]
                back = Button("Back")
                skill_choice = self._wait_for_choice(player, skills + [back])
                
                if skill_choice == back:
                    continue  # Return to main menu
                    
                return ("attack", skill_choice.thing)
                
            else:  # Swap chosen
                available = [c for c in player.creatures if c.hp > 0 and c != player.active_creature]
                if not available:
                    self._show_text(self.player, "No other creatures available!")
                    continue
                
                choices = [SelectThing(c) for c in available]
                back = Button("Back")
                swap_choice = self._wait_for_choice(player, choices + [back])
                
                if swap_choice == back:
                    continue  # Return to main menu
                    
                player.active_creature = swap_choice.thing
                return ("swap", swap_choice.thing)

    def _resolve_actions(self, p_action, b_action):
        # Handle swaps first
        if p_action[0] == "swap":
            self._show_text(self.player, f"You swapped to {p_action[1].display_name}!")
        if b_action[0] == "swap":
            self._show_text(self.player, f"Foe swapped to {b_action[1].display_name}!")
            
        # Then handle attacks
        actions = []
        if p_action[0] == "attack":
            actions.append((self.player, p_action[1]))
        if b_action[0] == "attack":
            actions.append((self.bot, b_action[1]))
            
        # Sort by speed, using random tiebreaker for equal speeds
        actions.sort(key=lambda x: (x[0].active_creature.speed, random.random()), reverse=True)
        
        for attacker, skill in actions:
            defender = self.bot if attacker == self.player else self.player
            self._execute_skill(attacker, defender, skill)

    def _execute_skill(self, attacker, defender, skill):
        # Calculate damage
        if skill.is_physical:
            raw_damage = attacker.active_creature.attack + skill.base_damage - defender.active_creature.defense
        else:
            raw_damage = (attacker.active_creature.sp_attack / defender.active_creature.sp_defense) * skill.base_damage
            
        # Apply type effectiveness
        multiplier = self._get_type_multiplier(skill.skill_type, defender.active_creature.creature_type)
        final_damage = int(raw_damage * multiplier)
        
        # Apply damage
        defender.active_creature.hp = max(0, defender.active_creature.hp - final_damage)
        
        self._show_text(self.player, 
            f"{attacker.active_creature.display_name} used {skill.display_name}! "
            f"Dealt {final_damage} damage to {defender.active_creature.display_name}!")

    def _get_type_multiplier(self, skill_type, defender_type):
        if skill_type == "normal":
            return 1.0
            
        effectiveness = {
            "fire": {"leaf": 2.0, "water": 0.5},
            "water": {"fire": 2.0, "leaf": 0.5},
            "leaf": {"water": 2.0, "fire": 0.5}
        }
        
        return effectiveness.get(skill_type, {}).get(defender_type, 1.0)

    def _check_battle_end(self):
        p_alive = any(c.hp > 0 for c in self.player.creatures)
        b_alive = any(c.hp > 0 for c in self.bot.creatures)
        
        if not p_alive or not b_alive:
            winner = self.player if p_alive else self.bot
            self._show_text(self.player, f"{winner.display_name} wins the battle!")
            self._transition_to_scene("MainMenuScene")
            return True
            
        return False
```

The key change is in the `_resolve_actions` method where the sort now uses a tuple key:
# Excerpt ID: b16947f0-5488-41f4-8702-11ce4d413ccf
```python
actions.sort(key=lambda x: (x[0].active_creature.speed, random.random()), reverse=True)
```

This ensures that:
1. Creatures are first sorted by speed (highest to lowest)
2. When speeds are equal, the random.random() tiebreaker determines the order
3. The random tiebreaker gives each creature an equal chance to go first in case of equal speeds

This change maintains all the existing functionality while properly implementing the speed tie resolution requirement from the architecture.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
