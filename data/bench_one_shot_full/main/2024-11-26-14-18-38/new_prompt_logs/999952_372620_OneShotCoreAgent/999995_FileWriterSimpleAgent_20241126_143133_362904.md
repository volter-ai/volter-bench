Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
The issue is in the MainGameScene where we're trying to find a skill by display_name in the creature's skills list. The problem is that DictionaryChoice returns a display_name, but we're trying to find that string in a list of Skill objects.

The fix should:
1. Keep models as pure data schemas
2. Work with the engine's DictionaryChoice system
3. Maintain type safety
4. Handle the choice selection in a way that matches objects properly

The solution is to modify the MainGameScene to properly handle the choice selection by:
1. Creating a mapping between display names and skills
2. Using the choice's display_name to look up the corresponding skill
3. Keeping the same pattern for both player and opponent choices

Here's the fixed MainGameScene:

# Excerpt ID: 5e9a6bbb-5ffb-49c0-8c09-67a5910e8131
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, DictionaryChoice
from main_game.models import Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.player_creature = player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]
        self._reset_creatures()

    def _reset_creatures(self):
        self.player_creature.hp = self.player_creature.max_hp
        self.opponent_creature.hp = self.opponent_creature.max_hp

    def __str__(self):
        return f"""=== Battle ===
Your {self.player_creature.display_name}: {self.player_creature.hp}/{self.player_creature.max_hp} HP
Opponent's {self.opponent_creature.display_name}: {self.opponent_creature.hp}/{self.opponent_creature.max_hp} HP

Available Skills:
{chr(10).join([f"> {skill.display_name}" for skill in self.player_creature.skills])}"""

    def _calculate_damage(self, attacker_creature, defender_creature, skill: Skill) -> int:
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker_creature.attack + skill.base_damage - defender_creature.defense
        else:
            raw_damage = (attacker_creature.sp_attack / defender_creature.sp_defense) * skill.base_damage

        # Calculate type multiplier
        multiplier = 1.0
        if skill.skill_type == "fire":
            if defender_creature.creature_type == "leaf": multiplier = 2.0
            elif defender_creature.creature_type == "water": multiplier = 0.5
        elif skill.skill_type == "water":
            if defender_creature.creature_type == "fire": multiplier = 2.0
            elif defender_creature.creature_type == "leaf": multiplier = 0.5
        elif skill.skill_type == "leaf":
            if defender_creature.creature_type == "water": multiplier = 2.0
            elif defender_creature.creature_type == "fire": multiplier = 0.5

        return int(raw_damage * multiplier)

    def _get_skill_from_choices(self, creature, player) -> Skill:
        # Create mapping of display names to skills
        skill_map = {skill.display_name: skill for skill in creature.skills}
        
        # Create choices using display names
        skill_choices = [DictionaryChoice(name) for name in skill_map.keys()]
        
        # Get choice and look up corresponding skill
        choice = self._wait_for_choice(player, skill_choices)
        return skill_map[choice.display_name]

    def _execute_turn(self, first_creature, second_creature, first_skill, second_skill):
        # First attack
        damage = self._calculate_damage(first_creature, second_creature, first_skill)
        second_creature.hp -= damage
        self._show_text(self.player, f"{first_creature.display_name} used {first_skill.display_name} for {damage} damage!")
        
        if second_creature.hp <= 0:
            return

        # Second attack
        damage = self._calculate_damage(second_creature, first_creature, second_skill)
        first_creature.hp -= damage
        self._show_text(self.player, f"{second_creature.display_name} used {second_skill.display_name} for {damage} damage!")

    def run(self):
        while True:
            # Player choice phase
            player_skill = self._get_skill_from_choices(self.player_creature, self.player)

            # Opponent choice phase
            opponent_skill = self._get_skill_from_choices(self.opponent_creature, self.opponent)

            # Resolution phase
            if self.player_creature.speed >= self.opponent_creature.speed:
                self._execute_turn(self.player_creature, self.opponent_creature, player_skill, opponent_skill)
            else:
                self._execute_turn(self.opponent_creature, self.player_creature, opponent_skill, player_skill)

            # Check win condition
            if self.opponent_creature.hp <= 0:
                self._show_text(self.player, "You won!")
                break
            elif self.player_creature.hp <= 0:
                self._show_text(self.player, "You lost!")
                break

        self._reset_creatures()
        self._transition_to_scene("MainMenuScene")
```

The key changes are:
1. Added `_get_skill_from_choices` helper method that:
   - Creates a mapping between display names and skills
   - Creates choices using display names
   - Gets choice and returns corresponding skill
2. Simplified the choice handling in the run method
3. Kept all models as pure data schemas
4. Maintained type safety throughout

This should resolve the ValueError while keeping within the engine's capabilities and architectural guidelines.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
