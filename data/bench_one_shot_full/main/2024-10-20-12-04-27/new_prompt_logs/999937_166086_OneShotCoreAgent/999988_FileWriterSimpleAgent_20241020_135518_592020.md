Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
I understand the issues raised during QA/testing. I'll describe how to fix these issues and then provide the rewritten `main_game_scene.py` file with the proposed solutions.

1. Fixing the issues:

a) Implementing the 'Back' option in the Player Choice Phase:
   - We'll add a 'Back' button to the attack and swap choices.
   - We'll implement a loop in the player_choice_phase to allow returning to the main choices.

b) Implementing random selection for equal speed:
   - In the resolution_phase, we'll add a random shuffle to the actions list when speeds are equal.

c) Resetting the player's creatures' state when leaving the scene:
   - We'll add a reset_creatures method to restore all creatures to their initial state.
   - We'll call this method in the run method after the battle ends.

2. Rewritten main_game_scene.py file:

# Excerpt ID: 5db12e1d-337b-4329-a982-98d8d9e7af59
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
from typing import Optional
import time
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.turn_counter = 0

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        return f"""===Battle===
Turn: {self.turn_counter}

{self.player.display_name}'s {player_creature.display_name}:
HP: {player_creature.hp}/{player_creature.max_hp}

{self.opponent.display_name}'s {opponent_creature.display_name}:
HP: {opponent_creature.hp}/{opponent_creature.max_hp}

> Attack
> Swap
"""

    def run(self):
        self._show_text(self.player, "Battle start!")
        self._show_text(self.opponent, "Battle start!")
        
        while True:
            self.turn_counter += 1
            player_action = self.player_choice_phase(self.player)
            opponent_action = self.player_choice_phase(self.opponent)
            self.resolution_phase(player_action, opponent_action)
            
            if self.check_battle_end():
                break

        self.reset_creatures(self.player)
        self.reset_creatures(self.opponent)

    def player_choice_phase(self, current_player):
        while True:
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choices = [attack_button, swap_button]
            choice = self._wait_for_choice(current_player, choices)

            if attack_button == choice:
                action = self.choose_attack(current_player)
                if action:
                    return action
            elif swap_button == choice:
                action = self.choose_swap(current_player)
                if action:
                    return action

    def choose_attack(self, current_player):
        back_button = Button("Back")
        choices = [SelectThing(skill) for skill in current_player.active_creature.skills] + [back_button]
        choice = self._wait_for_choice(current_player, choices)
        if choice == back_button:
            return None
        return choice

    def choose_swap(self, current_player) -> Optional[SelectThing]:
        available_creatures = [creature for creature in current_player.creatures if creature.hp > 0 and creature != current_player.active_creature]
        if not available_creatures:
            self._show_text(current_player, "No creatures available to swap!")
            return None
        back_button = Button("Back")
        choices = [SelectThing(creature) for creature in available_creatures] + [back_button]
        choice = self._wait_for_choice(current_player, choices)
        if choice == back_button:
            return None
        return choice

    def resolution_phase(self, player_action, opponent_action):
        actions = [
            (self.player, player_action),
            (self.opponent, opponent_action)
        ]
        # Sort by speed, with random shuffle for equal speeds
        actions.sort(key=lambda x: (x[0].active_creature.speed, random.random()), reverse=True)

        for current_player, action in actions:
            if isinstance(action.thing, Skill):
                self.execute_skill(current_player, action.thing)
            elif isinstance(action.thing, Creature):
                self.swap_creature(current_player, action.thing)

    def execute_skill(self, attacker, skill):
        defender = self.player if attacker == self.opponent else self.opponent
        defender_creature = defender.active_creature

        if skill.is_physical:
            raw_damage = attacker.active_creature.attack + skill.base_damage - defender_creature.defense
        else:
            raw_damage = (attacker.active_creature.sp_attack / defender_creature.sp_defense) * skill.base_damage

        type_factor = self.get_type_factor(skill.skill_type, defender_creature.creature_type)
        final_damage = int(raw_damage * type_factor)

        defender_creature.hp = max(0, defender_creature.hp - final_damage)
        self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(defender, f"{defender.active_creature.display_name} took {final_damage} damage!")

        if defender_creature.hp == 0:
            self._show_text(defender, f"{defender_creature.display_name} fainted!")
            self.force_swap(defender)

    def swap_creature(self, player, new_creature):
        player.active_creature = new_creature
        self._show_text(player, f"Swapped to {new_creature.display_name}!")

    def force_swap(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if not available_creatures:
            return

        choices = [SelectThing(creature) for creature in available_creatures]
        new_creature = self._wait_for_choice(player, choices).thing
        self.swap_creature(player, new_creature)

    def get_type_factor(self, skill_type, creature_type):
        type_chart = {
            "fire": {"leaf": 2, "water": 0.5},
            "water": {"fire": 2, "leaf": 0.5},
            "leaf": {"water": 2, "fire": 0.5}
        }
        return type_chart.get(skill_type, {}).get(creature_type, 1)

    def check_battle_end(self):
        if all(creature.hp == 0 for creature in self.player.creatures):
            self._show_text(self.player, "You lost the battle!")
            self._show_text(self.opponent, "You won the battle!")
            time.sleep(2)
            self._quit_whole_game()
            return True
        elif all(creature.hp == 0 for creature in self.opponent.creatures):
            self._show_text(self.player, "You won the battle!")
            self._show_text(self.opponent, "You lost the battle!")
            time.sleep(2)
            self._quit_whole_game()
            return True
        return False

    def reset_creatures(self, player):
        for creature in player.creatures:
            creature.hp = creature.max_hp
        player.active_creature = player.creatures[0]
```

These changes address all the issues raised in the QA testing:

1. The 'Back' option is now implemented in both the attack and swap choices.
2. Random selection for equal speed is implemented in the resolution_phase.
3. The reset_creatures method is added and called at the end of the battle to restore all creatures to their initial state.

The code maintains the structure of the models as pure data schemas and uses the capabilities provided by the engine. The changes should resolve the discrepancies with the described architecture while improving the gameplay flow.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "5db12e1d-337b-4329-a982-98d8d9e7af59", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
