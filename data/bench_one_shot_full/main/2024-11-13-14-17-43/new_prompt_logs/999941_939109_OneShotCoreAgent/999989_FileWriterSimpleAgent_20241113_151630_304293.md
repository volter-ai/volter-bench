Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: ## Proposed Code Change
1. Analysis of the issue:
The error occurs when there are no available creatures to swap to. In the MainGameScene, when a creature is knocked out and we try to get available creatures to swap to, we're passing an empty list of choices to `_wait_for_choice()`, which violates the engine's assertion that there must always be at least one choice.

The root cause is in the `handle_turn` method where we handle the "Swap" action. When there are no available creatures to swap to, we default to an attack, but we should prevent the "Swap" option from being shown at all if there are no creatures to swap to.

The fix is to:
1. Check if there are available creatures before showing the "Swap" button
2. Only show the "Swap" option if there are creatures available to swap to
3. This maintains the engine's requirement that _wait_for_choice must always have choices

Here's the fixed MainGameScene:

# Excerpt ID: 17fac238-206f-427e-9403-40c8c1724c9f
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.bot = app.create_bot("basic_opponent")
        # Initialize creatures
        for p in [self.player, self.bot]:
            p.active_creature = p.creatures[0]
            for c in p.creatures:
                c.hp = c.max_hp

    def __str__(self):
        p_creature = self.player.active_creature
        b_creature = self.bot.active_creature
        
        return f"""=== Battle ===
Your {p_creature.display_name}: {p_creature.hp}/{p_creature.max_hp} HP
Foe's {b_creature.display_name}: {b_creature.hp}/{b_creature.max_hp} HP

> Attack
> Swap (if available)
"""

    def calculate_damage(self, attacker: Creature, defender: Creature, skill):
        # Calculate raw damage
        if skill.is_physical:
            raw_damage = attacker.attack + skill.base_damage - defender.defense
        else:
            raw_damage = (attacker.sp_attack / defender.sp_defense) * skill.base_damage
            
        # Type effectiveness
        effectiveness = 1.0
        if skill.skill_type == "fire":
            if defender.creature_type == "leaf": effectiveness = 2.0
            elif defender.creature_type == "water": effectiveness = 0.5
        elif skill.skill_type == "water":
            if defender.creature_type == "fire": effectiveness = 2.0
            elif defender.creature_type == "leaf": effectiveness = 0.5
        elif skill.skill_type == "leaf":
            if defender.creature_type == "water": effectiveness = 2.0
            elif defender.creature_type == "fire": effectiveness = 0.5
            
        return int(raw_damage * effectiveness)

    def get_available_creatures(self, player: Player):
        return [c for c in player.creatures if c.hp > 0 and c != player.active_creature]

    def handle_turn(self, attacker: Player, defender: Player):
        # Get action choice
        choices = [Button("Attack")]
        
        # Only add swap option if there are creatures available to swap to
        available_creatures = self.get_available_creatures(attacker)
        if available_creatures:
            choices.append(Button("Swap"))
            
        choice = self._wait_for_choice(attacker, choices)
        
        if choice.display_name == "Attack":
            # Choose skill
            skill_choices = [SelectThing(s) for s in attacker.active_creature.skills]
            skill = self._wait_for_choice(attacker, skill_choices).thing
            return ("attack", skill)
        else:
            # We know there are available creatures because we only show swap if there are
            creature_choices = [SelectThing(c) for c in available_creatures]
            new_creature = self._wait_for_choice(attacker, creature_choices).thing
            return ("swap", new_creature)

    def run(self):
        while True:
            # Get actions
            p_action = self.handle_turn(self.player, self.bot)
            b_action = self.handle_turn(self.bot, self.player)
            
            # Handle swaps first
            if p_action[0] == "swap":
                self.player.active_creature = p_action[1]
                self._show_text(self.player, f"You sent out {p_action[1].display_name}!")
            if b_action[0] == "swap":
                self.bot.active_creature = b_action[1]
                self._show_text(self.player, f"Foe sent out {b_action[1].display_name}!")
                
            # Handle attacks based on speed
            actions = []
            if p_action[0] == "attack":
                actions.append((self.player, self.bot, p_action[1]))
            if b_action[0] == "attack":
                actions.append((self.bot, self.player, b_action[1]))
                
            actions.sort(key=lambda x: x[0].active_creature.speed, reverse=True)
            
            for attacker, defender, skill in actions:
                damage = self.calculate_damage(attacker.active_creature, defender.active_creature, skill)
                defender.active_creature.hp = max(0, defender.active_creature.hp - damage)
                self._show_text(self.player, 
                    f"{attacker.active_creature.display_name} used {skill.display_name}! "
                    f"Dealt {damage} damage to {defender.active_creature.display_name}!")
                
                if defender.active_creature.hp == 0:
                    available = self.get_available_creatures(defender)
                    if not available:
                        self._show_text(self.player, 
                            "You win!" if defender == self.bot else "You lose!")
                        self._quit_whole_game()
                    else:
                        creature_choices = [SelectThing(c) for c in available]
                        new_creature = self._wait_for_choice(defender, creature_choices).thing
                        defender.active_creature = new_creature
                        self._show_text(self.player,
                            f"{'You' if defender == self.player else 'Foe'} sent out {new_creature.display_name}!")
```

The key changes are:
1. Only show the "Swap" button if there are available creatures to swap to
2. Removed the fallback to attack in the swap logic since we now prevent that case
3. Updated the __str__ to indicate swap is conditional
4. Simplified the handle_turn logic since we know swap is only available when there are creatures to swap to

This maintains all engine requirements while fixing the empty choices issue.

## Directions
Reply with a list of actions in the following format. The response should only contain the JSON list of actions, no other text.
Make sure you are using the excerpt_id which contains the entire contents of the file.

Each action in the list must have these fields:
- action: Must be "overwrite"
- excerpt_id: The ID of the excerpt to use
- file_path: The relative path to the file

Example format for multiple files:
[
    {
        "action": "overwrite",
        "excerpt_id": "abc1",
        "file_path": "src/main.py"
    },
    {
        "action": "overwrite",
        "excerpt_id": "def2",
        "file_path": "tests/test_main.py"
    }
]
__________________
Role: assistant
Content: 
__________________
