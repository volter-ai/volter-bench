Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To fix the issues raised during QA/testing, we need to address two main problems:

1. The `MainGameScene` is not exiting properly, either by transitioning to another scene or quitting the whole game.
2. The game loop in `MainGameScene` is not handling the end of the battle correctly.

Here's how we'll fix these issues:

1. We'll modify the `MainGameScene` to transition back to the `MainMenuScene` after the battle ends.
2. We'll update the `check_battle_end` method to return a boolean indicating whether the battle has ended.
3. We'll modify the main game loop to break when the battle ends and then transition to the main menu.

These changes will ensure that the scene exits properly and follows the expected flow of the game.

Here's the rewritten `main_game_scene.py` file with the proposed solution:

# Excerpt ID: bda95401-a0e0-4e13-8981-741c78fb5061
```python main_game/scenes/main_game_scene.py
from typing import Optional
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = app.create_bot("basic_opponent")
        self.turn_counter = 0

    def __str__(self):
        player_creature = self.player.active_creature
        opponent_creature = self.opponent.active_creature
        return f"""===Battle===
Turn: {self.turn_counter}

{self.player.display_name}'s {player_creature.display_name}:
HP: {player_creature.hp}/{player_creature.max_hp}

{self.opponent.display_name}'s {opponent_creature.display_name}:
HP: {opponent_creature.hp}/{opponent_creature.max_hp}

> Attack
> Swap
"""

    def run(self):
        self._show_text(self.player, "Battle start!")
        self._show_text(self.opponent, "Battle start!")
        while True:
            self.turn_counter += 1
            player_action = self.player_choice_phase(self.player)
            opponent_action = self.player_choice_phase(self.opponent)
            self.resolution_phase(player_action, opponent_action)

            if self.check_battle_end():
                break

        # Transition back to the main menu after the battle ends
        self._transition_to_scene("MainMenuScene")

    def player_choice_phase(self, current_player):
        while True:
            attack_button = Button("Attack")
            swap_button = Button("Swap")
            choices = [attack_button, swap_button]
            choice = self._wait_for_choice(current_player, choices)

            if attack_button == choice:
                return self.choose_attack(current_player)
            elif swap_button == choice:
                swap_action = self.choose_swap(current_player)
                if swap_action is None:
                    self._show_text(current_player, "No creatures available to swap. Attacking instead.")
                    return self.choose_attack(current_player)
                return swap_action

    def choose_attack(self, current_player):
        choices = [SelectThing(skill) for skill in current_player.active_creature.skills]
        return self._wait_for_choice(current_player, choices)

    def choose_swap(self, current_player) -> Optional[SelectThing]:
        available_creatures = [c for c in current_player.creatures if c.hp > 0 and c != current_player.active_creature]
        if not available_creatures:
            return None
        choices = [SelectThing(creature) for creature in available_creatures]
        return self._wait_for_choice(current_player, choices)

    def resolution_phase(self, player_action, opponent_action):
        actions = [
            (self.player, player_action),
            (self.opponent, opponent_action)
        ]
        actions.sort(key=lambda x: x[0].active_creature.speed, reverse=True)

        for current_player, action in actions:
            other_player = self.opponent if current_player == self.player else self.player
            if isinstance(action.thing, Skill):
                self.execute_skill(current_player, other_player, action.thing)
            elif isinstance(action.thing, Creature):
                self.swap_creature(current_player, action.thing)

    def execute_skill(self, attacker, defender, skill):
        if skill.is_physical:
            raw_damage = attacker.active_creature.attack + skill.base_damage - defender.active_creature.defense
        else:
            raw_damage = (attacker.active_creature.sp_attack / defender.active_creature.sp_defense) * skill.base_damage

        type_factor = self.get_type_factor(skill.skill_type, defender.active_creature.creature_type)
        final_damage = int(raw_damage * type_factor)

        defender.active_creature.hp = max(0, defender.active_creature.hp - final_damage)
        self._show_text(attacker, f"{attacker.active_creature.display_name} used {skill.display_name}!")
        self._show_text(defender, f"{defender.active_creature.display_name} took {final_damage} damage!")

        if defender.active_creature.hp == 0:
            self._show_text(defender, f"{defender.active_creature.display_name} fainted!")
            self.force_swap(defender)

    def swap_creature(self, player, new_creature):
        player.active_creature = new_creature
        self._show_text(player, f"Swapped to {new_creature.display_name}!")

    def force_swap(self, player):
        available_creatures = [c for c in player.creatures if c.hp > 0]
        if not available_creatures:
            return

        choices = [SelectThing(creature) for creature in available_creatures]
        new_creature = self._wait_for_choice(player, choices).thing
        self.swap_creature(player, new_creature)

    def get_type_factor(self, skill_type, creature_type):
        effectiveness = {
            "fire": {"leaf": 2, "water": 0.5},
            "water": {"fire": 2, "leaf": 0.5},
            "leaf": {"water": 2, "fire": 0.5}
        }
        return effectiveness.get(skill_type, {}).get(creature_type, 1)

    def check_battle_end(self):
        if all(c.hp == 0 for c in self.player.creatures):
            self._show_text(self.player, "You lost the battle!")
            self._show_text(self.opponent, "You won the battle!")
            return True
        elif all(c.hp == 0 for c in self.opponent.creatures):
            self._show_text(self.player, "You won the battle!")
            self._show_text(self.opponent, "You lost the battle!")
            return True
        return False
```

This solution addresses the issues by:

1. Adding a transition back to the main menu after the battle ends in the `run` method.
2. Modifying the `check_battle_end` method to return a boolean indicating whether the battle has ended.
3. Using the return value of `check_battle_end` to break the main game loop when the battle is over.

These changes ensure that the `MainGameScene` exits properly by transitioning back to the `MainMenuScene` after the battle ends, following the expected flow of the game and adhering to the engine's architecture.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "bda95401-a0e0-4e13-8981-741c78fb5061", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
