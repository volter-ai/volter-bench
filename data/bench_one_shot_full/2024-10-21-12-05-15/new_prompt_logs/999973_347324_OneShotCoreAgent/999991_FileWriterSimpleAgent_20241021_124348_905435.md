Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
I apologize for missing this important aspect of the game logic. You're right that we need to implement the speed-based turn order and the random decision for equal speeds. Here's how we'll fix this issue:

1. We'll modify the MainGameScene to implement the correct turn order based on creature speeds.
2. We'll add a method to compare speeds and determine the order of actions.
3. We'll use random.choice when speeds are equal to decide the order.
4. We'll restructure the main battle loop to accommodate this new turn order system.

Here's the updated MainGameScene with these changes implemented:

# Excerpt ID: d03202c9-13dd-437f-8df7-4d6c7026d23e
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Your skills:
{self._format_skills(self.player_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name}" for skill in skills])

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appears!")
        while True:
            if self._check_battle_end():
                self._show_battle_result()
                self._return_to_main_menu()
                break

            player_skill = self._player_choose_skill()
            opponent_skill = self._opponent_choose_skill()

            first, second = self._determine_turn_order(
                (self.player_creature, player_skill),
                (self.opponent_creature, opponent_skill)
            )

            self._execute_turn(first)
            if not self._check_battle_end():
                self._execute_turn(second)

    def _player_choose_skill(self):
        self._show_text(self.player, "Your turn!")
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def _opponent_choose_skill(self):
        return random.choice(self.opponent_creature.skills)

    def _determine_turn_order(self, player_action, opponent_action):
        player_creature, player_skill = player_action
        opponent_creature, opponent_skill = opponent_action

        if player_creature.speed > opponent_creature.speed:
            return player_action, opponent_action
        elif player_creature.speed < opponent_creature.speed:
            return opponent_action, player_action
        else:
            return random.choice([(player_action, opponent_action), (opponent_action, player_action)])

    def _execute_turn(self, action):
        creature, skill = action
        if creature == self.player_creature:
            self._execute_skill(self.player_creature, self.opponent_creature, skill)
        else:
            self._execute_skill(self.opponent_creature, self.player_creature, skill)

    def _execute_skill(self, attacker: Creature, defender: Creature, skill: Skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        type_factor = self._get_type_factor(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_factor)
        defender.hp = max(0, defender.hp - final_damage)

        self._show_text(self.player, f"{attacker.display_name} uses {skill.display_name}!")
        self._show_text(self.player, f"It deals {final_damage} damage to {defender.display_name}!")

    def _get_type_factor(self, skill_type: str, defender_type: str) -> float:
        if skill_type == "normal":
            return 1.0
        elif skill_type == "fire" and defender_type == "leaf":
            return 2.0
        elif skill_type == "water" and defender_type == "fire":
            return 2.0
        elif skill_type == "leaf" and defender_type == "water":
            return 2.0
        elif skill_type == "fire" and defender_type == "water":
            return 0.5
        elif skill_type == "water" and defender_type == "leaf":
            return 0.5
        elif skill_type == "leaf" and defender_type == "fire":
            return 0.5
        else:
            return 1.0

    def _check_battle_end(self) -> bool:
        return self.player_creature.hp <= 0 or self.opponent_creature.hp <= 0

    def _show_battle_result(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player_creature.display_name} fainted! You lose!")
        else:
            self._show_text(self.player, f"{self.opponent_creature.display_name} fainted! You win!")

    def _return_to_main_menu(self):
        return_button = Button("Return to Main Menu")
        choice = self._wait_for_choice(self.player, [return_button])
        if choice == return_button:
            self._transition_to_scene("MainMenuScene")
```

This updated implementation addresses the issue by:

1. Implementing a `_determine_turn_order` method that compares the speeds of the creatures and randomly decides the order if speeds are equal.
2. Restructuring the main battle loop to first determine the skills chosen by both the player and the opponent, then determine the turn order, and finally execute the skills in the correct order.
3. Using a separate `_execute_turn` method to handle the execution of each creature's turn, which allows for the correct order of actions based on speed.

These changes ensure that the creature with the higher speed acts first, and when speeds are equal, the order is randomly determined. This implementation adheres to the described architecture and stays within the capabilities of the engine while maintaining the existing model structure.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "d03202c9-13dd-437f-8df7-4d6c7026d23e", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
