Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
To address the issue raised during QA/testing, we need to implement the speed-based turn order and random decision-making for equal speed in the MainGameScene. Here's how we'll fix this:

1. We'll modify the MainGameScene to determine the turn order based on the creatures' speed stats.
2. If the speeds are equal, we'll use random selection to determine which creature goes first.
3. We'll restructure the battle loop to accommodate this new turn order system.

Here's the proposed solution for the MainGameScene:

# Excerpt ID: 014cdf85-fc72-417a-a6c1-8fdcaa59a902
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Your skills:
{self._format_skills(self.player_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name}" for skill in skills])

    def run(self):
        while True:
            self._reset_battle()
            self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appears!")
            while True:
                if self._check_battle_end():
                    break
                self._execute_turn()
            
            if not self._play_again():
                break

    def _reset_battle(self):
        self.player_creature.hp = self.player_creature.max_hp
        self.opponent_creature.hp = self.opponent_creature.max_hp

    def _execute_turn(self):
        player_skill = self._player_choose_skill()
        opponent_skill = random.choice(self.opponent_creature.skills)

        first, second = self._determine_turn_order(
            (self.player_creature, player_skill),
            (self.opponent_creature, opponent_skill)
        )

        self._execute_skill(*first)
        if not self._check_battle_end():
            self._execute_skill(*second)

    def _player_choose_skill(self):
        self._show_text(self.player, "Your turn to choose a skill!")
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def _determine_turn_order(self, player_action, opponent_action):
        player_creature, player_skill = player_action
        opponent_creature, opponent_skill = opponent_action

        if player_creature.speed > opponent_creature.speed:
            return player_action, opponent_action
        elif opponent_creature.speed > player_creature.speed:
            return opponent_action, player_action
        else:
            return random.sample([player_action, opponent_action], 2)

    def _execute_skill(self, attacker: Creature, skill: Skill):
        defender = self.opponent_creature if attacker == self.player_creature else self.player_creature
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        type_factor = self._get_type_factor(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_factor)
        defender.hp = max(0, defender.hp - final_damage)

        self._show_text(self.player, f"{attacker.display_name} uses {skill.display_name}!")
        self._show_text(self.player, f"It deals {final_damage} damage to {defender.display_name}!")

    def _get_type_factor(self, skill_type: str, defender_type: str) -> float:
        if skill_type == "normal":
            return 1.0
        elif skill_type == "fire" and defender_type == "leaf":
            return 2.0
        elif skill_type == "water" and defender_type == "fire":
            return 2.0
        elif skill_type == "leaf" and defender_type == "water":
            return 2.0
        elif skill_type == "fire" and defender_type == "water":
            return 0.5
        elif skill_type == "water" and defender_type == "leaf":
            return 0.5
        elif skill_type == "leaf" and defender_type == "fire":
            return 0.5
        else:
            return 1.0

    def _check_battle_end(self) -> bool:
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player_creature.display_name} fainted! You lose!")
            return True
        elif self.opponent_creature.hp <= 0:
            self._show_text(self.player, f"{self.opponent_creature.display_name} fainted! You win!")
            return True
        return False

    def _play_again(self) -> bool:
        play_again_button = Button("Play Again")
        quit_button = Button("Quit")
        choices = [play_again_button, quit_button]
        choice = self._wait_for_choice(self.player, choices)

        if choice == play_again_button:
            return True
        elif choice == quit_button:
            self._transition_to_scene("MainMenuScene")
            return False
```

This solution addresses the issue by:

1. Implementing a new `_execute_turn` method that handles the turn-based logic for both player and opponent.
2. Adding a `_determine_turn_order` method that decides which creature goes first based on their speed stats, with random selection for equal speeds.
3. Restructuring the battle loop to use the new turn order system.
4. Separating the player's skill selection into a `_player_choose_skill` method for clarity.

These changes ensure that the speed-based turn order and random decision-making for equal speed are properly implemented, addressing the issue raised during QA/testing while staying within the capabilities of the engine and maintaining the existing model structure.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "014cdf85-fc72-417a-a6c1-8fdcaa59a902", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
