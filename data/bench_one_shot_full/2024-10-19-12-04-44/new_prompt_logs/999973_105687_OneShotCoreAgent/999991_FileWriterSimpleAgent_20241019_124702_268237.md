Role: system
Content: You are a helpful assistant specialized in changing files based on proposed changes.
__________________
Role: user
Content: 
## Proposed Code Change
I apologize for overlooking the speed-based resolution logic in the previous implementation. I'll describe how to fix this issue and then provide the updated MainGameScene file.

1. Description of the fix:

To implement the speed-based resolution logic in the MainGameScene, we'll make the following changes:

a. Instead of executing skills immediately after each player's turn, we'll queue the chosen skills for both the player and the opponent.

b. After both skills are queued, we'll compare the speed of both creatures to determine the order of skill execution.

c. We'll execute the skills in the determined order, applying damage and checking for battle end conditions after each skill execution.

d. If a creature faints after the first skill, the second skill won't be executed.

These changes will ensure that the speed attribute of the creatures is taken into account during the battle, as specified in the architecture.

Now, I'll rewrite the MainGameScene file with the proposed solution:

# Excerpt ID: e6fa2379-1b16-4315-93a2-aaa75629e2b5
```python main_game/scenes/main_game_scene.py
from mini_game_engine.engine.lib import AbstractGameScene, Button, SelectThing
from main_game.models import Player, Creature, Skill
import random

class MainGameScene(AbstractGameScene):
    def __init__(self, app, player):
        super().__init__(app, player)
        self.opponent = self._app.create_bot("basic_opponent")
        self.player_creature = self.player.creatures[0]
        self.opponent_creature = self.opponent.creatures[0]

    def __str__(self):
        return f"""===Battle===
{self.player.display_name}'s {self.player_creature.display_name} (HP: {self.player_creature.hp}/{self.player_creature.max_hp})
VS
{self.opponent.display_name}'s {self.opponent_creature.display_name} (HP: {self.opponent_creature.hp}/{self.opponent_creature.max_hp})

Your skills:
{self._format_skills(self.player_creature.skills)}
"""

    def _format_skills(self, skills):
        return "\n".join([f"> {skill.display_name}" for skill in skills])

    def run(self):
        self._show_text(self.player, f"A wild {self.opponent_creature.display_name} appears!")
        while True:
            player_skill = self._player_turn()
            opponent_skill = self._opponent_turn()
            
            if self._resolve_turn(player_skill, opponent_skill):
                self._show_battle_result()
                self._return_to_main_menu()
                break

    def _player_turn(self) -> Skill:
        self._show_text(self.player, "Your turn!")
        choices = [SelectThing(skill, label=skill.display_name) for skill in self.player_creature.skills]
        choice = self._wait_for_choice(self.player, choices)
        return choice.thing

    def _opponent_turn(self) -> Skill:
        self._show_text(self.player, f"{self.opponent.display_name}'s turn!")
        return random.choice(self.opponent_creature.skills)

    def _resolve_turn(self, player_skill: Skill, opponent_skill: Skill) -> bool:
        first_creature, second_creature = self._determine_order()
        first_skill = player_skill if first_creature == self.player_creature else opponent_skill
        second_skill = opponent_skill if first_creature == self.player_creature else player_skill

        self._execute_skill(first_creature, second_creature, first_skill)
        if self._check_battle_end():
            return True

        self._execute_skill(second_creature, first_creature, second_skill)
        return self._check_battle_end()

    def _determine_order(self) -> tuple[Creature, Creature]:
        if self.player_creature.speed > self.opponent_creature.speed:
            return self.player_creature, self.opponent_creature
        elif self.player_creature.speed < self.opponent_creature.speed:
            return self.opponent_creature, self.player_creature
        else:
            return random.choice([(self.player_creature, self.opponent_creature),
                                  (self.opponent_creature, self.player_creature)])

    def _execute_skill(self, attacker: Creature, defender: Creature, skill: Skill):
        raw_damage = attacker.attack + skill.base_damage - defender.defense
        type_factor = self._get_type_factor(skill.skill_type, defender.creature_type)
        final_damage = int(raw_damage * type_factor)
        defender.hp = max(0, defender.hp - final_damage)

        self._show_text(self.player, f"{attacker.display_name} uses {skill.display_name}!")
        self._show_text(self.player, f"It deals {final_damage} damage to {defender.display_name}!")

    def _get_type_factor(self, skill_type: str, defender_type: str) -> float:
        if skill_type == "normal":
            return 1.0
        elif skill_type == "fire" and defender_type == "leaf":
            return 2.0
        elif skill_type == "water" and defender_type == "fire":
            return 2.0
        elif skill_type == "leaf" and defender_type == "water":
            return 2.0
        elif skill_type == "fire" and defender_type == "water":
            return 0.5
        elif skill_type == "water" and defender_type == "leaf":
            return 0.5
        elif skill_type == "leaf" and defender_type == "fire":
            return 0.5
        else:
            return 1.0

    def _check_battle_end(self) -> bool:
        return self.player_creature.hp <= 0 or self.opponent_creature.hp <= 0

    def _show_battle_result(self):
        if self.player_creature.hp <= 0:
            self._show_text(self.player, f"{self.player_creature.display_name} fainted! You lose!")
        else:
            self._show_text(self.player, f"{self.opponent_creature.display_name} fainted! You win!")

    def _return_to_main_menu(self):
        return_button = Button("Return to Main Menu")
        choice = self._wait_for_choice(self.player, [return_button])
        if choice == return_button:
            self._transition_to_scene("MainMenuScene")
```

This updated implementation of the MainGameScene now correctly incorporates the speed-based resolution logic as described in the architecture. The main changes are:

1. The `run` method now collects skills from both the player and opponent before resolving the turn.
2. A new `_resolve_turn` method handles the order of skill execution based on creature speeds.
3. The `_determine_order` method decides which creature goes first based on their speed attributes.
4. Skills are executed in the determined order, with battle end checks after each skill execution.

These changes ensure that the speed attribute of the creatures is properly taken into account during battles, addressing the issue raised in the QA/testing phase.

## Directions
Reply with a JSON list of actions to perform. 'overwrite' are the only valid action type. 
Make sure you are using the excerpt_id which contains the entire contents of the file

Examples:
overwriting files (this works for python, markdown, or any other file type)
```json output_example1
[{"action": "overwrite", "excerpt_id": "<id>", "file_path": "<relative file path>"}]
```

__________________
Role: assistant
Content: ```json
[{"action": "overwrite", "excerpt_id": "e6fa2379-1b16-4315-93a2-aaa75629e2b5", "file_path": "main_game/scenes/main_game_scene.py"}]
```
__________________
